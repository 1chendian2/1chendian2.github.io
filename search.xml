<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo故障收录</title>
      <link href="/2025/06/04/Hexo%E6%95%85%E9%9A%9C%E6%94%B6%E5%BD%95/"/>
      <url>/2025/06/04/Hexo%E6%95%85%E9%9A%9C%E6%94%B6%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Introductory"><a href="#Introductory" class="headerlink" title="Introductory"></a>Introductory</h2><p>Due to the mess as well as uneven on the internet,I decide to collect effective and efficient methods to address and dispose of disgusting problens.<br>I am pleasure to accept everyone of you precious opinions.</p><h2 id="hexo-deploy-上传报错"><a href="#hexo-deploy-上传报错" class="headerlink" title="hexo deploy 上传报错"></a>hexo deploy 上传报错</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect to host github.com port 22: Connection refused</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[33mError: Spawn failed     </span><br><span class="line">at ChildProcess.&lt;anonymous&gt; (D:\Blog\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)     </span><br><span class="line">at ChildProcess.emit (node:events:524:28)     </span><br><span class="line">at cp.emit (D:\Blog\node_modules\cross-spawn\lib\enoent.js:34:29)     </span><br><span class="line">at ChildProcess._handle.onexit (node:internal/child_process:293:12)[39m</span><br></pre></td></tr></table></figure><h3 id="首先说明"><a href="#首先说明" class="headerlink" title="首先说明"></a>首先说明</h3><p>当hexo发生错误时，应该首先看出错的原因（第一栏代码），而非hexo出错的位置（第二栏代码）。笔者认为在不改动系统文件的情况下，不必去排查系统文件错误。</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>ssh: connect to host github.com port 22: Connection refused这个错误提示的是连接github.com的22端口被拒绝了。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>使用GitHub的443端口</strong><br>22端口可能被防火墙屏蔽了，可以尝试连接GitHub的443端口。</p><ol><li>这个方案有效的前提是：执行命令<code>ssh -T -p 443 git@ssh.github.com</code>后不再提示connection refused。</li><li>打开文件资源管理器：<code>C:</code>-&gt;<code>用户</code>-&gt;<code>用户名</code>-&gt;<code>.ssh</code></li><li>新建<code>config</code>文件（无后缀）</li><li>添加</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure><ol start="5"><li>修改完config文件后，使用<code>ssh -T git@github.com</code>来测试和GitHub的网络通信是否正常，如果提示<code>Hi xxxxx! You&#39;ve successfully authenticated, but GitHub does notprovide shell access.</code> 就表示一切正常了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>呼和浩特旅行</title>
      <link href="/2025/06/02/%E5%91%BC%E5%92%8C%E6%B5%A9%E7%89%B9%E6%97%85%E8%A1%8C/"/>
      <url>/2025/06/02/%E5%91%BC%E5%92%8C%E6%B5%A9%E7%89%B9%E6%97%85%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="到新郑机场"><a href="#到新郑机场" class="headerlink" title="到新郑机场"></a>到新郑机场</h2><p>从焦作到新郑机场：公交+动车<br><img src="/img/2025_6_2/003.png" alt="404"></p><h2 id="第一次坐飞机，激动"><a href="#第一次坐飞机，激动" class="headerlink" title="第一次坐飞机，激动"></a>第一次坐飞机，激动</h2><p><img src="/img/2025_6_2/004.png" alt="404"><br>起飞时、遇颠簸时：我再也不坐飞机了<br>下飞机时：哎妈呀，飞机还是块呀</p><h2 id="呃呃，为何一下飞机，坐的地铁上全是广告，有些无语"><a href="#呃呃，为何一下飞机，坐的地铁上全是广告，有些无语" class="headerlink" title="呃呃，为何一下飞机，坐的地铁上全是广告，有些无语"></a>呃呃，为何一下飞机，坐的地铁上全是广告，有些无语</h2><p><img src="/img/2025_6_2/005.png" alt="404"></p><h2 id="草间弥生"><a href="#草间弥生" class="headerlink" title="草间弥生"></a>草间弥生</h2><p><img src="/img/2025_6_2/006.png" alt="404"></p><h2 id="我对韩国感兴趣"><a href="#我对韩国感兴趣" class="headerlink" title="我对韩国感兴趣"></a>我对韩国感兴趣</h2><p><img src="/img/2025_6_2/007.png" alt="404"></p><h2 id="喜德盛自行车，很好，我的GT300骑起来很带劲"><a href="#喜德盛自行车，很好，我的GT300骑起来很带劲" class="headerlink" title="喜德盛自行车，很好，我的GT300骑起来很带劲"></a>喜德盛自行车，很好，我的GT300骑起来很带劲</h2><p><img src="/img/2025_6_2/018.png" alt="404"></p><h2 id="好天气"><a href="#好天气" class="headerlink" title="好天气"></a>好天气</h2><p><img src="/img/2025_6_2/008.png" alt="404"></p><h2 id="一晚上速通7个商场，时间紧，任务重"><a href="#一晚上速通7个商场，时间紧，任务重" class="headerlink" title="一晚上速通7个商场，时间紧，任务重"></a>一晚上速通7个商场，时间紧，任务重</h2><p><img src="/img/2025_6_2/019.png" alt="404"></p><h2 id="艺术学院，保安不让我进"><a href="#艺术学院，保安不让我进" class="headerlink" title="艺术学院，保安不让我进"></a>艺术学院，保安不让我进</h2><p><img src="/img/2025_6_2/009.png" alt="404"></p><h2 id="国家公园，没啥东西，但是值得爬爬山看看风景"><a href="#国家公园，没啥东西，但是值得爬爬山看看风景" class="headerlink" title="国家公园，没啥东西，但是值得爬爬山看看风景"></a>国家公园，没啥东西，但是值得爬爬山看看风景</h2><p><img src="/img/2025_6_2/010.png" alt="404"></p><h2 id="内蒙古艺术馆最喜欢的画，本人钟意蓝色调的画"><a href="#内蒙古艺术馆最喜欢的画，本人钟意蓝色调的画" class="headerlink" title="内蒙古艺术馆最喜欢的画，本人钟意蓝色调的画"></a>内蒙古艺术馆最喜欢的画，本人钟意蓝色调的画</h2><p><img src="/img/2025_6_2/011.png" alt="404"></p><h2 id="艺术馆，一大学生做的毕设，作品名：藏宝箱。看一次笑一次，感觉回到了古代，贵重的东西不会放这，不贵的更不会放这。"><a href="#艺术馆，一大学生做的毕设，作品名：藏宝箱。看一次笑一次，感觉回到了古代，贵重的东西不会放这，不贵的更不会放这。" class="headerlink" title="艺术馆，一大学生做的毕设，作品名：藏宝箱。看一次笑一次，感觉回到了古代，贵重的东西不会放这，不贵的更不会放这。"></a>艺术馆，一大学生做的毕设，作品名：藏宝箱。看一次笑一次，感觉回到了古代，贵重的东西不会放这，不贵的更不会放这。</h2><p><img src="/img/2025_6_2/020.png" alt="404"></p><h2 id="IOT"><a href="#IOT" class="headerlink" title="IOT"></a>IOT</h2><p><img src="/img/2025_6_2/012.png" alt="404"></p><h2 id="不要放大看（摄于内蒙古科技馆，无任何不良引导，仅限于人体穴位交流学习）"><a href="#不要放大看（摄于内蒙古科技馆，无任何不良引导，仅限于人体穴位交流学习）" class="headerlink" title="不要放大看（摄于内蒙古科技馆，无任何不良引导，仅限于人体穴位交流学习）"></a>不要放大看（摄于内蒙古科技馆，无任何不良引导，仅限于人体穴位交流学习）</h2><p><img src="/img/2025_6_2/013.png" alt="404"></p><h2 id="号外！男大学生在空间站刷抖音！"><a href="#号外！男大学生在空间站刷抖音！" class="headerlink" title="号外！男大学生在空间站刷抖音！"></a>号外！男大学生在空间站刷抖音！</h2><p><img src="/img/2025_6_2/014.png" alt="404"></p><h2 id="退房尽量整理下，善始善终"><a href="#退房尽量整理下，善始善终" class="headerlink" title="退房尽量整理下，善始善终"></a>退房尽量整理下，善始善终</h2><p><img src="/img/2025_6_2/015.png" alt="404"></p><h2 id="再见，HOHHOT"><a href="#再见，HOHHOT" class="headerlink" title="再见，HOHHOT"></a>再见，HOHHOT</h2><p><img src="/img/2025_6_2/016.png" alt="404"></p><h2 id="一碗米要我9块人民币啊，金子做的吧"><a href="#一碗米要我9块人民币啊，金子做的吧" class="headerlink" title="一碗米要我9块人民币啊，金子做的吧"></a>一碗米要我9块人民币啊，金子做的吧</h2><p><img src="/img/2025_6_2/017.png" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（408考研）</title>
      <link href="/2025/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88408%E8%80%83%E7%A0%94%EF%BC%89/"/>
      <url>/2025/06/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88408%E8%80%83%E7%A0%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>一个进程（Process）是计算机中正在运行的程序的实例，它由以下核心组成部分构成：</p><ol><li>PCB（Process Control Block，进程控制块）</li></ol><ul><li>进程ID（PID）、父进程ID（PPID）</li><li>进程状态（运行、就绪、阻塞等）</li></ul><ol start="2"><li>代码段（Text Segment）</li><li>数据段（Data Segment）</li></ol><ul><li>程序执行的实体。没有代码，进程无法运行；没有数据，代码无法处理信息。</li></ul><h3 id="PCB内主要有什么"><a href="#PCB内主要有什么" class="headerlink" title="PCB内主要有什么"></a>PCB内主要有什么</h3><ol><li>进程标识信息：PID</li><li>进程状态信息：运行（Running）、就绪（Ready）、阻塞（Blocked）等</li><li>CPU上下文信息（状态）：（进程被切换时，保存当前CPU状态以便恢复）PC、SP</li><li>等</li></ol><h3 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h3><ul><li>区分就绪态与阻塞态</li><li>主动&#x2F;被动的转换</li></ul><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol><li><p><strong>分配PID与PCB</strong>  </p><ul><li>操作系统为新进程分配唯一的进程ID（PID）和空的进程控制块（PCB）。  </li><li><em>例子</em>：在终端输入 <code>ls</code> 命令时，Shell（父进程）调用 <code>fork()</code> 创建子进程，内核为其分配PCB。</li></ul></li><li><p><strong>分配资源</strong>  </p><ul><li>子进程继承父进程的资源（如文件描述符、内存映射），或从操作系统申请新资源。  </li><li><em>例子</em>：子进程通过 <code>exec()</code> 加载 <code>ls</code> 程序时，需申请内存存储代码和数据。</li></ul></li><li><p><strong>初始化PCB</strong>  </p><ul><li>设置进程状态（就绪）、程序计数器（PC）、堆栈指针等。</li></ul></li><li><p><strong>加入就绪队列</strong>  </p><ul><li>新进程被放入调度队列<strong>等待</strong>CPU分配。</li></ul></li></ol><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><h4 id="终止原因："><a href="#终止原因：" class="headerlink" title="终止原因："></a>终止原因：</h4><ul><li><strong>正常终止</strong>：进程执行完毕（如 <code>main()</code> 返回）。  </li><li><strong>异常终止</strong>：段错误（访问非法内存）、除零错误、被 <code>kill</code> 命令杀死。</li></ul><h4 id="终止步骤："><a href="#终止步骤：" class="headerlink" title="终止步骤："></a>终止步骤：</h4><ol><li>触发终止：exit()、信号、父进程终止</li><li>释放资源：内存、文件、锁、设备等</li><li>更新 PCB：状态改为 Zombie，记录退出状态</li><li>通知父进程：父进程 wait() 或由 init 接管</li><li>删除 PCB</li></ol><h3 id="进程阻塞与唤醒"><a href="#进程阻塞与唤醒" class="headerlink" title="进程阻塞与唤醒"></a>进程阻塞与唤醒</h3><h4 id="1-阻塞（主动行为）"><a href="#1-阻塞（主动行为）" class="headerlink" title="1. 阻塞（主动行为）"></a>1. <strong>阻塞（主动行为）</strong></h4><ul><li><strong>触发条件</strong>：进程主动调用阻塞操作（如 <code>read()</code> 等待I&#x2F;O）。  </li><li><strong>过程</strong>：  <ol><li>进程从运行态转为阻塞态，PCB加入等待队列。  </li><li>CPU调度其他就绪进程。</li></ol></li></ul><h4 id="2-唤醒（被动行为）"><a href="#2-唤醒（被动行为）" class="headerlink" title="2. 唤醒（被动行为）"></a>2. <strong>唤醒（被动行为）</strong></h4><ul><li><strong>触发条件</strong>：外部事件发生（如I&#x2F;O完成、信号量释放）。  </li><li><strong>过程</strong>：  <ol><li>内核将对应PCB从阻塞队列移到就绪队列。  </li><li>进程重新等待调度。</li></ol></li></ul><p><em>例子</em>：  </p><ul><li>当磁盘I&#x2F;O完成时，硬件触发中断，操作系统唤醒等待该I&#x2F;O的进程。</li></ul><h4 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h4><ol><li><p><strong>阻塞是主动的，唤醒是被动的</strong>：  </p><ul><li>阻塞是进程<strong>主动请求等待</strong>（如调用 <code>sleep()</code>），而唤醒依赖外部事件（如定时器中断）。</li></ul></li><li><p><strong>资源泄漏</strong>：  </p><ul><li>终止进程时若未释放资源（如内存泄漏），会导致系统资源耗尽。</li></ul></li><li><p>进程调度负责分配CPU资源，而非进程创建<br>进程调度（Process Scheduling）是操作系统内核的核心功能之一，负责从多个就绪（Ready）的进程中选择一个进程分配CPU资源，并控制进程状态的切换。其本质是解决CPU资源的分配问题，确保系统高效、公平地运行多个程序。</p></li></ol><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ol><li>共享存储：原理：多个进程访问同一块内存区域，直接读写数据，速度最快（无需内核介入）。</li><li>消息传递：原理：进程通过发送&#x2F;接收消息（数据包（HTTP））通信，由内核中转。</li><li>管道通信：管道是一种特殊的文件：又称pipe文件。管道不满即可发、管道不空即可收</li></ol><h3 id="如何理解“进程获得处理器运行是通过调度得到的”？"><a href="#如何理解“进程获得处理器运行是通过调度得到的”？" class="headerlink" title="如何理解“进程获得处理器运行是通过调度得到的”？"></a>如何理解“进程获得处理器运行是通过调度得到的”？</h3><p>这句话的核心含义是：在操作系统中，进程不能直接占用 CPU，而是必须由操作系统的调度程序（Scheduler）决定哪个进程可以运行、何时运行以及运行多久。</p><h3 id="并发程序的执行速度与调度策略的关系"><a href="#并发程序的执行速度与调度策略的关系" class="headerlink" title="并发程序的执行速度与调度策略的关系"></a>并发程序的执行速度与调度策略的关系</h3><p>并发程序的执行速度并非单纯由CPU性能决定，调度策略的合理配置（如时间片（短时间片提高响应速度，长时间片提高吞吐量。）、算法选择（FCFS适合长任务，RR适合交互式任务。））同样关键</p><h3 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h3><p>高级调度的核心功能是 将作业从磁盘加载到内存并创建进程，因此 一定会导致新进程创建</p><h3 id="为什么分时操作系统中，就绪态的任务最多？"><a href="#为什么分时操作系统中，就绪态的任务最多？" class="headerlink" title="为什么分时操作系统中，就绪态的任务最多？"></a>为什么分时操作系统中，就绪态的任务最多？</h3><p>分时操作系统的主要目标是：公平共享CPU时间（每个任务轮流执行一小段时间）。</p><h3 id="实时操作系统阻塞态任务最多"><a href="#实时操作系统阻塞态任务最多" class="headerlink" title="实时操作系统阻塞态任务最多"></a>实时操作系统阻塞态任务最多</h3><p>因为：</p><ol><li>任务多为事件&#x2F;周期驱动，大部分时间在等待触发条件。</li><li>高优先级任务抢占CPU，低优先级任务长期阻塞。</li><li>资源同步机制（如锁、信号量）强制任务阻塞等待。</li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><img src="/img/2025_6_2/001.png" alt="404"><br>进程-资源分配的基本单位<br>线程-现代OS中CPU调度和分派的最小单位</p><h3 id="系统线程-vs-用户线程"><a href="#系统线程-vs-用户线程" class="headerlink" title="系统线程 vs 用户线程"></a>系统线程 vs 用户线程</h3><p><img src="/img/2025_6_2/002.png" alt="404"></p><ul><li><p>用系统线程：<br>需要真并发（如视频编码、科学计算）。<br>线程可能频繁阻塞（如网络服务）。</p></li><li><p>用用户线程：<br>轻量级任务（如快速切换的小任务）。<br>语言或环境限制（如Python的GIL）。</p></li></ul><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>MLFQ的核心三点：</p><ol><li>优先级队列：高优先级处理短任务，低优先级处理长任务。</li><li>动态降级：霸占CPU的任务会被“惩罚”到低优先级。</li><li>奖励交互：频繁让出CPU的任务（如I&#x2F;O）保持高优先级。&#x2F;&#x2F; 以下举例</li></ol><ul><li>第一轮调度：X用了5ms后发起I&#x2F;O请求（如加载图片）→ 保持Q0（因为主动释放了CPU）。</li><li>第二轮调度：X从I&#x2F;O返回后，仍在 Q0，继续优先执行</li></ul><h3 id="利用信号量实现互斥"><a href="#利用信号量实现互斥" class="headerlink" title="利用信号量实现互斥"></a>利用信号量实现互斥</h3><p><img src="/img/2025_6_4/001.png" alt="404"></p><h3 id="利用信号量实现同步"><a href="#利用信号量实现同步" class="headerlink" title="利用信号量实现同步"></a>利用信号量实现同步</h3><p><img src="/img/2025_6_4/002.png" alt="404"><br>通过信号量，原本异步的进程可以像齿轮一样精准咬合，实现复杂的协作逻辑！</p><h3 id="利用信号量实现前驱关系"><a href="#利用信号量实现前驱关系" class="headerlink" title="利用信号量实现前驱关系"></a>利用信号量实现前驱关系</h3><p><img src="/img/2025_6_4/003.png" alt="404"></p><h3 id="生产者-消费者问题：为什么-PV-操作顺序很重要？"><a href="#生产者-消费者问题：为什么-PV-操作顺序很重要？" class="headerlink" title="生产者-消费者问题：为什么 PV 操作顺序很重要？"></a><strong>生产者-消费者问题：为什么 PV 操作顺序很重要？</strong></h3><p><strong>（1）生产者顺序：<code>P(empty)</code> → <code>P(mutex)</code></strong></p><ul><li>如果先 <code>P(mutex)</code> 再 <code>P(empty)</code>：<ul><li>生产者拿到锁后，发现缓冲区满，会阻塞在 <code>P(empty)</code>。</li><li>但锁未释放，消费者无法消费，导致<strong>死锁</strong>。</li></ul></li></ul><p><strong>（2）消费者顺序：<code>P(full)</code> → <code>P(mutex)</code></strong></p><ul><li>如果先 <code>P(mutex)</code> 再 <code>P(full)</code>：<ul><li>消费者拿到锁后，发现缓冲区空，会阻塞在 <code>P(full)</code>。</li><li>但锁未释放，生产者无法生产，导致<strong>死锁</strong>。</li></ul></li></ul><p><strong>结论</strong>：<strong>同步信号量（<code>empty</code>&#x2F;<code>full</code>）必须先于互斥信号量（<code>mutex</code>）申请</strong>，否则可能死锁。</p><h3 id="读者-写者"><a href="#读者-写者" class="headerlink" title="读者-写者"></a>读者-写者</h3><p>为什么这是“相对”写者优先？</p><p>阻塞队列的公平性：</p><ul><li>若读者A和写者B同时请求：读者A先执行 P(w)，成功进入。写者B执行 P(w)，被阻塞。读者A完成 V(w) 后，唤醒的是阻塞队列的队首进程（可能是另一个读者C，而非写者B）。</li><li>结果：写者B可能仍需等待多个读者完成后才能执行，因此是相对优先而非绝对优先。</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p> <strong>管程（Monitor）详解</strong></p><p>管程（Monitor）是一种<strong>高级进程同步工具</strong>，由编程语言或操作系统提供，用于解决信号量（Semaphore）在复杂同步问题中存在的<strong>死锁风险高、代码分散</strong>等问题。其核心思想是：<br><strong>将共享资源及其操作封装为一个模块，自动实现互斥访问，并通过条件变量（Condition Variables）实现灵活的进程同步</strong>。</p><hr><h4 id="为什么需要管程？"><a href="#为什么需要管程？" class="headerlink" title="为什么需要管程？"></a><strong>为什么需要管程？</strong></h4><p> <strong>信号量的缺陷</strong></p><ol><li><strong>PV操作分散</strong>：每个进程需自行编写PV代码，容易遗漏或顺序错误。</li><li><strong>死锁风险高</strong>：如错误嵌套PV操作（如先 <code>P(mutex)</code> 再 <code>P(empty)</code>）。</li><li><strong>可维护性差</strong>：同步逻辑与业务逻辑混杂，代码难以理解。</li></ol><p> <strong>管程的优势</strong></p><ul><li><strong>内置互斥</strong>：管程的过程（函数）<strong>自动保证互斥执行</strong>（同一时间仅一个进程进入管程）。</li><li><strong>条件变量</strong>：通过 <code>wait()</code> 和 <code>signal()</code> 实现进程阻塞与唤醒，避免忙等待。</li><li><strong>代码模块化</strong>：同步逻辑集中在管程内，业务逻辑更清晰。</li></ul><hr><h4 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a><strong>管程的组成</strong></h4><p>管程的定义包含以下4部分：</p><table><thead><tr><th>组成部分</th><th>说明</th></tr></thead><tbody><tr><td><strong>① 管程名称</strong></td><td>例如 <code>monitor Demo</code>。</td></tr><tr><td><strong>② 共享数据结构</strong></td><td>描述资源的抽象数据（如缓冲区、计数器等）。</td></tr><tr><td><strong>③ 操作共享数据的函数</strong></td><td>提供对资源的访问接口（如 <code>take_away()</code>、<code>give_back()</code>）。</td></tr><tr><td><strong>④ 同步工具</strong></td><td>如条件变量、互斥锁</td></tr></tbody></table><p> <strong>示例代码</strong></p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo                  <span class="comment">// ① 管程名称</span></span><br><span class="line">    shared int S;             <span class="comment">// ② 共享数据结构（资源计数器）</span></span><br><span class="line">    condition not_empty;      <span class="comment">// 条件变量（用于同步）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">take_away</span><span class="params">()</span> <span class="comment">&#123;   // ③ 操作过程1：申请资源</span></span></span><br><span class="line"><span class="comment"><span class="function">        if (S &lt;= 0) wait(not_empty);  // 资源不足时阻塞</span></span></span><br><span class="line"><span class="comment"><span class="function">        S--;                  // 占用资源</span></span></span><br><span class="line"><span class="comment"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">procedure</span> <span class="title">give_back</span><span class="params">()</span> <span class="comment">&#123;   // ③ 操作过程2：释放资源</span></span></span><br><span class="line"><span class="comment"><span class="function">        S++;                  // 释放资源</span></span></span><br><span class="line"><span class="comment"><span class="function">        signal(not_empty);    // 唤醒等待的进程</span></span></span><br><span class="line"><span class="comment"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">init_code</span><span class="params">()</span> <span class="comment">&#123; S = 5; &#125;</span>    <span class="comment">// ④ 初始化资源数为5</span></span></span><br><span class="line"><span class="function"><span class="title">end</span> <span class="title">monitor</span></span></span><br></pre></td></tr></table></figure><hr><h4 id="管程的核心机制"><a href="#管程的核心机制" class="headerlink" title="管程的核心机制"></a><strong>管程的核心机制</strong></h4><p> <strong>（1）互斥访问</strong></p><ul><li><strong>管程的过程（如 <code>take_away()</code>）自动互斥执行</strong>：<br>当一个进程进入管程时，其他进程必须等待其退出后才能进入。</li></ul><p> <strong>（2）条件变量（Condition Variables）</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td><code>wait(c)</code></td><td>当前进程阻塞在条件变量 <code>c</code> 上，并释放管程的互斥锁。</td></tr><tr><td><code>signal(c)</code></td><td>唤醒一个在条件变量 <code>c</code> 上等待的进程（若无等待进程，则不产生效果）。</td></tr></tbody></table><p><strong>关键区别</strong>：  </p><ul><li>信号量机制中的 V 操作：唤醒一个因等待该信号量而阻塞的进程，若没有阻塞进程，则信号量值加 1。</li><li>管程中的 signal 操作：若当前有进程在条件变量上阻塞，唤醒其中一个进程；若没有阻塞进程，该 signal 操作直接失效（不积累效果），而不像信号量的 V 操作那样会累积信号量值。<br>因此，两者的作用并不完全相同。</li></ul><hr><h4 id="管程-vs-信号量"><a href="#管程-vs-信号量" class="headerlink" title="管程 vs. 信号量"></a><strong>管程 vs. 信号量</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>管程（Monitor）</strong></th><th><strong>信号量（Semaphore）</strong></th></tr></thead><tbody><tr><td><strong>互斥实现</strong></td><td>自动（由管程保证）</td><td>手动（显式调用 <code>P()</code>&#x2F;<code>V()</code>）</td></tr><tr><td><strong>同步机制</strong></td><td>条件变量（<code>wait</code>&#x2F;<code>signal</code>）</td><td>PV操作（<code>P()</code>&#x2F;<code>V()</code>）</td></tr><tr><td><strong>死锁风险</strong></td><td>低（内置互斥，逻辑集中）</td><td>高（PV顺序错误易导致死锁）</td></tr><tr><td><strong>代码复杂度</strong></td><td>低（同步逻辑封装在管程内）</td><td>高（分散在各进程中）</td></tr><tr><td><strong>适用场景</strong></td><td>高级语言（如Java的<code>synchronized</code>）</td><td>底层系统编程（如操作系统内核）</td></tr></tbody></table><hr><h4 id="经典问题：用管程实现生产者-消费者"><a href="#经典问题：用管程实现生产者-消费者" class="headerlink" title="经典问题：用管程实现生产者-消费者"></a><strong>经典问题：用管程实现生产者-消费者</strong></h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int buffer[N], count = 0;</span></span><br><span class="line"><span class="comment">    condition not_full, not_empty;  // 两个条件变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    procedure produce(item) &#123;</span></span><br><span class="line"><span class="comment">        if (count == N) wait(not_full);  // 缓冲区满则等待</span></span><br><span class="line"><span class="comment">        buffer[count] = item;</span></span><br><span class="line"><span class="comment">        count++;</span></span><br><span class="line"><span class="comment">        signal(not_empty);  // 唤醒消费者</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">consume</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">        if (count == 0) wait(not_empty);  // 缓冲区空则等待</span></span></span><br><span class="line"><span class="comment"><span class="function">        item = buffer[count-1];</span></span></span><br><span class="line"><span class="comment"><span class="function">        count--;</span></span></span><br><span class="line"><span class="comment"><span class="function">        signal(not_full);  // 唤醒生产者</span></span></span><br><span class="line"><span class="comment"><span class="function">        return item;</span></span></span><br><span class="line"><span class="comment"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>优势</strong>：  </p><ul><li>生产者和消费者只需调用 <code>produce()</code> 和 <code>consume()</code>，无需关心互斥细节。</li><li>条件变量直接表达“缓冲区非空”和“缓冲区非满”的同步逻辑。</li></ul><hr><h4 id="管程的局限性"><a href="#管程的局限性" class="headerlink" title="管程的局限性"></a><strong>管程的局限性</strong></h4><ol><li><strong>语言依赖</strong>：需编程语言原生支持（如Java的 <code>synchronized</code>，Pascal的 <code>monitor</code>）。</li><li><strong>性能开销</strong>：管程的互斥和条件变量可能比信号量更耗时。</li><li><strong>灵活性不足</strong>：某些复杂场景（如嵌套同步）仍需结合其他机制。</li></ol><hr><h4 id="管程是被进程调用的，管程是语法范围，无法创建和撤销"><a href="#管程是被进程调用的，管程是语法范围，无法创建和撤销" class="headerlink" title="管程是被进程调用的，管程是语法范围，无法创建和撤销"></a>管程是被进程调用的，管程是语法范围，无法创建和撤销</h4><p>管程代码是固定的代码段，无法创建 &#x2F; 撤销：进程只能调用管程的现有过程，而不能像创建进程一样 “生成新的管程” 或 “删除已有的管程”。</p><h3 id="循环等待与死锁的关系解析"><a href="#循环等待与死锁的关系解析" class="headerlink" title="循环等待与死锁的关系解析"></a><strong>循环等待与死锁的关系解析</strong></h3><h4 id="循环等待的定义"><a href="#循环等待的定义" class="headerlink" title="循环等待的定义"></a><strong>循环等待的定义</strong></h4><p>循环等待是指存在一组进程 ({P_1, P_2, \cdots, P_n})，其中：</p><ul><li>(P_i) 持有的资源被 (P_{i+1}) 请求（(i&#x3D;1, 2, \cdots, n-1)）。</li><li>(P_n) 持有的资源被 (P_1) 请求，形成一个<strong>闭环等待链</strong>（如图2.13）。</li></ul><h4 id="循环等待-≠-死锁"><a href="#循环等待-≠-死锁" class="headerlink" title="循环等待 ≠ 死锁"></a><strong>循环等待 ≠ 死锁</strong></h4><p>虽然循环等待是死锁的<strong>必要条件</strong>，但<strong>并非充分条件</strong>。关键区别在于：</p><ul><li><strong>死锁的严格条件</strong>：<br>所有 (P_i) <strong>必须且只能</strong>从 (P_{i+1}) 获取资源（闭环内自给自足，无法被外部打破）。  </li><li><strong>循环等待的宽松条件</strong>：<br>进程可能从<strong>闭环外</strong>的其他进程获取资源（如图2.14中的 (P_K)），从而避免死锁。</li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a><strong>举例说明</strong></h4><h5 id="场景1：严格死锁（循环等待导致死锁）"><a href="#场景1：严格死锁（循环等待导致死锁）" class="headerlink" title="场景1：严格死锁（循环等待导致死锁）"></a><strong>场景1：严格死锁（循环等待导致死锁）</strong></h5><ul><li>(P_0) 持有 R1，请求 R2；  </li><li>(P_1) 持有 R2，请求 R1。<br><strong>结果</strong>：闭环内无外部资源可依赖，死锁必然发生。</li></ul><h5 id="场景2：循环等待但无死锁"><a href="#场景2：循环等待但无死锁" class="headerlink" title="场景2：循环等待但无死锁"></a><strong>场景2：循环等待但无死锁</strong></h5><ul><li>(P_0) 持有 R1，请求 R2；  </li><li>(P_1) 持有 R2，请求 R1 <strong>或 R3</strong>（R3被闭环外的 (P_K) 持有）。<br><strong>结果</strong>：若 (P_1) 选择请求 R3，且 (P_K) 释放 R3，则 (P_1) 可继续运行，闭环被打破，无死锁。</li></ul><h4 id="图解对比"><a href="#图解对比" class="headerlink" title="图解对比"></a><strong>图解对比</strong></h4><table><thead><tr><th><strong>图2.13（死锁）</strong></th><th><strong>图2.14（无死锁）</strong></th></tr></thead><tbody><tr><td>闭环内资源完全自循环，无外部依赖</td><td>闭环内进程可依赖外部资源（如 (P_K)）</td></tr><tr><td>必然死锁</td><td>可能避免死锁</td></tr></tbody></table><h4 id="核心结论"><a href="#核心结论" class="headerlink" title="核心结论"></a><strong>核心结论</strong></h4><ul><li><strong>循环等待是死锁的必要条件</strong>：所有死锁一定存在循环等待链。  </li><li><strong>但循环等待不必然导致死锁</strong>：若闭环内进程能通过外部资源解除等待，则系统仍可正常运行。  </li><li><strong>死锁的充分条件</strong>：循环等待 + <strong>资源完全闭环分配</strong>（无外部依赖）。</li></ul><h4 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a><strong>实际意义</strong></h4><ul><li><strong>死锁检测</strong>：仅发现循环等待链时，需进一步检查资源是否全部闭环。  </li><li><strong>死锁预防</strong>：允许进程从多来源申请资源（如银行家算法），可减少死锁概率。</li></ul><p><strong>简单说</strong>：<br>循环等待就像一群人围成一圈互相讨债，但如果有人能从圈外借到钱还债，圈子就能解开；若所有人只能靠圈内人还钱，就会僵持到底（死锁）。</p><h3 id="死锁处理三大策略详解"><a href="#死锁处理三大策略详解" class="headerlink" title="死锁处理三大策略详解"></a><strong>死锁处理三大策略详解</strong></h3><p>死锁的应对方法可分为三类，分别作用于死锁发生的不同阶段：</p><hr><h4 id="1-死锁预防（Prevention）"><a href="#1-死锁预防（Prevention）" class="headerlink" title="1. 死锁预防（Prevention）"></a><strong>1. 死锁预防（Prevention）</strong></h4><p><strong>核心思想</strong>：破坏死锁的四个必要条件中的至少一个，确保系统永远不会进入死锁状态。<br><strong>实现方式</strong>：  </p><table><thead><tr><th><strong>破坏条件</strong></th><th><strong>方法</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>互斥条件</strong></td><td>允许资源共享（如只读文件），但多数资源无法避免互斥。</td><td>适用性有限。</td></tr><tr><td><strong>请求并保持</strong></td><td>进程必须一次性申请所有资源，否则不分配（静态分配）。</td><td>资源利用率低，可能饥饿。</td></tr><tr><td><strong>不可剥脱条件</strong></td><td>若进程申请资源失败，则释放已占有的资源（回滚）。</td><td>实现复杂，开销大。</td></tr><tr><td><strong>循环等待条件（所有进程都在互相等待，谁都无法继续执行，形成“循环等待”。）</strong></td><td>强制资源按线性顺序申请（如所有进程必须先申请R1再申请R2）。</td><td>限制灵活性，可能浪费资源。</td></tr></tbody></table><p><strong>特点</strong>：严格但保守，可能降低系统吞吐量。</p><hr><h4 id="2-死锁避免（Avoidance）"><a href="#2-死锁避免（Avoidance）" class="headerlink" title="2. 死锁避免（Avoidance）"></a><strong>2. 死锁避免（Avoidance）</strong></h4><p><strong>核心思想</strong>：动态检查资源分配状态，确保系统始终处于<strong>安全状态</strong>（即存在至少一个进程执行序列不会导致死锁）。<br><strong>关键算法</strong>：  </p><ul><li><strong>银行家算法（Banker’s Algorithm）</strong>：  <ol><li>进程声明最大资源需求。  </li><li>分配资源前，模拟检查分配后系统是否仍安全。  </li><li>仅当安全时才分配资源。</li></ol></li></ul><p><strong>安全状态示例</strong>：<br>假设系统有10个内存块：  </p><ul><li>进程A已占4，最多需7；  </li><li>进程B已占2，最多需4；  </li><li>剩余4块。<br><strong>安全序列</strong>：B可先完成（需再2块），释放后A可完成（需再3块）。</li></ul><p><strong>特点</strong>：需预知进程最大需求，运行时开销大，适合资源类型少的场景。</p><hr><h4 id="3-死锁检测与恢复（Detection-Recovery）"><a href="#3-死锁检测与恢复（Detection-Recovery）" class="headerlink" title="3. 死锁检测与恢复（Detection &amp; Recovery）"></a><strong>3. 死锁检测与恢复（Detection &amp; Recovery）</strong></h4><p><strong>核心思想</strong>：允许死锁发生，但定期检测并解除。  </p><h5 id="（1）死锁检测"><a href="#（1）死锁检测" class="headerlink" title="（1）死锁检测"></a><strong>（1）死锁检测</strong></h5><ul><li><strong>资源分配图（RAG）算法</strong>：<br>构建有向图（进程→资源：申请边；资源→进程：分配边），检测图中是否存在环。  </li><li><strong>时间复杂度</strong>：(O(n^2))（n为进程数）。</li></ul><h5 id="（2）死锁恢复"><a href="#（2）死锁恢复" class="headerlink" title="（2）死锁恢复"></a><strong>（2）死锁恢复</strong></h5><table><thead><tr><th><strong>方法</strong></th><th><strong>操作</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>进程终止</strong></td><td>终止所有死锁进程，或逐个终止直至死锁解除。</td><td>代价高，可能丢失工作。</td></tr><tr><td><strong>资源抢占</strong></td><td>强制剥夺某进程资源分配给其他进程（需解决饥饿和回滚问题）。</td><td>实现复杂，可能引发级联终止。</td></tr></tbody></table><p><strong>特点</strong>：适合对死锁容忍度高的系统（如通用操作系统）。</p><hr><h4 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h4><table><thead><tr><th><strong>策略</strong></th><th><strong>时机</strong></th><th><strong>开销</strong></th><th><strong>资源利用率</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>预防</strong></td><td>事前</td><td>低</td><td>低</td><td>嵌入式系统、实时系统</td></tr><tr><td><strong>避免</strong></td><td>事中（动态）</td><td>高</td><td>高</td><td>已知最大需求的批处理系统</td></tr><tr><td><strong>检测与恢复</strong></td><td>事后</td><td>中</td><td>最高</td><td>通用操作系统（如Linux、Windows）</td></tr></tbody></table><hr><h4 id="如何选择策略？"><a href="#如何选择策略？" class="headerlink" title="如何选择策略？"></a><strong>如何选择策略？</strong></h4><ol><li><strong>严格实时系统</strong>：优先预防（如航空控制系统）。  </li><li><strong>高资源利用率需求</strong>：采用避免或检测（如数据库管理系统）。  </li><li><strong>通用系统</strong>：通常结合预防（部分条件）和检测（如Unix&#x2F;Linux默认不预防，仅定期检测）。</li></ol><p><strong>关键trade-off</strong>：安全性与性能的平衡！</p><h3 id="资源分配图（Resource-Allocation-Graph-RAG）判断系统是否处于死锁状态"><a href="#资源分配图（Resource-Allocation-Graph-RAG）判断系统是否处于死锁状态" class="headerlink" title="资源分配图（Resource Allocation Graph, RAG）判断系统是否处于死锁状态"></a>资源分配图（Resource Allocation Graph, RAG）判断系统是否处于死锁状态</h3><p>死锁的判断是通过简化资源分配图来完成的。方法如下：</p><ol><li>找出“可以执行完”的进程：</li></ol><p>找出满足可立即完成条件的进程 P：它请求的资源数量小于等于系统中可用的资源数 + 已分配给某些即将完成进程的资源数。</p><ol start="2"><li><p>删除满足条件的进程及其边（资源请求边和占有边）：</p></li><li><p>死锁的判断条件总结</p></li></ol><p>若图最终能被完全简化（所有节点和边都消除）→ 无死锁。<br>若图中还有剩余节点和边，即至少存在一个环路 → 死锁发生。</p><h3 id="循环等待条件的预防：资源有序分配法示例"><a href="#循环等待条件的预防：资源有序分配法示例" class="headerlink" title="循环等待条件的预防：资源有序分配法示例"></a><strong>循环等待条件的预防：资源有序分配法示例</strong></h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h4><p>通过强制所有进程<strong>按照统一的线性顺序申请资源</strong>，破坏循环等待条件。例如，规定资源类型为R1、R2、R3时，所有进程必须按 <strong>R1 → R2 → R3</strong> 的顺序申请，禁止反向或跳跃申请。</p><hr><h4 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a><strong>具体示例</strong></h4><p>假设系统中有三种资源：</p><ul><li><strong>打印机（R1）</strong></li><li><strong>扫描仪（R2）</strong></li><li><strong>磁盘（R3）</strong></li></ul><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a><strong>规则</strong>：</h4><p>所有进程必须按 <strong>R1 → R2 → R3</strong> 的顺序申请资源，不可逆序。</p><hr><h4 id="场景1：遵守顺序（无死锁）"><a href="#场景1：遵守顺序（无死锁）" class="headerlink" title="场景1：遵守顺序（无死锁）"></a><strong>场景1：遵守顺序（无死锁）</strong></h4><ul><li><strong>进程A</strong>：  <ol><li>申请打印机（R1）→ 成功。  </li><li>申请扫描仪（R2）→ 成功。  </li><li>申请磁盘（R3）→ 成功。</li></ol></li><li><strong>进程B</strong>：  <ol><li>申请打印机（R1）→ 阻塞（因被进程A占用）。</li></ol></li></ul><p><strong>结果</strong>：进程A完成后释放资源，进程B继续，<strong>不会形成循环等待</strong>。</p><hr><h4 id="场景2：违反顺序（可能死锁）"><a href="#场景2：违反顺序（可能死锁）" class="headerlink" title="场景2：违反顺序（可能死锁）"></a><strong>场景2：违反顺序（可能死锁）</strong></h4><p>若允许无序申请：</p><ul><li><strong>进程X</strong>：  <ol><li>先申请扫描仪（R2）→ 成功。  </li><li>再申请打印机（R1）→ 阻塞（假设被进程Y占用）。</li></ol></li><li><strong>进程Y</strong>：  <ol><li>先申请打印机（R1）→ 成功。  </li><li>再申请扫描仪（R2）→ 阻塞（被进程X占用）。</li></ol></li></ul><p><strong>结果</strong>：  </p><ul><li>进程X持有R2，等待R1；  </li><li>进程Y持有R1，等待R2；  </li><li><strong>循环等待 → 死锁</strong>。</li></ul><hr><h4 id="为什么有序分配能预防死锁？"><a href="#为什么有序分配能预防死锁？" class="headerlink" title="为什么有序分配能预防死锁？"></a><strong>为什么有序分配能预防死锁？</strong></h4><ul><li><strong>打破闭环</strong>：强制线性顺序后，进程只能单向等待资源（如R1→R2→R3），无法形成“A等B，B等A”的环路。  </li><li><strong>数学证明</strong>：若有环存在，则至少有一个进程违反了申请顺序，与规则矛盾。</li></ul><hr><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a><strong>实际应用</strong></h4><ul><li><strong>数据库系统</strong>：按固定顺序锁表（如先锁表A再锁表B）。  </li><li><strong>操作系统</strong>：文件系统按层级顺序加锁。</li></ul><p><strong>缺点</strong>：  </p><ul><li>可能降低灵活性（如进程必须提前申请所有高序资源，即使暂时不需要）。  </li><li>可能导致资源浪费（如进程A占用了R1但长时间不用，阻塞其他进程）。</li></ul><p><strong>总结</strong>：资源有序分配是简单有效的死锁预防手段，但需权衡效率与灵活性。</p><h3 id="临界资源（Critical-Resource）"><a href="#临界资源（Critical-Resource）" class="headerlink" title="临界资源（Critical Resource）"></a>临界资源（Critical Resource）</h3><p>不属于临界资源的选项：</p><ul><li>磁盘存储介质（Disk Storage Medium）</li></ul><p>虽然多个进程可以同时访问磁盘，但现代文件系统通常通过缓存、锁机制等方式管理并发访问，磁盘本身并非典型的临界资源。</p><ul><li>可重入的程序代码（Reentrant Code）</li></ul><p>可重入代码（Reentrant Code） 是指可以被多个线程或进程同时调用而不会导致数据不一致或错误的代码，可以被同时访问，但不能被修改。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可重入函数示例（仅使用局部变量）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 不依赖任何全局状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享数据段必须用可重入编码编写</p><h3 id="PV操作的实质"><a href="#PV操作的实质" class="headerlink" title="PV操作的实质"></a>PV操作的实质</h3><p>P即wait操作表示等待某种资源直到可用<br>V即signal(S)释放资源（S++），并唤醒等待该信号量的阻塞进程。</p><h3 id="PV-操作与系统调用的关系"><a href="#PV-操作与系统调用的关系" class="headerlink" title="PV 操作与系统调用的关系"></a>PV 操作与系统调用的关系</h3><ul><li>PV 操作是原语（Primitive）：<br>原语是操作系统内核中执行时不可被中断的原子操作，属于底层机制，其实现依赖硬件支持（如测试并设置指令）。</li><li>不直接等同于系统调用：<br>系统调用是用户态程序请求内核服务的接口（如fork()、open()），而 PV 操作是内核用于实现进程同步的内部机制。用户程序无法直接调用 PV 操作，而是通过操作系统提供的高层同步接口（如 POSIX 信号量sem_wait()&#x2F;sem_post()）间接使用。</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="物理地址与逻辑地址"><a href="#物理地址与逻辑地址" class="headerlink" title="物理地址与逻辑地址"></a>物理地址与逻辑地址</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a><strong>1. 基本概念</strong></h4><ul><li><p><strong>逻辑地址（Logical Address）</strong>  </p><ul><li>又称<strong>虚拟地址（Virtual Address）</strong>，是程序在编译、链接后生成的地址，从进程的视角看到的地址空间。  </li><li>特点：  <ul><li>每个进程拥有独立的逻辑地址空间（32位系统范围：<code>0 ~ 2³²-1</code>）。  </li><li>不同进程的逻辑地址可以相同，但实际映射到不同的物理内存位置。  </li><li>程序员只需关注逻辑地址，无需关心物理内存如何分配。</li></ul></li></ul></li><li><p><strong>物理地址（Physical Address）</strong>  </p><ul><li>是内存中实际存储单元的地址，CPU通过物理地址访问主存（RAM）。  </li><li>特点：  <ul><li>由操作系统和硬件（MMU）管理，对用户透明。  </li><li>逻辑地址必须转换为物理地址后才能访问真实数据。</li></ul></li></ul></li></ul><h4 id="2-实例说明"><a href="#2-实例说明" class="headerlink" title="2. 实例说明"></a><strong>2. 实例说明</strong></h4><ul><li><strong>场景</strong>：两个进程同时运行，均访问逻辑地址<code>0x4000</code>。  <ul><li>进程1的<code>0x4000</code> → 物理地址<code>0x8000</code>（存储数据A）。  </li><li>进程2的<code>0x4000</code> → 物理地址<code>0x12000</code>（存储数据B）。</li></ul></li><li><strong>结果</strong>：  <ul><li>进程间完全隔离，互不影响。  </li><li>物理内存的实际分配由操作系统管理。</li></ul></li></ul><hr><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>逻辑地址（虚拟地址）</strong></th><th><strong>物理地址</strong></th></tr></thead><tbody><tr><td><strong>生成阶段</strong></td><td>编译、链接时生成</td><td>运行时由MMU转换</td></tr><tr><td><strong>可见性</strong></td><td>进程可见</td><td>对进程透明</td></tr><tr><td><strong>唯一性</strong></td><td>进程内唯一，进程间可重复</td><td>全局唯一</td></tr><tr><td><strong>映射机制</strong></td><td>通过页表映射到物理内存</td><td>直接访问RAM</td></tr></tbody></table><p>逻辑地址是操作系统实现<strong>多进程、虚拟内存</strong>的核心机制，而物理地址是硬件执行的真实内存访问基础。两者通过MMU和页表协同工作，既保证了安全性，又提升了灵活性。</p><h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>内存保护是操作系统的核心功能之一，通过硬件支持（如基址寄存器和限长寄存器）和操作系统协作，可以实现进程内存空间的隔离和保护。重定位寄存器用于地址转换，界地址寄存器用于越界检查，两者结合既能实现动态地址映射，又能确保内存访问的安全性。特权指令的使用进一步保证了内存保护机制不会被用户程序破坏。</p><h4 id="内存保护的必要性"><a href="#内存保护的必要性" class="headerlink" title="内存保护的必要性"></a>内存保护的必要性</h4><ol><li><strong>保护操作系统</strong>：防止用户进程意外或恶意地修改操作系统的代码或数据。</li><li><strong>保护用户进程</strong>：防止一个用户进程访问或修改另一个用户进程的内存空间。</li><li><strong>系统稳定性</strong>：避免因非法内存访问导致的程序崩溃或系统错误。</li></ol><h4 id="内存保护的实现方法"><a href="#内存保护的实现方法" class="headerlink" title="内存保护的实现方法"></a>内存保护的实现方法</h4><p>题目中提到了两种常见的内存保护方法：</p><h5 id="方法1：上、下限寄存器"><a href="#方法1：上、下限寄存器" class="headerlink" title="方法1：上、下限寄存器"></a>方法1：上、下限寄存器</h5><ul><li><strong>原理</strong>：<ul><li>设置一对寄存器：<strong>下限寄存器</strong>和<strong>上限寄存器</strong>。</li><li>下限寄存器存放进程在主存中的起始物理地址（下限地址）。</li><li>上限寄存器存放进程在主存中的结束物理地址（上限地址）。</li></ul></li><li><strong>工作流程</strong>：<ul><li>CPU每次访问内存时，会检查访问的地址是否在下限和上限之间。</li><li>如果地址低于下限或高于上限，则触发越界异常，阻止访问。</li></ul></li><li><strong>优点</strong>：<ul><li>实现简单，硬件开销小。</li></ul></li><li><strong>缺点</strong>：<ul><li>需要为每个进程维护两个寄存器，且不支持动态地址变换（逻辑地址到物理地址的映射）。</li></ul></li></ul><h4 id="方法2：重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）"><a href="#方法2：重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）" class="headerlink" title="方法2：重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）"></a>方法2：重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）</h4><ul><li><strong>原理</strong>：<ul><li><strong>重定位寄存器（基址寄存器）</strong>：存放进程的起始物理地址。</li><li><strong>界地址寄存器（限长寄存器）</strong>：存放进程的最大逻辑地址（即进程的逻辑地址空间大小）。</li></ul></li><li><strong>工作流程</strong>：<ol><li>CPU生成一个逻辑地址。</li><li>硬件比较逻辑地址和界地址寄存器的值：<ul><li>如果逻辑地址 ≥ 界地址寄存器的值，说明越界，触发异常。</li><li>如果未越界，则将逻辑地址与重定位寄存器的值相加，得到物理地址。</li></ul></li><li>物理地址被送交内存单元进行访问。</li></ol></li><li><strong>优点</strong>：<ul><li>支持动态地址变换（逻辑地址到物理地址的映射）。</li><li>可以灵活地实现进程的内存隔离和保护。</li></ul></li><li><strong>缺点</strong>：<ul><li>需要额外的硬件支持（基址寄存器和限长寄存器）。</li></ul></li></ul><h4 id="特权指令与安全性"><a href="#特权指令与安全性" class="headerlink" title="特权指令与安全性"></a>特权指令与安全性</h4><ul><li>重定位寄存器和界地址寄存器的加载必须通过<strong>特权指令</strong>完成。<ul><li>特权指令只能由操作系统内核执行，用户程序无法直接修改这些寄存器。</li><li>这样可以防止用户程序恶意修改内存保护机制，确保系统的安全性。</li></ul></li><li>操作系统在切换进程时：<ol><li>保存当前进程的基址和限长寄存器值。</li><li>加载新进程的基址和限长寄存器值。</li><li>确保新进程只能访问自己的内存空间。</li></ol></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>假设：</p><ul><li>进程A的逻辑地址空间为0~1000。</li><li>进程A的物理内存起始地址为2000。</li><li>基址寄存器 &#x3D; 2000，限长寄存器 &#x3D; 1000。</li></ul><p>访问逻辑地址500：</p><ol><li>比较500 &lt; 1000，未越界。</li><li>物理地址 &#x3D; 500 + 2000 &#x3D; 2500。</li><li>访问物理地址2500。</li></ol><p>访问逻辑地址1500：</p><ol><li>比较1500 ≥ 1000，越界。</li><li>触发异常，阻止访问。</li></ol><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p> <strong>情况1：回收区与前面的空闲分区相邻（向前合并）</strong><br><strong>特点</strong>：回收区的起始地址 &#x3D; 前一个空闲分区的结束地址<br><strong>操作</strong>：将回收区合并到前一个空闲分区，<strong>只修改前一分区的大小</strong>（始址不变）。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链： [0K-100K], [150K-200K]</span><br><span class="line">进程释放内存块：[100K-150K]（回收区）</span><br></pre></td></tr></table></figure><ul><li>回收区（100K-150K）<strong>紧邻</strong>前面的空闲分区（0K-100K）。</li><li><strong>合并后</strong>：<br><code>[0K-150K], [150K-200K]</code>（前一个分区大小从100K→150K）</li></ul><hr><p> <strong>情况2：回收区与后面的空闲分区相邻（向后合并）</strong><br><strong>特点</strong>：回收区的结束地址 &#x3D; 后一个空闲分区的起始地址<br><strong>操作</strong>：将回收区合并到后一个空闲分区，<strong>修改后一分区的始址和大小</strong>。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链： [0K-100K], [200K-300K]</span><br><span class="line">进程释放内存块：[150K-200K]（回收区）</span><br></pre></td></tr></table></figure><ul><li>回收区（150K-200K）<strong>紧邻</strong>后面的空闲分区（200K-300K）。</li><li><strong>合并后</strong>：<br><code>[0K-100K], [150K-300K]</code>（后一个分区始址从200K→150K，大小从100K→150K）</li></ul><hr><p> <strong>情况3：回收区同时与前后两个空闲分区相邻（三块合并）</strong><br><strong>特点</strong>：回收区正好填补了前后两个空闲分区之间的空隙<br><strong>操作</strong>：将三个分区合并成一个，<strong>修改前一分区的大小，并删除后一分区</strong>。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链： [0K-100K], [200K-300K]</span><br><span class="line">进程释放内存块：[100K-200K]（回收区）</span><br></pre></td></tr></table></figure><ul><li>回收区（100K-200K）<strong>同时紧邻</strong>前面的（0K-100K）和后面的（200K-300K）空闲分区。</li><li><strong>合并后</strong>：<br><code>[0K-300K]</code>（前一个分区大小从100K→300K，后一个分区被删除）</li></ul><hr><p> <strong>情况4：回收区不与任何空闲分区相邻（独立插入）</strong><br><strong>特点</strong>：回收区既不与前一个分区相邻，也不与后一个分区相邻<br><strong>操作</strong>：在空闲分区链中<strong>新建一个表项</strong>，插入到合适位置（通常按地址排序）。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链： [0K-100K], [200K-300K]</span><br><span class="line">进程释放内存块：[150K-160K]（回收区）</span><br></pre></td></tr></table></figure><ul><li>回收区（150K-160K）<strong>不与任何空闲块相邻</strong>。</li><li><strong>插入后</strong>：<br><code>[0K-100K], [150K-160K], [200K-300K]</code>（新增一个表项）</li></ul><h3 id="搜索-分配算法"><a href="#搜索-分配算法" class="headerlink" title="搜索-分配算法"></a>搜索-分配算法</h3><p> <strong>1. 首次适应算法（First Fit）</strong><br><strong>规则</strong>：空闲分区按<strong>地址递增</strong>排列，分配时<strong>从头开始查找</strong>，选择<strong>第一个满足大小</strong>的空闲分区。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链（按地址排序）：</span><br><span class="line">[0K-50K], [60K-100K], [150K-300K]</span><br></pre></td></tr></table></figure><ul><li><strong>进程A请求40K</strong>：<ul><li>检查第一个分区 <code>[0K-50K]</code>（大小50K ≥ 40K）→ <strong>分配</strong>。</li><li>剩余 <code>[40K-50K]</code>（10K，假设不分割）。</li></ul></li><li><strong>进程B请求80K</strong>：<ul><li>跳过 <code>[40K-50K]</code>（太小）。</li><li>检查 <code>[60K-100K]</code>（40K ≥ 80K？不满足）。</li><li>检查 <code>[150K-300K]</code>（150K ≥ 80K）→ <strong>分配</strong>。</li></ul></li></ul><p><strong>优点</strong>：</p><ul><li>简单高效，<strong>查找速度快</strong>（只需找到第一个满足的）。</li><li><strong>高地址部分保留大块内存</strong>，适合后续大作业。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>低地址容易堆积小碎片</strong>（每次分配都从低地址开始）。</li><li>分配大作业时可能需要多次遍历。</li></ul><hr><p> <strong>2. 邻近适应算法（Next Fit &#x2F; 循环首次适应）</strong><br><strong>规则</strong>：空闲分区按<strong>地址递增</strong>排列，但<strong>从上一次分配结束的位置开始查找</strong>（类似循环队列）。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链：</span><br><span class="line">[0K-50K], [60K-100K], [150K-300K]</span><br></pre></td></tr></table></figure><ol><li>空闲分区按<strong>地址递增</strong>排列。</li><li>分配时<strong>从上一次分配结束的位置开始查找</strong>（类似循环队列）。</li><li>如果查找到链表末尾仍未找到合适分区，则<strong>回到链表头部继续查找</strong>。</li></ol><p><strong>初始空闲分区链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0K-50K], [60K-100K], [150K-300K]</span><br></pre></td></tr></table></figure><p><strong>假设初始指针指向链表的开头（<code>[0K-50K]</code>）</strong>。</p><hr><p> <strong>步骤1：进程A请求40K</strong></p><ul><li>从指针当前位置（<code>[0K-50K]</code>）开始查找：<ul><li><code>[0K-50K]</code> 大小 &#x3D; 50K ≥ 40K → <strong>满足</strong>。</li><li>分配 <code>[0K-40K]</code> 给进程A，剩余 <code>[40K-50K]</code>（10K，假设不分割）。</li><li><strong>指针移动到下一个分区 <code>[60K-100K]</code></strong>（因为分配是从 <code>[0K-50K]</code> 完成的，下一次从它的下一个开始）。</li></ul></li></ul><p><strong>更新后的空闲分区链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[40K-50K], [60K-100K], [150K-300K]</span><br></pre></td></tr></table></figure><p><strong>指针位置</strong>：指向 <code>[60K-100K]</code>。</p><hr><p> <strong>步骤2：进程B请求30K</strong></p><ul><li>从指针当前位置（<code>[60K-100K]</code>）开始查找：<ul><li><code>[60K-100K]</code> 大小 &#x3D; 40K ≥ 30K → <strong>满足</strong>。</li><li>分配 <code>[60K-90K]</code> 给进程B，剩余 <code>[90K-100K]</code>（10K）。</li><li><strong>指针移动到下一个分区 <code>[150K-300K]</code></strong>。</li></ul></li></ul><p><strong>更新后的空闲分区链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[40K-50K], [90K-100K], [150K-300K]</span><br></pre></td></tr></table></figure><p><strong>指针位置</strong>：指向 <code>[150K-300K]</code>。</p><hr><p> <strong>步骤3：进程C请求20K</strong></p><ul><li>从指针当前位置（<code>[150K-300K]</code>）开始查找：<ul><li><code>[150K-300K]</code> 大小 &#x3D; 150K ≥ 20K → <strong>满足</strong>。</li><li>分配 <code>[150K-170K]</code> 给进程C，剩余 <code>[170K-300K]</code>（130K）。</li><li><strong>指针移动到下一个分区</strong>，但已经是链表末尾，所以<strong>回到头部 <code>[40K-50K]</code></strong>。</li></ul></li></ul><p><strong>更新后的空闲分区链</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[40K-50K], [90K-100K], [170K-300K]</span><br></pre></td></tr></table></figure><p><strong>指针位置</strong>：指向 <code>[40K-50K]</code>。</p><hr><p> <strong>3. 最佳适应算法（Best Fit）</strong><br><strong>规则</strong>：空闲分区按<strong>大小递增</strong>排列，分配时<strong>选择最小的能满足需求的分区</strong>（避免浪费大块内存）。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链（按大小排序）：</span><br><span class="line">[10K-20K], [60K-100K], [150K-300K]</span><br></pre></td></tr></table></figure><ul><li><strong>进程A请求15K</strong>：<ul><li>检查 <code>[10K-20K]</code>（10K &lt; 15K？不满足）。</li><li>检查 <code>[60K-100K]</code>（40K ≥ 15K）→ <strong>分配</strong>。</li><li>剩余 <code>[75K-100K]</code>（25K）。</li></ul></li><li><strong>进程B请求10K</strong>：<ul><li>检查 <code>[10K-20K]</code>（10K ≥ 10K）→ <strong>分配</strong>。</li></ul></li></ul><p><strong>优点</strong>：</p><ul><li><strong>减少大分区的浪费</strong>（尽量保留大块内存）。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>产生大量小碎片</strong>（每次分配后可能留下极小剩余块）。</li><li><strong>查找速度慢</strong>（需要遍历所有小分区）。</li></ul><hr><p> <strong>4. 最坏适应算法（Worst Fit）</strong><br><strong>规则</strong>：空闲分区按<strong>大小递减</strong>排列，分配时<strong>选择最大的分区</strong>（尽量少留碎片）。</p><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空闲分区链（按大小排序）：</span><br><span class="line">[150K-300K], [60K-100K], [10K-20K]</span><br></pre></td></tr></table></figure><ul><li><strong>进程A请求50K</strong>：<ul><li>检查 <code>[150K-300K]</code>（150K ≥ 50K）→ <strong>分配</strong>。</li><li>剩余 <code>[200K-300K]</code>（100K）。</li></ul></li><li><strong>进程B请求20K</strong>：<ul><li>检查 <code>[200K-300K]</code>（100K ≥ 20K）→ <strong>分配</strong>。</li><li>剩余 <code>[220K-300K]</code>（80K）。</li></ul></li></ul><p><strong>优点</strong>：</p><ul><li><strong>减少小碎片</strong>（尽量使用大块，剩余部分仍然较大）。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>快速消耗大分区</strong>（可能导致大作业无法分配）。</li><li><strong>性能较差</strong>（实验证明不如首次适应）。</li></ul><hr><p> <strong>四种算法对比总结</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>排序方式</strong></th><th><strong>分配策略</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>首次适应</strong></td><td>地址递增</td><td>第一个满足的分区</td><td>简单高效，保留大块内存</td><td>低地址碎片多</td></tr><tr><td><strong>邻近适应</strong></td><td>地址递增</td><td>从上次结束位置继续查找</td><td>分配更均匀</td><td>可能破坏大分区，性能较差</td></tr><tr><td><strong>最佳适应</strong></td><td>大小递增</td><td>最小的能满足的分区</td><td>减少大分区浪费</td><td>产生大量小碎片，查找慢</td></tr><tr><td><strong>最坏适应</strong></td><td>大小递减</td><td>最大的能满足的分区</td><td>减少小碎片</td><td>快速消耗大分区，性能较差</td></tr></tbody></table><h3 id="索引-分配算法"><a href="#索引-分配算法" class="headerlink" title="索引-分配算法"></a>索引-分配算法</h3><p> <strong>基于索引搜索的动态分区分配算法详解</strong></p><p>在大型系统中，空闲分区链可能非常长，使用顺序搜索（如首次适应、最佳适应等）效率较低。因此，引入了 <strong>基于索引搜索的分配算法</strong>，通过 <strong>分类管理空闲分区</strong> 提高分配速度。主要包括以下三种算法：</p><hr><p> <strong>1. 快速适应算法（Quick Fit）</strong><br> <strong>核心思想</strong></p><ul><li>按 <strong>进程常用内存大小</strong> 预先划分多个空闲分区链（如4KB、8KB、16KB等）。</li><li>使用 <strong>索引表</strong> 记录每个大小类别的空闲链头指针。</li></ul><p> <strong>分配过程</strong></p><ol><li>根据进程请求的内存大小，在索引表中找到 <strong>能容纳它的最小分区链</strong>。</li><li>从该链表中取出 <strong>第一个空闲块</strong> 分配给进程。</li></ol><p> <strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">索引表：</span><br><span class="line">| 大小  | 空闲链头指针 |</span><br><span class="line">|-------|-------------|</span><br><span class="line">| 4KB   | → [4KB块1] → [4KB块2] |</span><br><span class="line">| 8KB   | → [8KB块1] → [8KB块2] |</span><br><span class="line">| 16KB  | → [16KB块1]           |</span><br></pre></td></tr></table></figure><ul><li><strong>进程请求5KB</strong>：<ul><li>查找索引表，选择 <strong>8KB链</strong>（最小能满足的）。</li><li>分配 <code>[8KB块1]</code>，剩余3KB（若系统允许分割）。</li></ul></li></ul><p> <strong>特点</strong></p><ul><li><strong>优点</strong>：<ul><li>查找速度极快（直接通过索引定位）。</li><li><strong>无外部碎片</strong>（分区按固定大小分类）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>回收合并复杂</strong>：需合并相邻分区，可能需重组索引表。</li><li><strong>内部碎片</strong>：若进程请求大小略小于分区大小（如7KB用8KB块）。</li></ul></li></ul><hr><p> <strong>2. 伙伴系统（Buddy System）</strong><br> <strong>核心思想</strong></p><ul><li>所有分区大小必须是 <strong>2的幂次方</strong>（如1KB、2KB、4KB等）。</li><li>通过 <strong>分裂与合并</strong> 管理空闲块，始终保持分区对齐。</li></ul><p> <strong>分配过程</strong></p><ol><li>计算满足请求的最小2^k分区（如请求5KB → 选择8KB）。</li><li>若8KB链为空，则查找更大的链（如16KB）：<ul><li>将16KB块 <strong>分裂为两个8KB伙伴块</strong>，一个分配，另一个加入8KB链。</li></ul></li><li>若16KB链仍为空，继续向上查找（如32KB）。</li></ol><p> <strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空闲链：</span><br><span class="line">| 大小 | 空闲块          |</span><br><span class="line">|------|----------------|</span><br><span class="line">| 8KB  | → [8KB块1]      |</span><br><span class="line">| 16KB | → [16KB块1]     |</span><br></pre></td></tr></table></figure><ul><li><strong>进程请求5KB</strong>：<ul><li>选择8KB链，分配 <code>[8KB块1]</code>。</li></ul></li><li><strong>若8KB链为空</strong>：<ul><li>从16KB链取出 <code>[16KB块1]</code>，分裂为两个8KB伙伴块：<ul><li>分配其中一个8KB，另一个加入8KB链。</li></ul></li></ul></li></ul><p> <strong>回收过程</strong></p><ul><li>检查回收块的 <strong>伙伴块</strong>（相邻且大小相同）是否空闲。<ul><li>若空闲，则合并为更大的块（如两个8KB合并为16KB），并递归检查能否继续合并。</li></ul></li></ul><p> <strong>特点</strong></p><ul><li><strong>优点</strong>：<ul><li>合并高效（仅需检查伙伴块）。</li><li>减少外部碎片（分区对齐）。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>内部碎片</strong>：请求非2^k大小时需向上取整（如5KB→8KB）。</li><li>分裂与合并增加开销。</li></ul></li></ul><hr><p> <strong>3. 哈希算法（Hash Fit）</strong><br> <strong>核心思想</strong></p><ul><li>使用 <strong>哈希表</strong> 管理空闲分区链，以分区大小为关键字。</li><li>通过哈希函数快速定位合适的分区链。</li></ul><p> <strong>分配过程</strong></p><ol><li>根据请求大小计算哈希值（如<code>hash(5KB)=链2</code>）。</li><li>在对应哈希桶的空闲链中查找满足大小的分区。</li></ol><p> <strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">哈希表：</span><br><span class="line">| 哈希桶 | 分区链                     |</span><br><span class="line">|--------|---------------------------|</span><br><span class="line">| 链1    | → [4KB块1] → [4KB块2]     |</span><br><span class="line">| 链2    | → [8KB块1] → [8KB块2]     |</span><br><span class="line">| 链3    | → [16KB块1]               |</span><br></pre></td></tr></table></figure><ul><li><strong>进程请求5KB</strong>：<ul><li><code>hash(5KB)</code> 指向链2（8KB），分配 <code>[8KB块1]</code>。</li></ul></li></ul><p> <strong>特点</strong></p><ul><li><strong>优点</strong>：<ul><li>查找速度快（接近O(1)）。</li><li>灵活支持非固定大小分区。</li></ul></li><li><strong>缺点</strong>：<ul><li>哈希冲突可能降低效率。</li><li>合并碎片较复杂（需额外策略）。</li></ul></li></ul><hr><p> <strong>对比总结</strong></p><table><thead><tr><th><strong>算法</strong></th><th><strong>适用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>快速适应</strong></td><td>固定大小请求频繁</td><td>无外部碎片，分配极快</td><td>回收合并复杂，内部碎片</td></tr><tr><td><strong>伙伴系统</strong></td><td>需要高效合并的场景</td><td>外部碎片少，合并简单</td><td>内部碎片多，仅支持2^k大小</td></tr><tr><td><strong>哈希算法</strong></td><td>大小分布不均匀的系统</td><td>灵活，查找快</td><td>哈希冲突可能影响性能</td></tr></tbody></table><hr><p> <strong>连续分配 vs 非连续分配</strong></p><ul><li><p><strong>连续分配</strong>（如上述算法）：</p><ul><li>要求作业占用 <strong>连续物理内存</strong>。</li><li>问题：即使总空闲足够，也可能因无连续空间导致分配失败。<blockquote><p>例如：内存有1GB碎片，但无连续的1GB块，大作业无法运行。</p></blockquote></li></ul></li><li><p><strong>非连续分配</strong>（分页&#x2F;分段）：</p><ul><li>允许作业分散存储在物理内存中。</li><li>优点：解决连续分配的空间浪费问题。</li><li>缺点：需要额外空间存储映射表（如页表），<strong>存储密度较低</strong>。</li></ul></li></ul><hr><p> <strong>关键点</strong></p><ol><li><strong>索引搜索算法</strong> 的核心是通过 <strong>分类或哈希</strong> 加速查找，适合大型系统。</li><li><strong>伙伴系统</strong> 是折中方案，兼顾分配速度和碎片管理，但限制分区大小。</li><li>非连续分配（如分页）是解决外部碎片的终极方案，但需硬件支持。</li></ol><h3 id="分页内存管理"><a href="#分页内存管理" class="headerlink" title="分页内存管理"></a>分页内存管理</h3><p>页面（Page）：进程的逻辑地址空间被划分为固定大小的块，称为页面，编号从0开始（页号）。<br>页框（Page Frame）：物理内存被划分为与页面大小相同的块，称为页框（或物理块），编号从0开始（页框号）。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2025/05/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2025/05/25/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="齐次线性方程组的解"><a href="#齐次线性方程组的解" class="headerlink" title="齐次线性方程组的解"></a>齐次线性方程组的解</h4><p><img src="/img/2025_5_25/001.png" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（408考研）</title>
      <link href="/2025/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88408%E8%80%83%E7%A0%94%EF%BC%89/"/>
      <url>/2025/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88408%E8%80%83%E7%A0%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="数据链路层的流量控制与可靠传输机制"><a href="#数据链路层的流量控制与可靠传输机制" class="headerlink" title="数据链路层的流量控制与可靠传输机制"></a>数据链路层的流量控制与可靠传输机制</h4><h5 id="GNB"><a href="#GNB" class="headerlink" title="GNB"></a>GNB</h5><p>首先探究为什么GBN的最大窗口为：2^n - 1</p><p>此时我们的数据编号为00，01，10，11，一共四个编号（0，1，2，3），如果我们我们设置发送窗口的值为 2^n（即4），那么当我们设置发送方的发送序号为0~3的四个数据包的时候，此时会发生两种情况：</p><ul><li>第一种情况：接受方正确接收了所有数据，然后返回接收到的最大序号，即3。（GBN返回此时接收到的序号的最大值）</li><li>第二种情况：接收方发送的确认没有正确回传，所以发送方需要重传4个数据包。</li></ul><p>无论是发生了第一种情况还是第二种情况，我们的接受方再一次收到4个数据的时候，都无法判断这是新的4个数据，还是重发的四个数据，此时就会产生错误。</p><p>那么如果我们设置发送窗口的大小为 2^n - 1的话（即3）：</p><p>此时我们只会发送0~2的3个数据包，并且等待确认，此时接受方有两种情况：</p><ul><li>第一种情况：接受方正确接收了数据，并且对最大序号2进行返回。</li><li>第二种情况：接受方发送的确认没有正确回传，此时发送方需要重传3个数据包。</li></ul><p>当第一种情况发生的时候，回传的确认正确的被发送方接收，那么下次发送的数据的序号会是3，0，1。如果发生了第二种情况，此时发送方回传的数据会是0，1，2这三个序号，那么此时就不会发生混淆。</p><h5 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h5><p><img src="/img/2025_5_20/005.png" alt="404"><br><img src="/img/2025_5_20/006.png" alt="404"></p><h4 id="为什么TDM（时分复用）对带宽有要求"><a href="#为什么TDM（时分复用）对带宽有要求" class="headerlink" title="为什么TDM（时分复用）对带宽有要求"></a>为什么TDM（时分复用）对带宽有要求</h4><ul><li>TDM的基本原理</li></ul><p>TDM（时分复用）通过 将时间划分为固定长度的时隙，让多个信号轮流占用信道：</p><ol><li>发送端：不同用户的信号被分配到不同的时间片（如用户1用第1个时隙，用户2用第2个时隙……）。</li><li>接收端：根据时间片提取对应信号，完成多路信号的分离。</li></ol><ul><li>带宽要求的核心原因</li></ul><p>TDM对带宽的要求源于信号调制后的复合信号特性：复合信号的带宽：将多个信号按时间片交织后，复合信号的频谱会扩展，其带宽可能远大于单个信号带宽。<br>原因：时域上的快速切换（时隙轮换）会导致频域的高频成分增加（傅里叶变换性质）。</p><ul><li>举例：</li></ul><p>若将 4 路 4 kHz 的语音信号通过 TDM 合并：时隙切换速度需足够快（如每秒 8000 次，每时隙 125 μs），复合信号的带宽可能扩展到 数十kHz。若信道带宽不足，高频成分会被滤除，导致信号失真。</p><h4 id="令牌环网络的工作流程"><a href="#令牌环网络的工作流程" class="headerlink" title="令牌环网络的工作流程"></a>令牌环网络的工作流程</h4><p>A → B → C → D →（令牌循环）<br>站点要发送数据时</p><ul><li>举例：站点B有数据要发给站点D。</li></ul><ol><li>等待令牌：B必须等到令牌传到自己手里（比如当前令牌在A→B的路径上）。</li><li>拿到令牌后：<br>B把令牌改成数据帧（贴上数据，写上目的地址D）。<br>发送数据帧到环上（B→C→D→A→B）。</li><li>数据帧的旅程<br>途经C：C检查数据帧，发现不是发给自己的，直接转发给D。<br>到达D：D发现是发给自己的，复制数据，但继续转发帧（因为帧要回到发送者B）。<br>回到B：B收到自己发的数据帧后，不再转发，而是：<br>检查数据是否成功传输（通过帧状态位）。<br>回收数据帧，重新生成一个干净的令牌。<br>把新令牌传给下一个站点（B→C）。</li></ol><h4 id="为什么全双工模式下不需要碰撞检测？"><a href="#为什么全双工模式下不需要碰撞检测？" class="headerlink" title="为什么全双工模式下不需要碰撞检测？"></a>为什么全双工模式下不需要碰撞检测？</h4><ul><li>半双工（Half-Duplex）：</li></ul><ol><li>同一时间只能单向通信（如对讲机）。</li><li>发送和接收共享同一信道，因此可能发生冲突（两个设备同时发数据）。</li><li>需要碰撞检测（如CSMA&#x2F;CD）：设备边发边听，发现冲突后重传。</li></ol><ul><li>全双工（Full-Duplex）：</li></ul><ol><li>双向同时通信（如电话）。</li><li>发送和接收使用独立的物理通道（如双绞线的两对线），互不干扰。</li><li>无需碰撞检测：因为发送和接收完全隔离，不可能冲突。</li></ol><h4 id="为什么网卡同时涉及数据链路层和物理层？"><a href="#为什么网卡同时涉及数据链路层和物理层？" class="headerlink" title="为什么网卡同时涉及数据链路层和物理层？"></a>为什么网卡同时涉及数据链路层和物理层？</h4><ol><li>物理层（Layer 1）的职责</li></ol><p>信号转换：<br>将计算机内部的数字信号（0&#x2F;1）转换为适合传输的 电信号（以太网）、光信号（光纤） 或 电磁波（Wi-Fi）。</p><ol start="2"><li>数据链路层（Layer 2）的职责</li></ol><p>帧的封装与解封装：<br>将网络层（如IP数据包）加上 帧头（源&#x2F;目的MAC地址）和 帧尾（FCS校验）。</p><h4 id="CSMA-CD协议中最短帧长的界定"><a href="#CSMA-CD协议中最短帧长的界定" class="headerlink" title="CSMA&#x2F;CD协议中最短帧长的界定"></a>CSMA&#x2F;CD协议中最短帧长的界定</h4><p>在以太网（CSMA&#x2F;CD）中：</p><ol><li>发送数据时，设备会持续监听信道（边发边听）。</li><li>如果发送的数据和监听到的信号不一致，说明发生了冲突。</li><li>一旦检测到冲突发送方会立即停止发送，并执行退避算法等待重传。</li></ol><p>如果帧太短的话：</p><ol><li>在冲突信号返回 A 之前，A 已经发完了整个帧。</li><li>A 停止监听信道（因为帧已经发完），无法检测到冲突。</li><li>结果：A 以为发送成功，但实际上数据已经因冲突被破坏。</li></ol><p>需要界定最短帧长，那么临界点就是传数据的时间占用整个争用期（2τ）</p><p>为什么“2τ × 速率”是最短帧长？</p><ol><li>2τ 是冲突信号返回的最长时间。</li><li>速率 决定单位时间能发送多少比特。</li><li>乘积 就是“在冲突信号返回前，最少要发送多少比特”。</li><li>这里的（τ）为总线传播时延，就是在链路上传输消耗的时间。</li><li>总而言之：</li></ol><h4 id="以太网：物理上星型结构、逻辑上是总线型结构"><a href="#以太网：物理上星型结构、逻辑上是总线型结构" class="headerlink" title="以太网：物理上星型结构、逻辑上是总线型结构"></a>以太网：物理上星型结构、逻辑上是总线型结构</h4><p><img src="/img/2025_5_20/001.png" alt="404"></p><p>由于电信号在网线中传输时会衰减，集线器的作用是 接收信号并重新放大，再广播给所有端口。</p><h4 id="IEEE-802-11-无线局域网"><a href="#IEEE-802-11-无线局域网" class="headerlink" title="IEEE 802.11 无线局域网"></a>IEEE 802.11 无线局域网</h4><h5 id="有固定设施的"><a href="#有固定设施的" class="headerlink" title="有固定设施的"></a>有固定设施的</h5><p><img src="/img/2025_5_20/002.png" alt="404"></p><p>为什么AP会改变？</p><ol><li>无线信号覆盖限制：单个AP的覆盖范围有限，移动设备（A）远离原AP（AP1）时，信号变弱，需切换到新AP（AP2）。</li><li>无缝漫游：在ESS中，所有AP共享同一个网络标识（SSID），设备可自动切换AP，而用户无感知。</li><li>AP改变但通信不中断：</li><li>高层协议（如TCP&#x2F;IP）不受影响，因为分配系统（DS）确保了数据转发。</li><li>只有物理层和链路层的连接点（AP）发生变化。</li></ol><h5 id="无固定设施的自组织网络"><a href="#无固定设施的自组织网络" class="headerlink" title="无固定设施的自组织网络"></a>无固定设施的自组织网络</h5><p>军事战场通信</p><ul><li><p>场景：<br>士兵携带的无线设备（如战术电台、无人机）在野外快速部署，没有固定基站。</p></li><li><p>自组网如何工作：</p></li></ul><p>设备自动发现附近的战友设备，形成临时网络。</p><p>每台设备既是通信终端，也是路由器，负责转发其他设备的数据。</p><p>如果某个士兵移动（如前进或撤退），网络拓扑动态调整，自动选择新路径。</p><ul><li>与移动IP的区别：</li></ul><p>移动IP需要依赖固定基站和互联网基础设施，而自组网完全独立运行。</p><ul><li><p>注意区分与移动IP的区别<br><img src="/img/2025_5_20/003.png" alt="404"></p></li><li><p>手机热点是自组织网络吗？<br><img src="/img/2025_5_20/004.png" alt="404"></p></li></ul><h4 id="PPP-P"><a href="#PPP-P" class="headerlink" title="PPP-P"></a>PPP-P</h4><ol><li>LCP 负责建立、维护和终止物理连接，并协商链路层参数。</li></ol><p>调制解调器拨号后，LCP先和ISP的服务器“握手”。<br>双方协商：“我们用CHAP认证，不压缩数据，链路超时时间设为30秒”。<br>若协商成功，链路建立；若失败（如密码错误），断开连接。</p><ol start="2"><li>NCP 在LCP建立链路后，配置网络层参数（如IP地址）。</li></ol><p>LCP完成链路建立后：<br>NCP（具体为IPCP）向ISP请求：“请给我一个IP地址”。<br>ISP回复：“你的IP是192.168.1.100，DNS是8.8.8.8”。<br>你的电脑获得IP，开始上网。</p><ol start="3"><li>组帧的方法</li></ol><h4 id="不同链路层协议的转发机制的差异"><a href="#不同链路层协议的转发机制的差异" class="headerlink" title="不同链路层协议的转发机制的差异"></a>不同链路层协议的转发机制的差异</h4><ul><li>以太网（IEEE 802.3）</li></ul><p>使用CSMA&#x2F;CD（半双工）或全双工模式，依赖交换机转发。</p><ul><li>PPP协议（点对点链路）</li></ul><p>简化帧格式（无MAC地址），直接转发到唯一对端。</p><ul><li>无线网络（IEEE 802.11）</li></ul><p>通过AP（接入点）转发，MAC地址包含发送端、接收端和BSSID。</p><h4 id="广播域（Broadcast-Domain）与冲突域（Collision-Domain）"><a href="#广播域（Broadcast-Domain）与冲突域（Collision-Domain）" class="headerlink" title="广播域（Broadcast Domain）与冲突域（Collision Domain）"></a>广播域（Broadcast Domain）与冲突域（Collision Domain）</h4><ol><li>广播域（Broadcast Domain）</li></ol><p>定义：<br>广播域是指网络中能接收到同一广播消息的所有设备的集合。当一台设备发送广播包（如目的IP为255.255.255.255或MAC为FF:FF:FF:FF:FF:FF）时，该包会被广播域内的所有设备接收和处理。</p><p>关键设备的影响：</p><p>路由器：分隔广播域（默认不转发广播包），每个路由器接口属于不同的广播域。</p><p>交换机：不能分隔广播域（会泛洪广播包），所有连接的设备属于同一广播域。</p><p>集线器&#x2F;中继器：不能分隔广播域（物理层设备，直接转发所有信号）。</p><p>示例：<br>若两个局域网通过路由器连接，则它们是两个独立的广播域；若仅通过交换机连接，则属于同一个广播域。</p><ol start="2"><li>冲突域（Collision Domain）</li></ol><p>定义：<br>冲突域是指网络中共享同一信道、可能发生数据冲突（Collision）的设备范围。当多台设备同时发送数据时，冲突域内的设备需要竞争信道（如CSMA&#x2F;CD机制）。</p><p>关键设备的影响：</p><p>交换机：分隔冲突域（每个交换机端口是一个独立的冲突域），因为交换机支持全双工通信。</p><p>路由器：分隔冲突域（每个接口独立）。</p><p>集线器&#x2F;中继器：不能分隔冲突域（所有连接的设备共享同一信道）。</p><p>示例：<br>若10台设备连接到一个集线器，它们属于同一个冲突域；若连接到一个交换机，则每台设备独占一个冲突域。</p><h4 id="如何理解“数据链路层中，流量控制与可靠传输机制是交织在一起的”？"><a href="#如何理解“数据链路层中，流量控制与可靠传输机制是交织在一起的”？" class="headerlink" title="如何理解“数据链路层中，流量控制与可靠传输机制是交织在一起的”？"></a>如何理解“数据链路层中，流量控制与可靠传输机制是交织在一起的”？</h4><p>在计算机网络的数据链路层（Data Link Layer），<strong>流量控制（Flow Control）</strong> 和 <strong>可靠传输（Reliable Delivery）</strong> 是两个核心功能，它们通常紧密结合，共同确保数据高效、无差错地传输。以下是具体解释：</p><hr><p> <strong>1. 流量控制（Flow Control）</strong><br><strong>目的</strong>：防止发送方发送数据过快，导致接收方来不及处理而丢包。<br><strong>实现方式</strong>：  </p><ul><li><strong>固定窗口协议（Sliding Window）</strong>：使用固定窗口大小（由协议参数预先设定） </li><li><strong>停等协议（Stop-and-Wait）</strong>：每发一帧，必须等确认（ACK）后再发下一帧（效率低，但简单）。</li></ul><p><strong>关键点</strong>：流量控制主要解决 <strong>“接收方处理能力”</strong> 问题，避免缓冲区溢出。</p><hr><p> <strong>2. 可靠传输（Reliable Delivery）</strong><br><strong>目的</strong>：确保数据帧正确、按序到达接收方，避免丢失或错误。<br><strong>实现方式</strong>：  </p><ul><li><strong>确认应答（ACK）</strong>：接收方收到数据后返回确认信号。  </li><li><strong>超时重传（Retransmission）</strong>：如果发送方未收到 ACK，会重发数据帧。  </li><li><strong>序号机制（Sequence Numbers）</strong>：确保数据按顺序接收，避免重复或乱序。</li></ul><p><strong>关键点</strong>：可靠传输主要解决 <strong>“数据丢失或错误”</strong> 问题。</p><hr><p> <strong>3. 为什么说它们“交织在一起”？</strong><br>在数据链路层，<strong>流量控制和可靠传输通常由同一机制（如固定窗口协议）同时实现</strong>，原因如下：  </p><p> <strong>例如：ARQ（自动重传请求）机制</strong></p><ul><li><strong>回退 N 帧（Go-Back-N, GBN）</strong> 和 <strong>选择重传（Selective Repeat, SR）</strong> 协议同时涉及：  <ul><li><strong>流量控制</strong>：设置窗口大小。  </li><li><strong>可靠传输</strong>：通过 ACK&#x2F;NAK 和重传保证数据正确性。</li></ul></li></ul><hr><p> <strong>4. 总结</strong></p><table><thead><tr><th><strong>功能</strong></th><th><strong>流量控制（Flow Control）</strong></th><th><strong>可靠传输（Reliable Delivery）</strong></th></tr></thead><tbody><tr><td><strong>核心目标</strong></td><td>防止接收方过载</td><td>防止数据丢失或错误</td></tr><tr><td><strong>实现方式</strong></td><td>固定窗口、停等协议</td><td>ACK、超时重传、序号机制</td></tr><tr><td><strong>交织点</strong></td><td>固定窗口同时控制速率和可靠性</td><td>ARQ 机制（如 GBN、SR）</td></tr></tbody></table><p><strong>结论</strong>：<br>在数据链路层，<strong>流量控制和可靠传输通常由同一套协议（如固定窗口、ARQ）实现</strong>，因此它们是紧密交织的。这种设计既保证了数据传输的可靠性，又避免了接收方被淹没，提高了整体效率。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h4><ul><li>它把内部网络（例如家或公司的局域网）的私有IP地址，转换成对外的公共IP地址，让内部设备能访问互联网。</li><li>例如：</li></ul><ol><li>有3台设备（手机、电脑、平板），都通过路由器连接互联网。</li><li>内部IP（路由器分配的私有地址）：<br>手机：192.168.1.2<br>电脑：192.168.1.3<br>平板：192.168.1.4</li><li>外部IP（运营商提供的公共地址）：123.45.67.89</li><li>当你的手机访问某个网站（例如陈同学的桃花源）时，数据包先发给路由器，路由器会把手机的私有IP（192.168.1.2）替换成公共IP（123.45.67.89），并记录这个连接。网站收到请求后，只会看到公共IP（123.45.67.89），不知道内部具体是哪台设备发的请求。网站返回数据时，路由器根据之前的记录，再把数据转发给手机。</li></ol><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>A_HOME和B_HOME的路由器都用同样的私有IP段（比如192.168.1.1）。</p><p>A的电脑IP是192.168.1.2，B的电视也是192.168.1.2。</p><p>私有IP只在本地有效：</p><p>A的192.168.1.2只在A的局域网内有效，B的192.168.1.2也只在B有效。</p><p>当A电脑访问陈同学的网站时，路由器会把私有IP（192.168.1.2）转换成公共IP（比如123.45.67.89）。</p><h4 id="通过路由器连接IPv4和IPv6网络"><a href="#通过路由器连接IPv4和IPv6网络" class="headerlink" title="通过路由器连接IPv4和IPv6网络"></a>通过路由器连接IPv4和IPv6网络</h4><ul><li>隧道技术（Tunneling）</li></ul><p>两个IPv6网络通过IPv4互联网连接：</p><ol><li><p>由器A将IPv6数据包封装为IPv4数据包，目标为路由器B的IPv4地址。</p></li><li><p>路由器B解封装后，将原始IPv6数据包转发到本地IPv6网络。</p></li></ol><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP的工作流程（4个步骤）</p><p>假设一台新电脑（DHCP客户端）连接到公司网络，需要获取IP地址：</p><p>（1）DHCP发现（DHCP Discover）电脑（刚开机，IP&#x3D;0.0.0.0）广播一条消息：“谁是DHCP服务器？我需要一个IP地址！”源IP:0.0.0.0（因为还没有IP）目标IP:255.255.255.255（全网广播）目标MAC:FF:FF:FF:FF:FF:FF（局域网广播）<br>为什么用广播？→电脑不知道DHCP服务器在哪，只能大喊一声问所有人。</p><p>（2）DHCP提供（DHCP Offer）DHCP服务器（比如公司内网的服务器）听到广播后回应：“我这有一个IP：192.168.1.100，你要吗？”源IP:DHCP服务器的IP（如192.168.1.1）目标IP:255.255.255.255（仍然广播，因为电脑还没IP）提供的配置:IP地址、子网掩码、网关、DNS、租期（如24小时）<br>注意：如果网络中有多个DHCP服务器，电脑会收到多个Offer，通常选择第一个。</p><p>（3）DHCP请求（DHCP Request）电脑选择其中一个Offer（比如192.168.1.100），并广播确认：“我要用192.168.1.100，请确认！”源IP:0.0.0.0（仍未正式分配）目标IP:255.255.255.255（继续广播）<br>为什么还要广播？→告诉其他DHCP服务器“我已选好，你们不用再给我IP了”。</p><p>（4）DHCP确认（DHCP Ack）DHCP服务器最终确认分配：“OK，192.168.1.100归你了，租期24小时！”源IP:DHCP服务器IP目标IP:255.255.255.255正式分配：IP、子网掩码、网关、DNS等信息。<br>此时，电脑正式获得IP，可以上网了！</p><h4 id="IPv6的QoS"><a href="#IPv6的QoS" class="headerlink" title="IPv6的QoS"></a>IPv6的QoS</h4><ul><li>是什么：</li></ul><p>在有限的带宽下，提供端到端的可靠保证</p><ul><li>IPv6 通过以下方式原生支持 QoS：</li></ul><ol><li><p>流量类别（Traffic Class, 8位）<br>标记数据包的优先级（如视频通话 &gt; 网页浏览）。</p></li><li><p>流标签（Flow Label, 20位）<br>标识同一数据流（如一场视频会议的所有包），确保路由器统一处理。</p></li></ol><ul><li>某公司使用 IPv6 网络进行跨国视频会议，需保证低延迟、不卡顿。</li></ul><p>步骤：</p><ol><li>标记优先级</li></ol><p>视频会议终端将数据包的 Traffic Class 设为 0xB8（对应实时交互类流量）。<br>Flow Label 设为唯一值（如 0xABC12），标识此会议流。</p><ol start="2"><li>路由器处理</li></ol><p>路由器检测到 Traffic Class &#x3D; 0xB8，优先转发该数据包。<br>相同 Flow Label 的包走同一路径，避免乱序。</p><ol start="3"><li>带宽保障</li></ol><p>若网络拥塞，普通下载流量（Traffic Class &#x3D; 0x00）会被延迟，视频会议包仍优先传输。</p><ol start="4"><li>效果：</li></ol><p>即使网络带宽紧张，视频会议仍保持流畅，而文件下载速度暂时下降。</p><h4 id="RIP-中的水平分割与毒性逆转"><a href="#RIP-中的水平分割与毒性逆转" class="headerlink" title="RIP 中的水平分割与毒性逆转"></a>RIP 中的水平分割与毒性逆转</h4><p><img src="/img/2025_5_25/002.png" alt="404"></p><ul><li>水平分割的作用</li></ul><ol><li><p>规则：如果路由器从某个接口学到一条路由，则不会通过同一接口再通告该路由。</p></li><li><p>本例：</p></li></ol><p>RouterB 从 RouterA 的接口学到 10.0.0.0&#x2F;8，因此不会通过同一接口将这条路由发回给 RouterA。</p><p>即使 RouterA 的直连路由失效，RouterB 也不会向 RouterA 发送错误信息，从而避免环路。</p><ul><li>使用毒性逆转（Poison Reverse）的效果</li></ul><p>毒性逆转是水平分割的增强版，其核心思想是：<br>“如果路由器从某个接口学到一条路由，它仍然会通过同一接口通告该路由，但会将其标记为不可达（跳数&#x3D;∞）。”</p><p><img src="/img/2025_5_25/003.png" alt="404"></p><p>注意：</p><ol><li>当 RouterA 的直连路由 10.0.0.0&#x2F;8 失效时：RouterA 会立即删除直连路由。</li><li>水平逆转超时速度慢：RouterB 会继续保留“10.0.0.0&#x2F;8 可通过 RouterA 到达（跳数&#x3D;1）”的路由，直到路由超时计时器（Route Age Timer）到期（如RIP默认是180秒）。</li></ol><h4 id="移动-IP-通信过程示例"><a href="#移动-IP-通信过程示例" class="headerlink" title="移动 IP 通信过程示例"></a>移动 IP 通信过程示例</h4><ul><li>场景描述</li></ul><p>假设你是一台笔记本电脑（移动节点），IP 地址是 192.168.1.100（归属地址），原始网络是“家庭 Wi-Fi”（归属网络）。<br>当你带着笔记本从家移动到公司时，公司网络是被访网络，你需要保持 192.168.1.100 不变以维持正在进行的视频会议。</p><ul><li>步骤详解</li></ul><ol><li>在家（归属网络）</li></ol><p>你的笔记本通过家庭 Wi-Fi（192.168.1.0&#x2F;24）联网，本地代理（家庭路由器）记录你的归属地址 192.168.1.100。</p><ol start="2"><li>移动到公司（被访网络）</li></ol><p>公司网络是 10.0.0.0&#x2F;8，笔记本连接到公司 Wi-Fi。</p><p>外地代理（公司路由器）为你分配一个转交地址（如 10.0.0.5），并通知你的本地代理：“192.168.1.100 现在在 10.0.0.5”。</p><ol start="3"><li>数据转发流程</li></ol><p>同事（IP 192.168.1.200）给你发送数据包，目标地址是你的归属地址 192.168.1.100。</p><p>本地代理（家庭路由器）拦截该数据包，通过隧道封装（如 IP-in-IP）发送到转交地址 10.0.0.5。</p><p>外地代理（公司路由器）解封装数据包，最终递交给你的笔记本。</p><ol start="4"><li>你的回复</li></ol><p>笔记本直接通过公司网络（10.0.0.0&#x2F;8）发送回复，无需经过本地代理（优化路径）。</p><h4 id="路由器的交付"><a href="#路由器的交付" class="headerlink" title="路由器的交付"></a>路由器的交付</h4><h4 id="直接交付-全程不经过路由器"><a href="#直接交付-全程不经过路由器" class="headerlink" title="直接交付-全程不经过路由器"></a>直接交付-全程不经过路由器</h4><p>即若同属一个子网的A与B通信：主机 A（192.168.1.2）和主机 B（192.168.1.3）连接在同一交换机的局域网中（子网 192.168.1.0&#x2F;24）。</p><ol><li><p>主机 A 判断 192.168.1.3 属于同一子网。</p></li><li><p>主机 A 发送 ARP 请求：“谁是 192.168.1.3？请告诉你的 MAC 地址”。</p></li><li><p>主机 B 回复 ARP 响应，提供自己的 MAC 地址。</p></li><li><p>主机 A 将 ICMP 请求包（ping）封装目标 MAC 地址，通过交换机直接交付给主机 B。</p></li></ol><h4 id="间接交付-多次直接交付"><a href="#间接交付-多次直接交付" class="headerlink" title="间接交付-多次直接交付"></a>间接交付-多次直接交付</h4><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>实际通信流程示例</p><ul><li>场景：用FTP客户端（端口21）上传文件到服务器。</li></ul><ol><li>客户端：</li></ol><p>随机选择源端口（如50001），目标端口&#x3D;21。<br>发送数据包：源Socket&#x3D;192.168.1.100:50001，目的Socket&#x3D;203.0.113.5:21。</p><ol start="2"><li>服务器：</li></ol><p>通过端口21识别FTP服务进程，处理请求。<br>返回数据时，源Socket&#x3D;203.0.113.5:21，目的Socket&#x3D;192.168.1.100:50001。</p><ol start="3"><li>多任务支持：</li></ol><p>同一台服务器可同时处理多个FTP连接，因为每个客户端的源Socket不同（如192.168.1.100:50001 vs 192.168.1.101:60000）</p><h4 id="Q：UDP完全不靠谱吗？"><a href="#Q：UDP完全不靠谱吗？" class="headerlink" title="Q：UDP完全不靠谱吗？"></a>Q：UDP完全不靠谱吗？</h4><p>不是！UDP的不可靠指协议本身不提供重传等机制，但应用层可自行实现可靠性（如QUIC协议）。</p><h4 id="Q：TCP一定比UDP慢？"><a href="#Q：TCP一定比UDP慢？" class="headerlink" title="Q：TCP一定比UDP慢？"></a>Q：TCP一定比UDP慢？</h4><p>不一定！在丢包率低的网络中，TCP的流量控制能优化吞吐量；而UDP在高丢包时可能因无重传更快。</p><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><ul><li>为什么要使用三次握手？</li></ul><ol><li>不使用三次握手</li></ol><p>若客户端发送SYN&#x3D;1, Seq&#x3D;100（第一次握手），但因网络延迟未到达服务器。</p><p>客户端超时重传SYN&#x3D;1, Seq&#x3D;200（新请求），成功建立连接并传输数据后关闭。</p><p>此时旧SYN（Seq&#x3D;100）突然到达服务器，若仅用两次握手：</p><p>服务器误认为新连接，回复SYN-ACK并分配资源。</p><p>客户端实际已关闭连接，不会回复ACK，导致服务器一直等待（资源浪费）。</p><ol start="2"><li>三次握手如何解决：</li></ol><p>客户端对旧SYN-ACK（应答Seq&#x3D;100）会回复RST（重置），因为当前连接已失效。（客户端已经完成了Seq&#x3D;200的连接并关闭了。它现在并没有处于“SYN_SENT”或“ESTABLISHED”状态。当它收到这个SYN-ACK（Seq&#x3D;300，对Seq&#x3D;100的响应）时，发现这不是自己当前期望的报文。于是客户端直接丢弃这个SYN-ACK，并发送RST（Reset）报文给服务器。RST的作用是告诉服务器：“这个连接我已经不认了，请你别等了。”）</p><p>关键点：第三次握手（ACK）是客户端对服务器响应的确认，表明连接是“新鲜”的。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="域名解析过程示例（以查询-1chendian2-github-io-为例）"><a href="#域名解析过程示例（以查询-1chendian2-github-io-为例）" class="headerlink" title="域名解析过程示例（以查询 1chendian2.github.io 为例）"></a>域名解析过程示例（以查询 1chendian2.github.io 为例）</h4><p>假设你的计算机（客户机）需要访问 <code>1chendian2.github.io</code>，但不知道它的 IP 地址，于是触发 DNS 解析过程。整个过程涉及 <strong>递归查询 + 迭代查询</strong>，并可能发送 <strong>最多 8 个 UDP 报文</strong>（4 次查询 + 4 次响应）。  </p><p>步骤详解</p><ul><li><strong>① 客户机 → 本地域名服务器（递归查询）</strong></li></ul><ol><li><strong>动作</strong>：你的计算机向 <strong>本地 DNS 服务器</strong>（如 ISP 提供的 DNS 服务器）发送一个 <strong>DNS 请求报文</strong>（查询 <code>1chendian2.github.io</code> 的 IP）。  </li><li><strong>查询方式</strong>：<strong>递归查询</strong>（即本地 DNS 服务器必须返回最终结果，不能让你自己去问其他服务器）。</li></ol><blockquote><p><strong>报文计数</strong>：  </p><ul><li>查询报文 1（客户机 → 本地 DNS）  </li><li>响应报文 1（本地 DNS → 客户机，但此时可能无缓存，需后续查询）</li></ul></blockquote><hr><ul><li><strong>② 本地 DNS 服务器查询缓存</strong></li></ul><ol><li>如果本地 DNS 服务器缓存中有 <code>1chendian2.github.io</code> 的记录，直接返回 IP（解析结束）。  </li><li><strong>若无缓存</strong>，则本地 DNS 服务器代表客户机，向 <strong>根域名服务器</strong> 发起 <strong>迭代查询</strong>。</li></ol><hr><ul><li><strong>③ 本地 DNS → 根域名服务器（迭代查询）</strong></li></ul><ol><li><strong>动作</strong>：本地 DNS 服务器向 <strong>根域名服务器</strong> 查询 <code>1chendian2.github.io</code> 的 IP。<em><strong>（三级域名的网站、四级域名网站见2016计算机408考研）</strong></em></li><li><strong>根域名服务器回复</strong>：“我不知道 <code>1chendian2.github.io</code> 的 IP，但 <code>.com</code> 顶级域名服务器（TLD）的地址是 <code>X.X.X.X</code>，你去问它。”</li></ol><blockquote><p><strong>报文计数</strong>：  </p><ul><li>查询报文 2（本地 DNS → 根服务器）  </li><li>响应报文 2（根服务器 → 本地 DNS，返回 <code>.com</code> TLD 地址）</li></ul></blockquote><hr><ul><li><strong>④ 本地 DNS → .com 顶级域名服务器（迭代查询）</strong></li></ul><ol><li><strong>动作</strong>：本地 DNS 服务器向 <code>.com</code> TLD 服务器（<code>dns.com</code>）查询 <code>1chendian2.github.io</code> 的 IP。  </li><li><strong>TLD 服务器回复</strong>：“我不知道 <code>1chendian2.github.io</code> 的 IP，但 <code>abc.com</code> 的权威域名服务器（<code>dns.abc.com</code>）的地址是 <code>Y.Y.Y.Y</code>，你去问它。”</li></ol><blockquote><p><strong>报文计数</strong>：  </p><ul><li>查询报文 3（本地 DNS → .com TLD）  </li><li>响应报文 3（.com TLD → 本地 DNS，返回 <code>dns.abc.com</code> 地址）</li></ul></blockquote><hr><ul><li><strong>⑤ 本地 DNS → abc.com 权威域名服务器（迭代查询）</strong></li></ul><ol><li><strong>动作</strong>：本地 DNS 服务器向 <code>dns.abc.com</code>（权威服务器）查询 <code>1chendian2.github.io</code> 的 IP。  </li><li><strong>权威服务器回复</strong>：“<code>1chendian2.github.io</code> 的 IP 是 <code>192.0.2.100</code>。”</li></ol><blockquote><p><strong>报文计数</strong>：  </p><ul><li>查询报文 4（本地 DNS → <code>dns.abc.com</code>）  </li><li>响应报文 4（<code>dns.abc.com</code> → 本地 DNS，返回 <code>1chendian2.github.io</code> 的 IP）</li></ul></blockquote><hr><ul><li><strong>⑥ 本地 DNS 缓存并返回结果给客户机</strong></li></ul><ol><li><strong>动作</strong>：本地 DNS 服务器缓存 <code>1chendian2.github.io</code> 的 IP（<code>192.0.2.100</code>），然后返回给客户机。  </li><li><strong>客户机</strong> 拿到 IP 后，即可访问 <code>1chendian2.github.io</code>。</li></ol><blockquote><p><strong>报文计数</strong>：  </p><ul><li>响应报文 5（本地 DNS → 客户机，返回最终 IP）</li></ul></blockquote><hr><ul><li><strong>总结（报文流程）</strong></li></ul><table><thead><tr><th><strong>步骤</strong></th><th><strong>查询方 → 被查询方</strong></th><th><strong>查询方式</strong></th><th><strong>返回内容</strong></th><th><strong>报文类型</strong></th></tr></thead><tbody><tr><td>①</td><td>客户机 → 本地 DNS</td><td>递归查询</td><td>（无缓存，需进一步查询）</td><td>查询 1</td></tr><tr><td>②</td><td>本地 DNS → 根服务器</td><td>迭代查询</td><td><code>.com</code> TLD 服务器地址</td><td>查询 2 + 响应 2</td></tr><tr><td>③</td><td>本地 DNS → .com TLD</td><td>迭代查询</td><td><code>abc.com</code> 权威服务器地址</td><td>查询 3 + 响应 3</td></tr><tr><td>④</td><td>本地 DNS → <code>dns.abc.com</code></td><td>迭代查询</td><td><code>1chendian2.github.io</code> 的 IP</td><td>查询 4 + 响应 4</td></tr><tr><td>⑤</td><td>本地 DNS → 客户机</td><td>递归响应</td><td><code>192.0.2.100</code></td><td>响应 5</td></tr></tbody></table><p><strong>总报文数</strong>：5 次查询&#x2F;响应（若严格按 UDP 计算，可视为 8 个报文）。  </p><hr><ul><li><strong>DNS 缓存优化</strong></li></ul><ol><li><strong>本地 DNS 缓存</strong>：存储最近查询的域名，减少重复查询。  </li><li><strong>客户机缓存</strong>：如浏览器、操作系统也会缓存 DNS 记录（TTL 到期后清除）。  </li><li><strong>减少查询次数</strong>：若缓存命中，可跳过部分步骤（如直接问权威服务器）。</li></ol><hr><ul><li><strong>关键点</strong>  </li><li></li></ul><p>✅ <strong>递归查询</strong>：客户机要求本地 DNS 服务器“必须给我最终答案”。<br>✅ <strong>迭代查询</strong>：本地 DNS 服务器一步步问其他服务器（根 → TLD → 权威）。<br>✅ <strong>UDP 报文</strong>：DNS 默认使用 UDP（快速、轻量），但大响应可能用 TCP。<br>✅ <strong>缓存机制</strong>：提高解析速度，减少根服务器压力。  </p><p>这样，<code>1chendian2.github.io</code> 的 IP 就被成功解析，计算机可以访问该网站了！ </p><h4 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h4><p><strong>FTP 工作原理详解（以文件传输为例）</strong>  </p><p>FTP（File Transfer Protocol，文件传输协议）用于在客户端和服务器之间传输文件。它使用 <strong>两个独立的 TCP 连接</strong>：<strong>控制连接</strong>（端口 21）和 <strong>数据连接</strong>（端口 20）。下面以客户端上传文件 <code>example.txt</code> 到 FTP 服务器为例，详细说明 FTP 的工作流程。  </p><hr><ol><li><strong>FTP 连接建立（控制连接）</strong></li></ol><p><strong>① 客户端发起控制连接（TCP 三次握手）</strong></p><ul><li><strong>动作</strong>：客户端向 FTP 服务器的 <strong>21 端口</strong> 发起 TCP 连接请求（SYN）。  </li><li><strong>服务器响应</strong>：服务器接受连接（SYN-ACK），完成三次握手（ACK）。  </li><li><strong>作用</strong>：建立 <strong>控制连接</strong>，用于发送 FTP 命令（如登录、切换目录、上传&#x2F;下载请求等）。</li></ul><blockquote><p><strong>示例命令</strong>（客户端发送）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER username  // 输入用户名</span><br><span class="line">PASS password  // 输入密码</span><br></pre></td></tr></table></figure></blockquote><hr><ol start="2"><li><strong>文件传输（数据连接）</strong><br>FTP 的数据连接有两种模式：<strong>主动模式（PORT）</strong> 和 <strong>被动模式（PASV）</strong>。</li></ol><p><strong>（1）主动模式（PORT）—— 服务器主动连接客户端</strong><br><strong>② 客户端发送 PORT 命令</strong></p><ul><li><strong>动作</strong>：客户端告诉服务器：“我在 <code>IP:端口</code>（如 <code>192.168.1.100:5000</code>）等你，请用 <strong>20 端口</strong> 连接我。”  </li><li><strong>服务器响应</strong>：服务器从 <strong>20 端口</strong> 发起 TCP 连接至客户端指定的端口（<code>192.168.1.100:5000</code>）。</li></ul><p><strong>③ 数据传输</strong></p><ul><li><strong>动作</strong>：客户端发送 <code>STOR example.txt</code>（上传）或 <code>RETR example.txt</code>（下载）。  </li><li><strong>数据流</strong>：文件内容通过 <strong>数据连接</strong>（20 → 5000）传输。</li></ul><blockquote><p><strong>适用场景</strong>：客户端位于公网（无防火墙限制），服务器能直接访问客户端。  </p></blockquote><hr><p><strong>（2）被动模式（PASV）—— 客户端主动连接服务器</strong><br><strong>② 客户端发送 PASV 命令</strong></p><ul><li><strong>动作</strong>：客户端请求服务器：“请告诉我一个端口，我来连接你。”  </li><li><strong>服务器响应</strong>：服务器随机开放一个端口（如 <code>3000</code>），并回复：<code>227 Entering Passive Mode (192.168.1.1,3000)</code>。</li></ul><p><strong>③ 客户端连接服务器端口</strong></p><ul><li><strong>动作</strong>：客户端主动连接服务器的 <code>3000</code> 端口，建立数据通道。</li></ul><p><strong>④ 数据传输</strong></p><ul><li><strong>动作</strong>：客户端发送 <code>STOR example.txt</code> 或 <code>RETR example.txt</code>。  </li><li><strong>数据流</strong>：文件内容通过 <strong>数据连接</strong>（客户端 → 3000）传输。</li></ul><blockquote><p><strong>适用场景</strong>：客户端位于 NAT&#x2F;防火墙后（如家庭网络），无法被服务器直接访问。  </p></blockquote><hr><ol start="3"><li><strong>连接关闭</strong><br><strong>⑤ 传输完成，关闭连接</strong></li></ol><ul><li><strong>控制连接</strong>：保持开放，可继续发送其他命令（如 <code>LIST</code> 查看目录）。  </li><li><strong>数据连接</strong>：传输完成后立即关闭。  </li><li><strong>退出</strong>：客户端发送 <code>QUIT</code>，服务器关闭控制连接。</li></ul><hr><ul><li><strong>FTP 关键特点总结</strong></li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>双通道</strong></td><td>控制连接（21） + 数据连接（20 或 PASV 随机端口）</td></tr><tr><td><strong>传输模式</strong></td><td>主动模式（PORT） &#x2F; 被动模式（PASV）</td></tr><tr><td><strong>协议依赖</strong></td><td>基于 TCP，确保可靠传输</td></tr><tr><td><strong>权限管理</strong></td><td>支持用户名&#x2F;密码认证，也可匿名登录（anonymous）</td></tr><tr><td><strong>跨平台</strong></td><td>可在不同操作系统（Windows&#x2F;Linux）间传输文件</td></tr></tbody></table><hr><ul><li><strong>FTP 与 HTTP 对比</strong></li></ul><table><thead><tr><th><strong>对比项</strong></th><th><strong>FTP</strong></th><th><strong>HTTP</strong></th></tr></thead><tbody><tr><td><strong>连接方式</strong></td><td>双连接（控制+数据）</td><td>单连接（请求-响应后关闭）</td></tr><tr><td><strong>传输效率</strong></td><td>适合大文件（可断点续传）</td><td>适合小文件（无状态）</td></tr><tr><td><strong>安全性</strong></td><td>默认明文（可搭配 FTPS&#x2F;SFTP）</td><td>可加密（HTTPS）</td></tr><tr><td><strong>用途</strong></td><td>文件管理（上传&#x2F;下载&#x2F;删除）</td><td>网页访问（GET&#x2F;POST）</td></tr></tbody></table><hr><ul><li><strong>实际应用场景</strong></li></ul><ol><li><strong>网站维护</strong>：通过 FTP 上传网页文件至服务器。  </li><li><strong>企业备份</strong>：自动备份数据库至远程 FTP 存储。  </li><li><strong>匿名共享</strong>：提供公共文件下载（如 Linux 镜像站）。</li></ol><p>通过上述流程，FTP 实现了高效、灵活的文件传输，适用于各种网络环境！ </p><h4 id="DNS（域名系统）-相关的记录类型"><a href="#DNS（域名系统）-相关的记录类型" class="headerlink" title="DNS（域名系统） 相关的记录类型"></a>DNS（域名系统） 相关的记录类型</h4><ol><li>A记录（Address Record）</li></ol><ul><li>作用：将域名指向一个 IPv4地址（如 192.0.2.1）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example.com.    A    192.0.2.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示访问 example.com 时解析到 192.0.2.1。</span></span><br></pre></td></tr></table></figure><ul><li>类似记录：</li></ul><p>AAAA记录：指向IPv6地址（如 2001:db8::1）。</p><ul><li>负载均衡：</li></ul><p>通过轮询A记录来实现。</p><ol start="2"><li>CNAME记录（Canonical Name Record）</li></ol><ul><li>作用：将域名 别名 指向另一个域名（真实域名），实现间接解析。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.example.com.    CNAME    example.com.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问 www.example.com 时，实际解析到 example.com 的IP。</span></span><br></pre></td></tr></table></figure><ul><li>注意：</li></ul><p>CNAME不能与其他记录（如MX、TXT）共存。常用于CDN、子域名统一管理。</p><h4 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h4><ul><li><p>发邮件：用户代理 → SMTP → 发送方SMTP服务器 → SMTP → 接收方SMTP服务器。</p></li><li><p>收邮件：用户代理 ← POP3&#x2F;IMAP ← 接收方服务器。</p></li><li><p>异步通信：邮件存储在服务器，收件人随时拉取。</p></li></ul><p>通过SMTP的“推”和POP3的“拉”，电子邮件实现了灵活、可靠的异步通信。</p><h4 id="万维网的工作流程"><a href="#万维网的工作流程" class="headerlink" title="万维网的工作流程"></a>万维网的工作流程</h4><ul><li>万维网的工作流程如下：</li></ul><ol><li>服务器监听TCP端口80，等待连接请求。  </li><li>浏览器发起请求，与服务器建立TCP连接。  </li><li>浏览器发送HTTP请求获取网页。  </li><li>服务器处理请求，构建所需信息并通过HTTP响应返回。  </li><li>浏览器解析响应并显示网页。  </li><li>释放TCP连接。</li></ol><h4 id="鼠标点击一个网页链接，会发生什么？"><a href="#鼠标点击一个网页链接，会发生什么？" class="headerlink" title="鼠标点击一个网页链接，会发生什么？"></a>鼠标点击一个网页链接，会发生什么？</h4><ol><li>应用层<br>DHCP（若未配置IP）：<br>用户主机通过DHCP协议自动获取本地网络的IP地址、子网掩码、默认网关等配置（若未手动配置）。</li></ol><p>DNS：<br>浏览器解析URL中的域名 <a href="http://www.tsinghua.edu.cn,向本地dns服务器发起查询请求,通过递归/%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2%E6%9C%80%E7%BB%88%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%88%E5%A6%82">www.tsinghua.edu.cn，向本地DNS服务器发起查询请求，通过递归/迭代查询最终获取目标服务器的IP地址（如</a> 166.111.4.100）。</p><p>HTTP：<br>浏览器生成HTTP请求（如 GET &#x2F;chn&#x2F;index.htm），并依赖下层协议（TCP）传输。</p><ol start="2"><li>传输层<br>TCP连接：<br>浏览器通过TCP协议与服务器建立可靠连接（三次握手），目标端口为80（HTTP默认端口）。</li></ol><p>若使用HTTPS：还需通过TLS协议加密（涉及SSL握手）。</p><p>UDP（可选）：<br>DNS查询通常使用UDP协议（端口53），因其无需建立连接，适合快速的小数据包传输。</p><ol start="3"><li>网络层（网际层）<br>IP路由：<br>HTTP请求被封装为IP数据包，源IP（用户主机）和目标IP（清华大学服务器）由路由器基于路由表逐跳转发。</li></ol><p>ARP：<br>在局域网内，通过ARP协议将网关IP地址解析为MAC地址，确保数据包能通过以太网传输。</p><ol start="4"><li>数据链路层<br>以太网（CSMA&#x2F;CD）：<br>在本地网络中，数据包封装为以太网帧，通过MAC地址寻址。若使用有线网络，遵循CSMA&#x2F;CD冲突检测机制（交换机环境下冲突较少）。</li></ol><p>PPP（广域网）：<br>若用户通过ISP拨号上网，数据链路层可能使用PPP协议封装IP数据包。</p><ol start="5"><li>物理层<br>数据最终转换为电信号（有线）或电磁波（无线），通过物理介质（如光纤、双绞线）传输至下一跳设备（如路由器、交换机）。</li></ol><h3 id="网络杂谈"><a href="#网络杂谈" class="headerlink" title="网络杂谈"></a>网络杂谈</h3><h4 id="嗯…-无法访问此页面"><a href="#嗯…-无法访问此页面" class="headerlink" title="嗯… 无法访问此页面"></a>嗯… 无法访问此页面</h4><p><em>已重置连接。请尝试：检查连接、检查代理和防火墙ERR_CONNECTION_RESET</em></p><ol><li>dns服务器解析错误：首先电脑出现网页无法正常访问而其他应用正常，大多数人都会想到是否是dns服务器出现了解析的问题，所以他们做的第一件事情通常是将DHCP修改为手动配置dns，当然，我一开始也是这样考虑的，于是我修改了手动dns，将dns服务器配置为<code>114.114.114.114</code>或者国内一些主流大厂的dns服务器（如腾讯和阿里的dns服务器），但是在修改过后且用<code>ipconfig /flushdns</code>命令清理dns缓存后，我发现该问题依旧会复现，且在发生问题的时候，通过终端是可以<code>ping</code>通发生问题网站的网址的，也没有发生丢包的情况，且用<code>nslookup</code>命令查看dns服务器解析目标网站的ip地址，也是正常解析的，因此我排除了dns出现问题的可能。</li></ol><h4 id="拨号上网"><a href="#拨号上网" class="headerlink" title="拨号上网"></a>拨号上网</h4><p><strong>拨号上网（Dial-up Internet Access）</strong> 是一种通过电话线模拟信号传输数据的早期互联网接入技术，曾在20世纪90年代至21世纪初广泛使用。其核心特点是利用电话网络和调制解调器（Modem）实现计算机与互联网服务提供商（ISP）的连接。</p><hr><p><strong>1. 工作原理</strong></p><ul><li><p><strong>调制解调器（Modem）</strong>：<br>将计算机的 <strong>数字信号</strong> 转换为电话线可传输的 <strong>模拟信号</strong>（调制），反之亦然（解调）。  </p><ul><li>拨号时，Modem会发出熟悉的“嘀嘀嘀…滋滋滋”握手音。</li></ul></li><li><p><strong>拨号过程</strong>：  </p><ol><li>用户通过计算机拨叫ISP提供的电话号码（如 <code>16300</code>）。  </li><li>电话线接通ISP的调制解调器池（Modem Pool）。  </li><li>双方Modem协商连接参数（如速率：56 Kbps）。  </li><li>建立PPP（点对点协议）连接，分配动态IP地址。</li></ol></li></ul><hr><p><strong>2. 主要特点</strong></p><ul><li><p><strong>低速传输</strong>：  </p><ul><li>理论最大速率 <strong>56 Kbps</strong>（实际受线路质量影响可能仅30-40 Kbps）。  </li><li>下载1MB文件需约3-5分钟，无法支持视频流媒体。</li></ul></li><li><p><strong>独占电话线</strong>：  </p><ul><li>上网时电话无法接听或拨出（“占线”）。  </li><li>部分家庭安装“分线器”但会降低网速。</li></ul></li><li><p><strong>按需连接</strong>：  </p><ul><li>每次上网需手动拨号，按时间计费（早期按分钟收费）。</li></ul></li></ul><hr><p><strong>3. 关键组件</strong></p><table><thead><tr><th><strong>组件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>调制解调器（Modem）</td><td>数模信号转换，支持拨号与数据传输。</td></tr><tr><td>电话线（PSTN）</td><td>物理传输介质，使用普通铜质电话线路。</td></tr><tr><td>ISP接入服务器</td><td>提供拨号号码、认证账号（如用户名&#x2F;密码）、分配IP地址。</td></tr><tr><td>PPP协议</td><td>管理数据封装、错误检测和IP地址分配（如 <code>PPPoE</code> 衍生协议用于后续宽带）。</td></tr></tbody></table><hr><p><strong>4. 与宽带对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>拨号上网</strong></th><th><strong>现代宽带（如光纤）</strong></th></tr></thead><tbody><tr><td>速度</td><td>56 Kbps</td><td>100 Mbps - 1 Gbps+</td></tr><tr><td>连接方式</td><td>按需拨号，临时连接</td><td>始终在线（Always-On）</td></tr><tr><td>电话线影响</td><td>上网时电话不可用</td><td>独立线路（电话&#x2F;网络分离）</td></tr><tr><td>典型费用</td><td>按分钟计费 + 电话费</td><td>包月固定费用</td></tr></tbody></table><hr><p><strong>5. 为什么被淘汰？</strong></p><ul><li><strong>速度瓶颈</strong>：无法满足网页多媒体化（如图片、视频）需求。  </li><li><strong>技术替代</strong>：  <ul><li><strong>DSL（如ADSL）</strong>：利用电话线高频频段，实现上网&#x2F;通话并行。  </li><li><strong>光纤&#x2F; Cable</strong>：更高带宽、更低延迟。</li></ul></li><li><strong>用户体验差</strong>：连接不稳定，易受干扰（如天气、电磁噪声）。</li></ul><hr><p><strong>6. 历史意义</strong></p><ul><li><strong>互联网普及先驱</strong>：推动早期家庭和中小企业接入互联网。  </li><li><strong>文化符号</strong>：拨号音成为一代人的集体记忆（如美国在线AOL的“Welcome”语音）。  </li><li><strong>技术基础</strong>：PPP协议衍生出PPPoE，至今用于部分宽带认证。</li></ul><hr><p><strong>常见问题</strong><br> Q1：现在还能用拨号上网吗？  </p><ul><li>少数偏远地区或特殊场景（如备份连接）仍支持，但主流ISP已逐步关闭服务。</li></ul><p> Q2：为什么拨号音听起来像“噪音”？  </p><ul><li>这是Modem的 <strong>握手协议（Handshaking）</strong>，通过不同频率音频协商参数（如V.34&#x2F;V.90标准）。</li></ul><p> Q3：拨号上网的IP地址是固定的吗？  </p><ul><li>通常是动态IP，每次拨号重新分配（类似现代家庭宽带的DHCP）。</li></ul><h1 id="本书梳理"><a href="#本书梳理" class="headerlink" title="本书梳理"></a>本书梳理</h1><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h3><h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><h4 id="电路、报文、分组交换"><a href="#电路、报文、分组交换" class="headerlink" title="电路、报文、分组交换"></a>电路、报文、分组交换</h4><h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><h4 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h4><h3 id="计算机网络的分层"><a href="#计算机网络的分层" class="headerlink" title="计算机网络的分层"></a>计算机网络的分层</h3><h4 id="ISO-OSI模型"><a href="#ISO-OSI模型" class="headerlink" title="ISO&#x2F;OSI模型"></a>ISO&#x2F;OSI模型</h4><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h4><hr><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><h4 id="波特率、比特率"><a href="#波特率、比特率" class="headerlink" title="波特率、比特率"></a>波特率、比特率</h4><h4 id="奈奎斯特、香农定理"><a href="#奈奎斯特、香农定理" class="headerlink" title="奈奎斯特、香农定理"></a>奈奎斯特、香农定理</h4><h4 id="曼彻斯特编码"><a href="#曼彻斯特编码" class="headerlink" title="曼彻斯特编码"></a>曼彻斯特编码</h4><h4 id="QAM技术"><a href="#QAM技术" class="headerlink" title="QAM技术"></a>QAM技术</h4><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><h4 id="双绞线、同轴电缆、光纤、无线介质"><a href="#双绞线、同轴电缆、光纤、无线介质" class="headerlink" title="双绞线、同轴电缆、光纤、无线介质"></a>双绞线、同轴电缆、光纤、无线介质</h4><h4 id="物理接口的特性"><a href="#物理接口的特性" class="headerlink" title="物理接口的特性"></a>物理接口的特性</h4><h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><hr><h2 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="封装成帧：组帧方法（4种）"><a href="#封装成帧：组帧方法（4种）" class="headerlink" title="封装成帧：组帧方法（4种）"></a>封装成帧：组帧方法（4种）</h3><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><h3 id="差错控制（检错-纠错）"><a href="#差错控制（检错-纠错）" class="headerlink" title="差错控制（检错&#x2F;纠错）"></a>差错控制（检错&#x2F;纠错）</h3><h3 id="流量控制与可靠传输（交织）"><a href="#流量控制与可靠传输（交织）" class="headerlink" title="流量控制与可靠传输（交织）"></a>流量控制与可靠传输（交织）</h3><h4 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h4><h5 id="非连续ARQ-SW"><a href="#非连续ARQ-SW" class="headerlink" title="非连续ARQ(SW)"></a>非连续ARQ(SW)</h5><h5 id="连续ARQ-GN-SR"><a href="#连续ARQ-GN-SR" class="headerlink" title="连续ARQ(GN\SR)"></a>连续ARQ(GN\SR)</h5><h3 id="介质访问控制-FDM-TDM-CDM-WDM-纯LOHA-时隙ALOHA-CSMA-CD-CSMA-CA-令牌传递"><a href="#介质访问控制-FDM-TDM-CDM-WDM-纯LOHA-时隙ALOHA-CSMA-CD-CSMA-CA-令牌传递" class="headerlink" title="介质访问控制(FDM\TDM\CDM\WDM\纯LOHA\时隙ALOHA\CSMA\\CD\CSMA\\CA\令牌传递)"></a>介质访问控制(FDM\TDM\CDM\WDM\纯LOHA\时隙ALOHA\CSMA\\CD\CSMA\\CA\令牌传递)</h3><h3 id="局域网-IEEE802-3-IEEE802-11-VLAN"><a href="#局域网-IEEE802-3-IEEE802-11-VLAN" class="headerlink" title="局域网(IEEE802.3\IEEE802.11\VLAN)"></a>局域网(IEEE802.3\IEEE802.11\VLAN)</h3><h3 id="广域网-PPP"><a href="#广域网-PPP" class="headerlink" title="广域网(PPP)"></a>广域网(PPP)</h3><h3 id="设备-网桥、交换机"><a href="#设备-网桥、交换机" class="headerlink" title="设备(网桥、交换机)"></a>设备(网桥、交换机)</h3><hr><h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层提供的两种服务、路由器的功能、SDN"><a href="#网络层提供的两种服务、路由器的功能、SDN" class="headerlink" title="网络层提供的两种服务、路由器的功能、SDN"></a>网络层提供的两种服务、路由器的功能、SDN</h3><h3 id="IPv4-NAT-划分子网-路由聚合-ARP-DCHP-ICMP"><a href="#IPv4-NAT-划分子网-路由聚合-ARP-DCHP-ICMP" class="headerlink" title="IPv4\NAT\划分子网\路由聚合\ARP\DCHP\ICMP"></a>IPv4\NAT\划分子网\路由聚合\ARP\DCHP\ICMP</h3><h3 id="IPv6-v4-v6转换"><a href="#IPv6-v4-v6转换" class="headerlink" title="IPv6\v4-v6转换"></a>IPv6\v4-v6转换</h3><h3 id="距离向量路由算法（协议）、链路状态算法（协议）、RIP-OSPF-BGP（路径向量协议）"><a href="#距离向量路由算法（协议）、链路状态算法（协议）、RIP-OSPF-BGP（路径向量协议）" class="headerlink" title="距离向量路由算法（协议）、链路状态算法（协议）、RIP\OSPF\BGP（路径向量协议）"></a>距离向量路由算法（协议）、链路状态算法（协议）、RIP\OSPF\BGP（路径向量协议）</h3><h3 id="IP多播、IGMP"><a href="#IP多播、IGMP" class="headerlink" title="IP多播、IGMP"></a>IP多播、IGMP</h3><h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h3><h3 id="冲突域和广播域、路由器的组成和功能"><a href="#冲突域和广播域、路由器的组成和功能" class="headerlink" title="冲突域和广播域、路由器的组成和功能"></a>冲突域和广播域、路由器的组成和功能</h3><hr><h2 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h2><h3 id="4个作用"><a href="#4个作用" class="headerlink" title="4个作用"></a>4个作用</h3><h3 id="UDP-格式、检验"><a href="#UDP-格式、检验" class="headerlink" title="UDP(格式、检验)"></a>UDP(格式、检验)</h3><h3 id="TCP-格式、连接管理、可靠传输、流量控制、拥塞控制"><a href="#TCP-格式、连接管理、可靠传输、流量控制、拥塞控制" class="headerlink" title="TCP(格式、连接管理、可靠传输、流量控制、拥塞控制)"></a>TCP(格式、连接管理、可靠传输、流量控制、拥塞控制)</h3><hr><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><h3 id="C-S-P2P"><a href="#C-S-P2P" class="headerlink" title="C&#x2F;S \ P2P"></a>C&#x2F;S \ P2P</h3><h3 id="DNS-3个组成部分"><a href="#DNS-3个组成部分" class="headerlink" title="DNS(3个组成部分)"></a>DNS(3个组成部分)</h3><h3 id="FTP-两条路径"><a href="#FTP-两条路径" class="headerlink" title="FTP(两条路径)"></a>FTP(两条路径)</h3><h3 id="E-MAIL-SMTP-POP3-MIME"><a href="#E-MAIL-SMTP-POP3-MIME" class="headerlink" title="E-MAIL(SMTP\POP3\MIME)"></a>E-MAIL(SMTP\POP3\MIME)</h3><h3 id="WWW-HTTP"><a href="#WWW-HTTP" class="headerlink" title="WWW(HTTP)"></a>WWW(HTTP)</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android开发课程</title>
      <link href="/2025/05/06/Android%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B/"/>
      <url>/2025/05/06/Android%E5%BC%80%E5%8F%91%E8%AF%BE%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>河南理工大学Android开发课程：共40学时（24理论学时、16实践学时），学分2.5。</p><h3 id="Android四层结构"><a href="#Android四层结构" class="headerlink" title="Android四层结构"></a>Android四层结构</h3><p><img src="/img/2025_5_6/001.png" alt="404"></p><ul><li><p>应用层(System Apps)<br>系统内置的<strong>应用程序以及非系统级的应用程序</strong>都属于应用层，负责与用户进行交互，一般使用Java或者Kotlin开发，也就是我们所说的应用层开发。</p></li><li><p>应用框架层(Java API Framework)<br>这一层为应用层开发提供所需要的Java API，也就是常说的Android系统的Java源码，这一层由Java代码编写，所以叫JavaFramework。</p></li><li><p>系统运行库层(Native)<br>从图中可以看出这里分为了两个部分，分别是C&#x2F;C++程序库和Android运行时库。</p><ol><li><p>C&#x2F;C++库<br>这些C&#x2F;C++库程序可以被应用框架层所使用，至于为什么Android系统要使用C&#x2F;C++库，而不都用Java库，原因主要是C&#x2F;C++代码执行效率更高，而且很多功能有成熟的C++代码，不用重新写</p></li><li><p>Android运行时库</p></li></ol></li></ul><p>分为核心库和ART。*（Android运行时环境（ART）自Android 4.4版本引入，并在后续版本中逐步取代了原有的Dalvik作为Android平台的默认运行时环境。）*其中核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。而ART则是专门为移动设备定制的Java虚拟机，在之前还有被淘汰的Dalvik虚拟机。ART和JVM还是有很大的区别，它是由C++编写，用来运行Java程序，所以非常关键。而且Android系统还允许同时允许多个ART实例，所以在Android系统中，每个进程都有一个虚拟机，一个APP发生崩溃不会影响其他APP。</p><ul><li>Linux内核层(Linux Kernel)<br>Android的核心服务是基于Linux内核，同时在该基础上添加了Android专用的驱动，比如Binder。由于Linux系统的优秀性，Android在基于Linux于安全性、内存管理、进程管理等都有很大优势。</li></ul><h3 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h3><p><img src="/img/2025_5_6/002.png" alt="404"></p><h4 id="Activity（活动）"><a href="#Activity（活动）" class="headerlink" title="Activity（活动）"></a>Activity（活动）</h4><ul><li>作用：</li></ul><p>用户交互的界面，负责展示UI并处理用户操作（如点击、滑动）。</p><ul><li>特点：</li></ul><p>一个应用通常由多个Activity组成，通过栈管理（任务栈）。<br>通过Intent跳转或传递数据。<br>生命周期回调（如onCreate()、onDestroy()）用于管理资源。</p><h4 id="Service（服务）"><a href="#Service（服务）" class="headerlink" title="Service（服务）"></a>Service（服务）</h4><ul><li>作用：</li></ul><p>在后台执行长时间运行的操作（如下载、播放音乐），无界面。</p><ul><li>特点：</li></ul><p>启动服务：通过startService()启动，需手动停止。<br>绑定服务：通过bindService()与组件绑定，可跨进程通信（IPC）。<br>典型场景：后台网络请求、定时任务等。</p><h4 id="BroadcastReceiver（广播接收器）"><a href="#BroadcastReceiver（广播接收器）" class="headerlink" title="BroadcastReceiver（广播接收器）"></a>BroadcastReceiver（广播接收器）</h4><ul><li><p>作用：监听系统或应用发出的广播（如电量不足、网络变化），并触发响应。</p></li><li><p>特点：</p></li></ul><p>可启用Activity、Notification通知</p><h4 id="ContentProvider（内容提供者）"><a href="#ContentProvider（内容提供者）" class="headerlink" title="ContentProvider（内容提供者）"></a>ContentProvider（内容提供者）</h4><ul><li><p>作用：管理应用间数据共享，提供统一的访问接口（如通讯录、数据库）。</p></li><li><p>特点：</p></li></ul><p>通过ContentResolver操作数据（增删改查）。<br>支持权限控制，保障数据安全。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>Intent（意图）：四大组件间通信的纽带，可显式&#x2F;隐式指定目标组件。</p><p>AndroidManifest.xml：所有组件需在此文件中声明（注册），否则无法使用。</p><p>四大组件各司其职，共同构成Android应用的基石：Activity管界面、Service管后台、BroadcastReceiver管事件、ContentProvider管数据共享。</p><h3 id="Log类"><a href="#Log类" class="headerlink" title="Log类"></a>Log类</h3><p>Android 的 <code>Log</code> 类提供了不同级别的日志输出方法，用于不同场景的调试和问题追踪。以下是它们的含义和典型使用场景：</p><hr><h4 id="1-Log-v-Verbose（详细日志）"><a href="#1-Log-v-Verbose（详细日志）" class="headerlink" title="1. Log.v() - Verbose（详细日志）"></a><strong>1. <code>Log.v()</code> - Verbose（详细日志）</strong></h4><ul><li><strong>级别</strong>：最低，输出最详细的日志信息</li><li><strong>使用场景</strong>：<ul><li>开发阶段的详细流程跟踪</li><li>需要记录大量调试信息时（如循环、高频事件）</li><li><strong>生产环境应关闭</strong></li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.v(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onCreate() called&quot;</span>); </span><br><span class="line"><span class="comment">// 输出：V/TAG: onCreate() called</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="2-Log-d-Debug（调试日志）"><a href="#2-Log-d-Debug（调试日志）" class="headerlink" title="2. Log.d() - Debug（调试日志）"></a><strong>2. <code>Log.d()</code> - Debug（调试日志）</strong></h4><ul><li><strong>级别</strong>：调试信息</li><li><strong>使用场景</strong>：<ul><li>开发时检查变量值、方法调用流程</li><li>临时调试问题（完成后建议删除）</li><li><strong>生产环境建议关闭</strong></li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;User ID: &quot;</span> + userId); </span><br><span class="line"><span class="comment">// 输出：D/TAG: User ID: 123</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-Log-i-Info（信息日志）"><a href="#3-Log-i-Info（信息日志）" class="headerlink" title="3. Log.i() - Info（信息日志）"></a><strong>3. <code>Log.i()</code> - Info（信息日志）</strong></h4><ul><li><strong>级别</strong>：重要运行时信息</li><li><strong>使用场景</strong>：<ul><li>记录关键业务流程（如用户登录、支付成功）</li><li>需要长期保留的运行时状态</li><li><strong>生产环境可保留</strong></li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.i(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;App started, version: 1.2.0&quot;</span>); </span><br><span class="line"><span class="comment">// 输出：I/TAG: App started, version: 1.2.0</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-Log-w-Warning（警告日志）"><a href="#4-Log-w-Warning（警告日志）" class="headerlink" title="4. Log.w() - Warning（警告日志）"></a><strong>4. <code>Log.w()</code> - Warning（警告日志）</strong></h4><ul><li><strong>级别</strong>：潜在问题</li><li><strong>使用场景</strong>：<ul><li>捕获非预期但可恢复的情况（如低内存、网络超时重试）</li><li>标记需要关注的边界条件</li><li><strong>生产环境必须监控</strong></li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Log.w(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;Low memory, cache cleared&quot;</span>); </span><br><span class="line"><span class="comment">// 输出：W/TAG: Low memory, cache cleared</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="5-Log-e-Error（错误日志）"><a href="#5-Log-e-Error（错误日志）" class="headerlink" title="5. Log.e() - Error（错误日志）"></a><strong>5. <code>Log.e()</code> - Error（错误日志）</strong></h4><ul><li><strong>级别</strong>：严重错误</li><li><strong>使用场景</strong>：<ul><li>记录崩溃前的错误（如异常捕获）</li><li>关键功能失败（如数据库写入失败）</li><li><strong>生产环境必须紧急处理</strong></li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 危险操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;Failed to save data&quot;</span>, e); </span><br><span class="line">    <span class="comment">// 输出：E/TAG: Failed to save data [附带异常堆栈]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建一个跳转按钮"><a href="#创建一个跳转按钮" class="headerlink" title="创建一个跳转按钮"></a>创建一个跳转按钮</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Button btn=findViewById(R.id.btn);</span><br><span class="line">btn.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;   <span class="comment">// 这里是匿名类的实例化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;btn&quot;</span>);</span><br><span class="line">      <span class="comment">/*TAG是日志标签，一般为类名，借助它能够对日志进行过滤。</span></span><br><span class="line"><span class="comment">      &quot;btn&quot;是日志的具体信息，一般用来标记某个事件，在此处或许表示按钮（Button）被点击了。*/</span></span><br><span class="line">      <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity2.<span class="built_in">this</span>,MainActivity.class);</span><br><span class="line">      <span class="comment">/*Intent是负责在不同组件间进行通信的载体。*/</span></span><br><span class="line">      startActivity(intent);</span><br><span class="line">      <span class="comment">/*startActivity(intent);执行意图*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接通过 new 接口名() &#123; ... &#125; 的方式实现接口，没有显式定义类名。</span></span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>;  <span class="comment">// 唯一的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性布局的权重"><a href="#线性布局的权重" class="headerlink" title="线性布局的权重"></a>线性布局的权重</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span> //<span class="attr">该行为权重</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span>    //vertical时，高为0</span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:autoLink</span>=<span class="string">&quot;phone&quot;</span>    //<span class="attr">可设置不同的值</span>，<span class="attr">对应的部分会成为超链接</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;http://www.baidu.com 13312345678 test@163.com&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="做一个登录界面"><a href="#做一个登录界面" class="headerlink" title="做一个登录界面"></a>做一个登录界面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText usernameEditText;</span><br><span class="line">    <span class="keyword">private</span> EditText passwordEditText;</span><br><span class="line">    <span class="keyword">private</span> Button loginButton;</span><br><span class="line">    <span class="keyword">private</span> Button registerButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        EdgeToEdge.enable(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//实现全面屏，例如挖孔屏可以覆盖孔</span></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//它将指定的 XML 布局文件加载到当前 Activity 的窗口中</span></span><br><span class="line">        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;</span><br><span class="line">            <span class="type">Insets</span> <span class="variable">systemBars</span> <span class="operator">=</span> insets.getInsets(WindowInsetsCompat.Type.systemBars());</span><br><span class="line">            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);</span><br><span class="line">            <span class="keyword">return</span> insets;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//init</span></span><br><span class="line">        usernameEditText = findViewById(R.id.usernameEditText);</span><br><span class="line">        <span class="comment">//通过资源 ID 查找并初始化用户界面组件</span></span><br><span class="line">        passwordEditText = findViewById(R.id.passwordEditText);</span><br><span class="line">        loginButton = findViewById(R.id.loginButton);</span><br><span class="line">        registerButton = findViewById(R.id.registerButton);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// logic</span></span><br><span class="line">        loginButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(usernameEditText.getText().toString().trim())</span><br><span class="line">                || <span class="string">&quot;&quot;</span>.equals(passwordEditText.getText().toString().trim()))&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;用户名/密码不能为空&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则</span></span><br><span class="line">                <span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> getSharedPreferences(<span class="string">&quot;user&quot;</span>,MODE_PRIVATE);</span><br><span class="line">                <span class="comment">/*参数 1：&quot;user&quot; 是共享偏好文件的名称，系统会在应用内部存储中创建名为 user.xml 的文件。</span></span><br><span class="line"><span class="comment">                  参数 2：MODE_PRIVATE 指定该文件仅能被当前应用访问，其他应用无法读取或修改。</span></span><br><span class="line"><span class="comment">                  数据以 键值对（Key-Value） 形式保存在 XML 文件中。</span></span><br><span class="line"><span class="comment">                  常用于存储轻量级应用数据（如用户设置、登录状态等）。</span></span><br><span class="line"><span class="comment">                  数据存储在 /data/data/应用包名/shared_prefs/user.xml，root 设备可查看。</span></span><br><span class="line"><span class="comment">                  线程安全。 */</span></span><br><span class="line">                <span class="keyword">if</span>(sp.getString(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;1&quot;</span>).equals(usernameEditText.getText().toString())</span><br><span class="line">                    &amp;&amp; sp.getString(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;2&quot;</span>).equals(passwordEditText.getText().toString()))&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;登录成功&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*String getString(String key, String defaultValue)</span></span><br><span class="line"><span class="comment">                key：要获取数据的键（String 类型）。</span></span><br><span class="line"><span class="comment">                defaultValue：如果指定的 key 不存在（意思是数据库中就没有这个键）时返回的默认值。 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        registerButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,MainActivity2.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做一个注册界面"><a href="#做一个注册界面" class="headerlink" title="做一个注册界面"></a>做一个注册界面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity2</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText registerUsernameEditText;</span><br><span class="line">    <span class="keyword">private</span> EditText registerPasswordEditText;</span><br><span class="line">    <span class="keyword">private</span> EditText confirmPasswordEditText;</span><br><span class="line">    <span class="keyword">private</span> Button registerSubmitButton;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFS_NAME=<span class="string">&quot;user&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME_KEY=<span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD_KEY=<span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        EdgeToEdge.enable(<span class="built_in">this</span>);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line">        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;</span><br><span class="line">            <span class="type">Insets</span> <span class="variable">systemBars</span> <span class="operator">=</span> insets.getInsets(WindowInsetsCompat.Type.systemBars());</span><br><span class="line">            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);</span><br><span class="line">            <span class="keyword">return</span> insets;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        registerUsernameEditText = findViewById(R.id.registerUsernameEditText);</span><br><span class="line">        registerPasswordEditText = findViewById(R.id.registerPasswordEditText);</span><br><span class="line">        confirmPasswordEditText = findViewById(R.id.confirmPasswordEditText);</span><br><span class="line">        registerSubmitButton = findViewById(R.id.registerSubmitButton);</span><br><span class="line"></span><br><span class="line">        registerSubmitButton.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> registerUsernameEditText.getText().toString();</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> registerPasswordEditText.getText().toString();</span><br><span class="line">                <span class="type">String</span> <span class="variable">confirmPassword</span> <span class="operator">=</span> confirmPasswordEditText.getText().toString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (username.isEmpty() || password.isEmpty() || !password.equals(confirmPassword))&#123;</span><br><span class="line">                    Toast.makeText(MainActivity2.<span class="built_in">this</span>, <span class="string">&quot;用户名与密码都不能为空，而且两次密码的输入都需要一致&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">SharedPreferences</span> <span class="variable">sharedPreferences</span> <span class="operator">=</span> getSharedPreferences(PREFS_NAME,MODE_PRIVATE);</span><br><span class="line">                <span class="comment">/*共享偏好</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                SharedPreferences.<span class="type">Editor</span> <span class="variable">editor</span> <span class="operator">=</span> sharedPreferences.edit();</span><br><span class="line">                <span class="comment">/*要对共享偏好文件进行写入操作，得先获取编辑器对象。</span></span><br><span class="line"><span class="comment">                SharedPreferences.Editor 是 Android 中用于修改共享偏好文件（SharedPreferences）的接口。</span></span><br><span class="line"><span class="comment">                Editor putString(String key, String value);</span></span><br><span class="line"><span class="comment">                Editor putInt(String key, int value);</span></span><br><span class="line"><span class="comment">                Editor putBoolean(String key, boolean value);等</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                editor.putString(USERNAME_KEY,username);</span><br><span class="line">                editor.putString(PASSWORD_KEY,password);</span><br><span class="line">                <span class="comment">/*把用户输入的 username 和 password 以字符串形式存进共享偏好文件</span></span><br><span class="line"><span class="comment">                USERNAME_KEY 和 PASSWORD_KEY 是自定义的键名。 */</span></span><br><span class="line">                editor.apply();</span><br><span class="line">                <span class="comment">//apply() 方法会异步地把修改内容写入磁盘。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                Toast.makeText(MainActivity2.<span class="built_in">this</span>, <span class="string">&quot;注册成功&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity2.<span class="built_in">this</span>,MainActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">                finish();</span><br><span class="line">                <span class="comment">//用于关闭当前 Activity </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="做一个可进行明-暗文切换的输入框"><a href="#做一个可进行明-暗文切换的输入框" class="headerlink" title="做一个可进行明&#x2F;暗文切换的输入框"></a>做一个可进行明&#x2F;暗文切换的输入框</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:endIconMode</span>=<span class="string">&quot;password_toggle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/passwordEditText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;密码&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.textfield.TextInputLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="密码格式的限制"><a href="#密码格式的限制" class="headerlink" title="密码格式的限制"></a>密码格式的限制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!password.matches(<span class="string">&quot;.*\\d.*&quot;</span>) || !password.matches(<span class="string">&quot;.*[a-zA-Z].*&quot;</span>) || !password.matches(<span class="string">&quot;.*[^a-zA-Z0-9].*&quot;</span>))&#123;</span><br><span class="line">  Toast.makeText(MainActivity2.<span class="built_in">this</span>, <span class="string">&quot;必须包含一个数字、一个字母、一个特殊字符&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类-以Handler为例"><a href="#匿名内部类-以Handler为例" class="headerlink" title="匿名内部类,以Handler为例"></a>匿名内部类,以Handler为例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口() &#123;</span><br><span class="line">    <span class="comment">// 重写父类的方法或实现接口的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先定义一个 Handler 的子类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Looper.getMainLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">        textView.setText((String) msg.obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在 Activity 中使用</span></span><br><span class="line"><span class="keyword">private</span> Handler handler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    textView = findViewById(R.id.textView);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建子类的实例</span></span><br><span class="line">    handler = <span class="keyword">new</span> <span class="title class_">MyHandler</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动子线程...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        EdgeToEdge.enable(<span class="built_in">this</span>);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; &#123;</span><br><span class="line">            <span class="type">Insets</span> <span class="variable">systemBars</span> <span class="operator">=</span> insets.getInsets(WindowInsetsCompat.Type.systemBars());</span><br><span class="line">            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);</span><br><span class="line">            <span class="keyword">return</span> insets;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.textView);</span><br><span class="line"></span><br><span class="line">       handler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper())&#123;</span><br><span class="line">        <span class="comment">//Handler：是一个 “桥梁”，负责把消息从子线程传递到主线程。</span></span><br><span class="line">        <span class="comment">//创建一个线程，并指定他的工作地点是主线程（Looper.getMainLooper()）。</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="comment">//重写 handleMessage() 方法，指定操作</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">               <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">               <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String)msg.obj;</span><br><span class="line">               textView.setText(result);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">/*将消息从子线程传递到主线程，确保 UI 更新操作在主线程执行。</span></span><br><span class="line"><span class="comment">       匿名内部类</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Message message= Message.obtain();</span><br><span class="line">               <span class="comment">//Message.obtain()：从消息池中获取一个消息对象（Coder拿一张便签纸）。</span></span><br><span class="line">               message.obj = <span class="string">&quot;后台任务完成&quot;</span>;</span><br><span class="line">               <span class="comment">//Coder在便签纸上写 “后台任务完成”</span></span><br><span class="line">               handler.sendMessage(message);</span><br><span class="line">               <span class="comment">//把便签纸交给Handler</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="comment">//匿名对象</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布局、组件及其属性"><a href="#布局、组件及其属性" class="headerlink" title="布局、组件及其属性"></a>布局、组件及其属性</h3><h4 id="LinearLayout（线性布局）"><a href="#LinearLayout（线性布局）" class="headerlink" title="LinearLayout（线性布局）"></a>LinearLayout（线性布局）</h4><ul><li>必备属性  android:orientation&#x3D;”vertical”</li></ul><h4 id="RelativeLayout（相对布局）"><a href="#RelativeLayout（相对布局）" class="headerlink" title="RelativeLayout（相对布局）"></a>RelativeLayout（相对布局）</h4><p>- </p><h4 id="TextView（文本框）"><a href="#TextView（文本框）" class="headerlink" title="TextView（文本框）"></a>TextView（文本框）</h4><ul><li>android:text&#x3D;”我是第二个页面”</li><li>android:textColor&#x3D;”#FF0000”</li><li>android:background&#x3D;”#FF0000”</li><li>android:layout_width&#x3D;”match_parent”   &#x2F;&#x2F;和父容器一样</li><li>android:layout_height&#x3D;”wrap_content”    &#x2F;&#x2F;合适，不大不小，默认规定的值</li><li>android:gravity&#x3D;”right”    &#x2F;&#x2F;靠右显示</li><li>android:layout_width&#x3D;”60dp”   &#x2F;&#x2F;单位为dp</li><li>android:layout_alignBaseline&#x3D;”@id&#x2F;etid”</li><li>android:layout_alignBaseline&#x3D;”@id&#x2F;etid”       &#x2F;&#x2F;是一个在 RelativeLayout 中使用的属性，用于将一个视图的基线（baseline）与另一个视图的基线对齐。这个属性通常用于对齐文本控件（如 TextView 或 EditText）的文本基线，使它们在视觉上对齐。$仅适用于 RelativeLayout</li><li>android:layout_toRightOf      &#x2F;&#x2F;用于将当前视图的左边缘放置在指定视图的右边缘的右侧。$仅适用于 RelativeLayout</li><li>android:layout_below&#x3D;”@id&#x2F;etid”     &#x2F;&#x2F;是一个在 RelativeLayout 中使用的属性，用于将当前视图的顶部放置在etid视图的底部的下方。这个属性通常用于控制视图之间的垂直布局关系。 $仅适用于 RelativeLayout<br>作用</li><li>android:layout_alignRight&#x3D;”@id&#x2F;etpwd”     &#x2F;&#x2F;是 Android 布局文件中的一种属性，用于指定当前视图的右边缘与另一个视图（这里是 etpwd）的右边缘对齐。$仅适用于 RelativeLayout</li><li>android:layout_toLeftOf&#x3D;”@id&#x2F;btncancel”     &#x2F;&#x2F;用于将一个视图的右边缘放置在另一个视图的左边缘的左侧 $仅适用于 RelativeLayout</li></ul><h4 id="Button（按钮）"><a href="#Button（按钮）" class="headerlink" title="Button（按钮）"></a>Button（按钮）</h4><ul><li>android:id&#x3D;”@+id&#x2F;btn”</li><li>android:text&#x3D;”跳转”</li><li>android:layout_width&#x3D;”match_parent”</li><li>android:layout_height&#x3D;”wrap_content”</li><li>android:layout_marginRight&#x3D;”10dp”     &#x2F;&#x2F;是一个用于设置视图（View）在父布局中右侧外边距的属性。它定义了视图与父布局右侧之间的空间距离。</li></ul><h4 id="EditText（文本编辑框）"><a href="#EditText（文本编辑框）" class="headerlink" title="EditText（文本编辑框）"></a>EditText（文本编辑框）</h4><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li>launcher：启动器</li><li>gradle：编译代码、处理资源、管理第三方库依赖、生成APK&#x2F;AAB文件，以及配置不同构建变体（如Debug&#x2F;Release）。</li><li>ctrl+O：快速添加重写方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（408考研）</title>
      <link href="/2025/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88408%E8%80%83%E7%A0%94%EF%BC%89/"/>
      <url>/2025/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88408%E8%80%83%E7%A0%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><h5 id="为什么间接寻址相对直接寻址可扩大寻址范围"><a href="#为什么间接寻址相对直接寻址可扩大寻址范围" class="headerlink" title="为什么间接寻址相对直接寻址可扩大寻址范围"></a>为什么间接寻址相对直接寻址可扩大寻址范围</h5><p>假设：</p><p>计算机的 指令字长16位，其中 地址字段占8位（直接寻址时）。</p><p>存储器的 地址总线宽度为16位（即最大寻址范围是64KB）。</p><p>内存单元存储的数据宽度也是 16位（即每个单元能存一个地址）。</p><ol><li>直接寻址的局限性<br>若采用直接寻址，地址字段仅8位，可直接寻址的范围是 2⁸ &#x3D; 256个单元（如0x00~0xFF）。</li></ol><p>这远小于存储器实际的64KB（16位地址）范围，造成了浪费。</p><ol start="2"><li>间接寻址的解决方式<br>间接寻址的地址字段（8位）不直接表示操作数地址，而是指向一个内存单元，该单元中存储了 完整的16位操作数地址。</li></ol><p>例如：</p><p>指令中的地址字段为 0x40（8位）。</p><p>CPU先访问内存单元 0x40，读取其中存储的 16位地址（如 0xA010）。</p><p>最终操作数位于 0xA010（16位地址，突破了8位限制）。</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><h5 id="x86架构与ARM架构"><a href="#x86架构与ARM架构" class="headerlink" title="x86架构与ARM架构"></a>x86架构与ARM架构</h5><p>特性        x86                         ARM<br>指令集    CISC（复杂指令）        RISC（精简指令）<br>功耗       较高（性能优先）        较低（能效优先）<br>主导领域    PC、服务器、高性能计算    移动设备、嵌入式、IoT<br>生态Windows&#x2F;Linux主流             Android&#x2F;iOS主导</p><h5 id="cmp-v-s-test"><a href="#cmp-v-s-test" class="headerlink" title="cmp v.s. test"></a>cmp v.s. test</h5><p>CMP vs TEST 核心区别<br>指令底层操作主要用途            影响的关键标志位<br>CMP    OP1 - OP2比较数值大小        ZF, CF, SF, OF<br>TESTOP1 &amp; OP2检查位模式或判断零值ZF, SF</p><ol><li>cmp</li></ol><p>关键标志位：</p><p>ZF&#x3D;1：两数相等（OP1 &#x3D;&#x3D; OP2）。</p><p>CF&#x3D;1：无符号数 OP1 &lt; OP2。</p><p>SF≠OF：有符号数 OP1 &lt; OP2。</p><ol start="2"><li>test</li></ol><p>ZF&#x3D;1：结果为零（所有位按位与后为0）。</p><p>SF&#x3D;1：结果的最高位为1（负数）。</p><p>概述：</p><h1 id="计算机系统导论"><a href="#计算机系统导论" class="headerlink" title="计算机系统导论"></a>计算机系统导论</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><h3 id="硬件层次"><a href="#硬件层次" class="headerlink" title="硬件层次"></a>硬件层次</h3><h4 id="冯诺依曼思想"><a href="#冯诺依曼思想" class="headerlink" title="冯诺依曼思想"></a>冯诺依曼思想</h4><h4 id="五大组成硬件"><a href="#五大组成硬件" class="headerlink" title="五大组成硬件"></a>五大组成硬件</h4><h3 id="软件层次"><a href="#软件层次" class="headerlink" title="软件层次"></a>软件层次</h3><h4 id="分为系统软件与应用软件"><a href="#分为系统软件与应用软件" class="headerlink" title="分为系统软件与应用软件"></a>分为系统软件与应用软件</h4><h4 id="三个级别的语言、各种翻译程序的概念、翻译的四个阶段"><a href="#三个级别的语言、各种翻译程序的概念、翻译的四个阶段" class="headerlink" title="三个级别的语言、各种翻译程序的概念、翻译的四个阶段"></a>三个级别的语言、各种翻译程序的概念、翻译的四个阶段</h4><h3 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h3><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h1 id="数据表示与运算"><a href="#数据表示与运算" class="headerlink" title="数据表示与运算"></a>数据表示与运算</h1><h2 id="不同进制数之间的转换"><a href="#不同进制数之间的转换" class="headerlink" title="不同进制数之间的转换"></a>不同进制数之间的转换</h2><h2 id="原码、反码、补码、移码之间的表示与转换"><a href="#原码、反码、补码、移码之间的表示与转换" class="headerlink" title="原码、反码、补码、移码之间的表示与转换"></a>原码、反码、补码、移码之间的表示与转换</h2><h2 id="运算方法与运算电路"><a href="#运算方法与运算电路" class="headerlink" title="运算方法与运算电路"></a>运算方法与运算电路</h2><h3 id="带标志加法器、算数逻辑单元、加减运算电路、乘法运算电路、除法运算电路"><a href="#带标志加法器、算数逻辑单元、加减运算电路、乘法运算电路、除法运算电路" class="headerlink" title="带标志加法器、算数逻辑单元、加减运算电路、乘法运算电路、除法运算电路"></a>带标志加法器、算数逻辑单元、加减运算电路、乘法运算电路、除法运算电路</h3><h3 id="定点数的移位、加减、乘除运算"><a href="#定点数的移位、加减、乘除运算" class="headerlink" title="定点数的移位、加减、乘除运算"></a>定点数的移位、加减、乘除运算</h3><h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h3><table><thead><tr><th><strong>层级</strong></th><th><strong>名称</strong></th><th><strong>关键功能</strong></th><th><strong>记忆口诀</strong></th></tr></thead><tbody><tr><td><strong>M4</strong></td><td>高级语言层</td><td>程序员编写的代码（如 C、Python），需编译成下层语言。</td><td>“<strong>写代码</strong>“</td></tr><tr><td><strong>M3</strong></td><td>汇编语言层</td><td>将高级语言编译为汇编指令（如 <code>MOV AX, 5</code>），再翻译为机器码。</td><td>“<strong>翻译成汇编</strong>“</td></tr><tr><td><strong>M2</strong></td><td>操作系统层</td><td>用机器语言实现操作系统功能（如进程调度、内存管理）。</td><td>“<strong>OS 干活</strong>“</td></tr><tr><td><strong>M1</strong></td><td>传统机器语言层</td><td>CPU 直接执行的二进制指令（如 <code>10110000</code>），是软硬件分界线。</td><td>“<strong>硬件能懂</strong>“</td></tr><tr><td><strong>M0</strong></td><td>微程序机器层</td><td>用微指令（更低级的控制信号）解释机器指令，由硬件直接执行。</td><td>“<strong>硬件细节</strong>“</td></tr></tbody></table><h3 id="汇编语言与机器语言在ARM与x86上的表现"><a href="#汇编语言与机器语言在ARM与x86上的表现" class="headerlink" title="汇编语言与机器语言在ARM与x86上的表现"></a>汇编语言与机器语言在ARM与x86上的表现</h3><table><thead><tr><th><strong>操作</strong></th><th><strong>x86 汇编指令</strong></th><th><strong>x86 机器指令（二进制）</strong></th><th><strong>ARM 汇编指令</strong></th><th><strong>ARM 机器指令（二进制）</strong></th></tr></thead><tbody><tr><td><strong>将 5 存入寄存器</strong></td><td><code>MOV AL, 5</code></td><td><code>10110000 00000101</code></td><td><code>MOV R0, #5</code></td><td><code>1110001110100000 00000101</code></td></tr><tr><td><strong>加法（寄存器+1）</strong></td><td><code>ADD AX, 1</code></td><td><code>00000100 00000001</code></td><td><code>ADD R0, R0, #1</code></td><td><code>1110000010000000 00000001</code></td></tr></tbody></table><p><strong>关键点</strong>：</p><ul><li><strong>x86</strong>：变长指令（1~15 字节），复杂寻址模式，兼容性强。  </li><li><strong>ARM</strong>：定长指令（4 字节），精简指令集（RISC），能效高。  </li><li><strong>同一操作在不同架构下的机器码和汇编指令完全不同</strong>，这是系统结构的影响</li></ul><h3 id="数据通路宽度"><a href="#数据通路宽度" class="headerlink" title="数据通路宽度"></a>数据通路宽度</h3><p>指CPU内部一次能处理的二进制位数，即ALU（算术逻辑单元）和寄存器之间的数据传输位数。ALU位数通常等于机器字长</p><h3 id="机器字长一般与CPU中通用寄存器的位数有关"><a href="#机器字长一般与CPU中通用寄存器的位数有关" class="headerlink" title="机器字长一般与CPU中通用寄存器的位数有关"></a>机器字长一般与CPU中通用寄存器的位数有关</h3><p>通用寄存器：CPU中用于暂存数据和地址的存储单元，其位数通常等于机器字长。</p><ul><li>示例：<br>32位CPU的通用寄存器（如EAX）是32位。<br>64位CPU的通用寄存器（如RAX）是64位。</li></ul><h3 id="对用户透明-不透明的寄存器（无需-需要程序员直接操作）"><a href="#对用户透明-不透明的寄存器（无需-需要程序员直接操作）" class="headerlink" title="对用户透明&#x2F;不透明的寄存器（无需&#x2F;需要程序员直接操作）"></a>对用户透明&#x2F;不透明的寄存器（无需&#x2F;需要程序员直接操作）</h3><ol><li>对用户透明的寄存器</li></ol><ul><li>指令寄存器（IR）</li></ul><p>存储当前正在解码的指令，完全由硬件控制。</p><ol start="2"><li>对用户不透明的寄存器</li></ol><ul><li>通用寄存器（如x86的EAX、ARM的R0-R12）</li></ul><p>存储运算数据或地址，程序员需显式使用（如MOV EAX, 5）。</p><ul><li>状态寄存器（FLAGS &#x2F; CPSR）</li></ul><p>包含条件码（零标志、进位标志等），程序员需通过分支指令（如JZ）或显式读写（如PUSHF）来使用。</p><ol start="3"><li>特殊情况</li></ol><p>**程序计数器（PC）**的透明性：分场景讨论</p><ul><li>大多数情况下透明（由硬件自动管理）</li></ul><p>普通顺序执行：CPU自动递增PC，程序员无需干预。</p><ul><li>特定情况下不透明（程序员需显式操作）</li></ul><p>汇编编程：直接通过指令修改PC（如x86的JMP、ARM的BX）。</p><h3 id="周期的差异与比较"><a href="#周期的差异与比较" class="headerlink" title="周期的差异与比较"></a>周期的差异与比较</h3><table><thead><tr><th><strong>周期类型</strong></th><th><strong>定义</strong></th><th><strong>组成关系</strong></th><th><strong>典型场景</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>时钟周期</strong></td><td>CPU时钟信号的一个完整振荡周期（CPU频率倒数）</td><td>最小单位时间</td><td>所有硬件同步操作的基础</td><td>2GHz CPU → 时钟周期&#x3D;0.5ns</td></tr><tr><td><strong>CPU周期</strong></td><td>完成一个基本操作的时间（如取指、执行）</td><td>1个CPU周期 &#x3D; 多个时钟周期</td><td>非流水线CPU的指令分阶段执行</td><td>取指周期&#x3D;4时钟周期，执行周期&#x3D;3时钟周期</td></tr><tr><td><strong>指令周期</strong></td><td>执行一条完整指令所需的时间</td><td>1个指令周期 &#x3D; 取指+解码+执行+访存+写回</td><td>衡量CPU处理单条指令的速度</td><td>简单指令CPI&#x3D;1，复杂指令CPI&gt;1</td></tr><tr><td><strong>中断周期</strong></td><td>处理硬件&#x2F;软件中断请求的完整流程时间</td><td>中断周期 &#x3D; 保存现场+执行中断服务程序+恢复现场</td><td>外设请求、异常处理</td><td>键盘输入触发中断，耗时约10-100时钟周期</td></tr><tr><td><strong>机器周期</strong></td><td>CPU执行一条指令所需的基本时间单位，通常由多个时钟周期（Clock Cycles）组成</td><td>一个机器周期包含以下阶段：取指、译码、执行、访存、写回</td><td></td><td></td></tr></tbody></table><h3 id="计算机中，CPU-的-CPI-与下列（A）因素无关。"><a href="#计算机中，CPU-的-CPI-与下列（A）因素无关。" class="headerlink" title="计算机中，CPU 的 CPI 与下列（A）因素无关。"></a>计算机中，CPU 的 CPI 与下列（A）因素无关。</h3><p>A. 时钟频率B. 系统结构C. 指令集D. 计算机组织</p><p>RISC（精简指令集）通常 CPI 较低（接近 1）。CISC（复杂指令集）某些指令可能需要多个周期（CPI &gt; 1）。<br>CPI 取决于 CPU 的架构、指令集和微架构优化，但与时钟频率无关。时钟频率影响的是 指令的执行速度（时间），而不是 每条指令所需的周期数（CPI）。</p><h3 id="0的表示"><a href="#0的表示" class="headerlink" title="0的表示"></a>0的表示</h3><p> <strong>1. 原码（Sign-Magnitude）</strong></p><ul><li><strong>+0</strong>：<code>00000000</code>（最高位 <code>0</code> 表示正，其余位为数值 <code>0</code>）</li><li><strong>-0</strong>：<code>10000000</code>（最高位 <code>1</code> 表示负，其余位为数值 <code>0</code>）</li><li><strong>特点</strong>：原码有 <strong>+0 和 -0 两种表示</strong>。</li></ul><p> <strong>2. 反码（Ones’ Complement）</strong></p><ul><li><strong>+0</strong>：<code>00000000</code>（与原码相同）</li><li><strong>-0</strong>：<code>11111111</code>（负数的反码是对其绝对值的原码逐位取反）</li><li><strong>特点</strong>：反码也有 <strong>+0 和 -0 两种表示</strong>。</li></ul><p> <strong>3. 补码（Two’s Complement）</strong></p><ul><li><strong>+0</strong>：<code>00000000</code>（与原码相同）</li><li><strong>-0</strong>：补码规定 <strong>0 只有一种表示</strong>，即 <code>00000000</code>，而 <code>10000000</code> 表示 <strong>-128</strong>（8位补码的最小值）。</li><li><strong>特点</strong>：补码 <strong>没有 -0</strong>，使得表示范围比原码和反码多一个数（-128）。</li></ul><p> <strong>4. 移码（Excess-K，通常用于浮点数阶码）</strong></p><ul><li>移码 &#x3D; <strong>真值 + 偏移量（通常 ( K &#x3D; 2^{n-1} ) 或 ( 2^{n-1}-1 )）</strong></li><li>以 <strong>偏移量 ( K &#x3D; 128 )</strong>（8位移码）为例：<ul><li><strong>+0</strong>：<code>0 + 128 = 128</code> → <code>10000000</code></li><li><strong>-0</strong>：<code>-0 + 128 = 128</code> → <code>10000000</code></li></ul></li><li><strong>特点</strong>：移码 <strong>没有 +0 和 -0 的区别</strong>，统一表示为 <code>10000000</code>。</li><li>王道计组2-1-5-24</li></ul><h3 id="“当且仅当”-的含义"><a href="#“当且仅当”-的含义" class="headerlink" title="“当且仅当” 的含义"></a>“当且仅当” 的含义</h3><p>A ⇔ B（A 和 B 完全等价）</p><p>在逻辑和数学中，“当且仅当”（if and only if，缩写为 iff）表示 两个命题在逻辑上完全等价，即：</p><ul><li>如果 A 成立，那么 B 一定成立（A ⇒ B）</li><li>如果 B 成立，那么 A 也一定成立（B ⇒ A）</li></ul><h3 id="CF中的Cout"><a href="#CF中的Cout" class="headerlink" title="CF中的Cout"></a>CF中的Cout</h3><ol><li>加法时：最高位产生进位：Cout &#x3D; 1</li><li>减法时：最高位不够减，借一：Cout&#x3D;0</li><li>Cout<em>异或</em>Sub &#x3D; CF</li><li>CF只对无符号数有意义</li></ol><ul><li>关于<strong>2</strong>的理解：计算 000 - 111（3位无符号数）<br>计算过程（用补码实现减法）：<br>减法 A - B 可通过 A + (−B) 完成，其中 −B 用 二进制补码 表示：求 B（111）的补码（即 -B）：按位取反：111 → 000<br>加 1：000 + 1 &#x3D; 001（-7 的补码）。计算 000 + 001 &#x3D; 001（直接相加，无进位,<strong>则Cout&#x3D;0</strong>）。</li></ul><p>关键点：补码减法的 Cout 需要额外判断。</p><h3 id="乘法运算电路中的控制逻辑"><a href="#乘法运算电路中的控制逻辑" class="headerlink" title="乘法运算电路中的控制逻辑"></a>乘法运算电路中的控制逻辑</h3><p><img src="/img/2025_6_9/002.png" alt="404"><br><img src="/img/2025_6_9/001.png" alt="404"></p><blockquote><p>注：第三步为判断<code>Y[0]=0</code>.</p></blockquote><h3 id="运算器的组成"><a href="#运算器的组成" class="headerlink" title="运算器的组成"></a>运算器的组成</h3><p>王道P206</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>圆通寺骑行</title>
      <link href="/2025/04/02/%E5%9C%86%E9%80%9A%E5%AF%BA%E9%AA%91%E8%A1%8C/"/>
      <url>/2025/04/02/%E5%9C%86%E9%80%9A%E5%AF%BA%E9%AA%91%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今日下午有政治理论课，再一个上午还得上数据挖掘的课。思来想去，这两个课都不能逃，依然放弃骑行青龙峡，但是骑车总是要骑的，决定三入圆通寺！</p><h3 id="挥不去的思念"><a href="#挥不去的思念" class="headerlink" title="挥不去的思念"></a>挥不去的思念</h3><p><img src="/img/2025_4_2/001.jpg" alt="404"></p><p>一定要抽时间再去一趟<strong>青龙峡</strong></p><h3 id="temple"><a href="#temple" class="headerlink" title="temple"></a>temple</h3><p><img src="/img/2025_4_2/002.jpg" alt="404"></p><p>Cycling is so much fun, I met an old man on the road and I asked him to take a picture for me, he agreed and I raised my bike. </p><p>It was very energetic</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p><img src="/img/2025_4_2/003.jpg" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 骑行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-排序</title>
      <link href="/2025/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="什么是排序"><a href="#什么是排序" class="headerlink" title="什么是排序"></a>什么是排序</h3><ol><li><p>输入<br>输入一段序列</p></li><li><p>输出<br>输出该序列的有序序列</p></li><li><p>算法的稳定性<br>对于A与B，其关键字相同，若排序后，A与B的相对位置仍不变，则称该算法是稳定的。</p></li><li><p>分类：根据<strong>元素是否完全存在于内存中</strong></p></li></ol><ul><li>内部排序：排序期间元素全部在内存中。</li><li>外部排序：排序期间元素<strong>无法全部同时</strong>存在于内存中。</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>将数据分为“有序部分、待确定元素、无需部分”，慢慢扩大有序部分，缩小无需部分，直至全部有序。</p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(ElemType a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">// a[0]为哨兵，不存储元素</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始的第一个元素可视为已排序好的元素</span></span><br><span class="line">    <span class="keyword">while</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            a[<span class="number">0</span>] = a[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;a[<span class="number">0</span>]&lt;a[j];j--)&#123;   <span class="comment">//此处的小于号是“稳定”的关键</span></span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            &#125;<span class="comment">//循环结束时，j停在小于哨兵的最近的元素上。但待插入的位置是哨兵的后一个位置，所以下面需要j++；</span></span><br><span class="line">            a[j+<span class="number">1</span>] = a[<span class="number">0</span>];      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ul><li>空间复杂度O(1)</li><li>比较次数和移动次数取决于排序表的初始状态。<em><strong>一种理解时间复杂度的方式</strong></em>最好O(n)，即执行n次if条件判断语句，不执行元素移动；最坏O(n^2)，即i&#x3D;2时，移动一次元素、i&#x3D;3时，移动两次元素······，即为1+2+···+(n-1)&#x3D;n*(n-1)&#x2F;2,赋值语句不计入比较。</li><li>时间复杂度O(n^2)</li><li>是稳定的算法</li><li>适用于顺序存储和链式存储的线性表，采用链式存储是无需移动元素</li><li>适用于基本有序的排序表或数据量不大的排序表</li></ul><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p>直接插入排序进行了：找到位置+移位操作 - - - 一边比较一边移动元素<br>折半插入排序：找到位置+移位操作 - - - 直接找到待插位置+将整体部分一个个移动</p><h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(ElemType a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i , j , high , mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = a[i];</span><br><span class="line">        low = <span class="number">1</span> ;</span><br><span class="line">        high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&gt;a[<span class="number">0</span>])&#123;</span><br><span class="line">                high = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low =mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//当二分查找结束时，low指向比待定元素刚刚大的，high指向比待定元素刚刚小的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)&#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[high+<span class="number">1</span>] = a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><ul><li>折半插入仅减小了比较的次数</li><li>仅适用于顺序表</li><li>稳定的</li></ul><h4 id="两种排序方法的比较"><a href="#两种排序方法的比较" class="headerlink" title="两种排序方法的比较"></a>两种排序方法的比较</h4><p><img src="/img/2025_3_25/001.png" alt="404"><br><img src="/img/2025_3_25/002.jpg" alt="404"></p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>mini版直接插入排序，因为直接插入排序当序列为排列好时，时间复杂度最小。顾希尔排序为了让其接近于有序。</p><p>过程：取一个小于n的增量d1，把表分为d1组（即这次有d1个下凹槽），对这d1组<strong>分别</strong>执行直接插入排序；接着取d2<code>&lt;</code>d1，直至dn &#x3D; 1 </p><h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><ul><li>不稳定</li><li>空间复杂度O(1)</li><li>O(n^1.3)，当n在某个范围内时（很难计算出1.3）；O(n^2),最坏。</li><li>适用于顺序表</li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>根据两个关键字的比较结果来交换这两个元素的位置</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(ElemType a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt; n<span class="number">-1</span>;i++)&#123;<span class="comment">//n个数只需要比较n-1次</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">                a[j<span class="number">-1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//j作为后操作数，与其前一个比较，所以第一次回到i（0）的前一个，即为小于号而非等于号，随着前面的逐渐确定，i的值逐渐增大。</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;     <span class="comment">//没有交换，证明某轮比较时该次以及后续已经有序。它的作用是 提前退出函数，但不会返回任何值。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h5><ul><li><img src="/img/2025_3_26/001.png" alt="404"></li><li>空间复杂度O(1)</li><li>只有小于时交换，因此这位稳定的算法</li><li>适用于顺序表与链表</li><li>不同于直接插入排序，冒泡排序产生的有序子序列是<strong>全局有序的</strong>。</li><li><img src="/img/2025_3_26/002.jpg" alt="404"></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*本算法为快排代码*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(ElemType a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;<span class="comment">//plow与phigh，当它们相等时，将pivot放进它们中的一个（哪一个都一样）</span></span><br><span class="line">        <span class="type">int</span> pivotpos = Partition(a,low,high)      <span class="comment">//注意这里的数组调用方式，pivotpos枢轴位置</span></span><br><span class="line">        QuickSort(a,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        QuickSort(a,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本算法为Partiton()*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ElemType a[],<span class="type">int</span> low ,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    ElemType pivot = a[low];        将当前表中的第一个元素设为枢轴，划分表</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high]&gt;=pivot)  --high;</span><br><span class="line">        a[low] = a[high];       <span class="comment">//将比枢轴小的元素移动到左边</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low]&lt;=pivot)  ++low;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;     <span class="comment">//返回枢轴最后存放的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h5><ul><li><img src="/img/2025_3_26/003.jpg" alt="404"></li><li><img src="/img/2025_3_26/004.jpg" alt="404"></li><li>仅适用于顺序表</li><li>不稳定</li><li>为什么说元素二等分时最快，有序时最慢：这些都在在pivot选择每份元素第一个值的条件下运作的。</li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(ElemType a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">        <span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">            <span class="type">int</span> temp = a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h5><ul><li>简单选择排序：设第一个元素为最小值，向后查找，若遇到比它小的元素，更新min值；最后交换这两个数。</li><li>空间复杂度O(1)</li><li>时间复杂度：比较次数：和初始排序的序列无关为<code>n*(n-1)/2</code>；操作次数最大<code>3*(n-1)</code>,最小0。时间复杂度始终是O(n^2)</li><li>不稳定，可由（2，2‘，1）验证</li><li>适用于顺序表与链表</li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul><li>大根堆：一棵完全二叉树，任何一个非叶节点大于等于左右孩子节点</li><li>小根堆：一棵完全二叉树，任何一个非叶节点小于等于左右孩子节点</li><li>思路：1-&gt;将一个无序序列构造为堆；2-&gt;当堆顶元素不在时，如何调整堆以便下一次删除堆顶元素</li></ul><h5 id="算法-6"><a href="#算法-6" class="headerlink" title="算法"></a>算法</h5><ol><li>性质：对于有n个节点的完全二叉树，它层次遍历的最后一个节点，就是<code>n/2向下取整</code>的孩子</li><li>建立堆的思想：遍历<code>n/2向下取整#到#1</code>，设其为k，若k小于左右孩子中的较大者，则让他们交换。这个过程可能会破坏下一级的堆，需重新构造。</li><li>建立大根堆</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(ElemType a[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;<span class="comment">//   i的取值范围是1~len/2</span></span><br><span class="line">        HeadAdjust(a,i,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(ElemType a[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = a[k];        <span class="comment">//a[0]暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//i的初值为k的左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; a[i]&lt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="comment">//获取较大元素</span></span><br><span class="line">        <span class="comment">//这里很重要，获取较大的元素并且移动较大的元素后，再对以该较大元素为根的子树进行调整，并且不需要调整已经调整好的以较小的元素为根的子树。整个调整过程遵循：从下到上，从左到右。</span></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; a[i])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[k] = a[i];<span class="comment">//用孩子填补父节点</span></span><br><span class="line">            k = i;      <span class="comment">//修改k值，以便继续向下筛选！！！</span></span><br><span class="line">            <span class="comment">//这很重要，例如对于一棵节点数为8的树，k为4，修剪一颗子树，k为3，修剪一棵子树，k为2，修剪两棵子树，k为1，修剪三棵子树。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[k] = a[<span class="number">0</span>];        <span class="comment">//用父节点填补孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>堆排序算法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(ElemType a[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(a,len);    <span class="comment">// Initial reactor construction，初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//n-1趟交换、建堆过程</span></span><br><span class="line">        Swap(a[i],a[<span class="number">1</span>]);    <span class="comment">//堆底元素和堆顶元素交换</span></span><br><span class="line">        HeadAdjust(a,<span class="number">1</span>,i<span class="number">-1</span>);        <span class="comment">//重新调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h5><ul><li><img src="/img/2025_3_26/005.jpg" alt="404"></li><li>根据算法可得，关键字的总比较次数不超过<code>4*n</code>。即总调整次数*每次调整所需要比较4次。</li><li>空间复杂度：O(1)</li><li>不稳定</li><li>适用于顺序表</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法-7"><a href="#算法-7" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：将前后相邻的有序表归并成一个新的有序表</span></span><br><span class="line"><span class="comment">过程：先将a中元素复制到b，再将b中的元素有序的复制到a*/</span></span><br><span class="line">ElemType *b = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * (n+<span class="number">1</span>));</span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> mid, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = low ;k &lt;= high ;k++)&#123;</span><br><span class="line">        b[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span> , j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = low , j = mid+<span class="number">1</span> , k = i;I&lt;=mid &amp;&amp; j &lt;=high;k++)&#123;<span class="comment">//注意这里k的变化</span></span><br><span class="line">        <span class="keyword">if</span>(b[i] &lt;= b[j])&#123;</span><br><span class="line">            a[k] = b[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            a[k] = b[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        a[k++] = b[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)&#123;</span><br><span class="line">        a[k++] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：合并</span></span><br><span class="line"><span class="comment">算法思想：分冶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(ElemType a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (low+high)/<span class="number">2</span>; <span class="comment">//从中间划分为两个子序列</span></span><br><span class="line">        MergeSort(a,low,mid);   <span class="comment">//对左边的序列递归排序</span></span><br><span class="line">        MergeSort(a,mid+<span class="number">1</span>,high);    <span class="comment">//对右边的序列递归排序</span></span><br><span class="line">        Merge(a,low,mid,high);      <span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><ul><li>归并：将两个或者两个以上的有序表合并成为新的有序表</li><li>二路归并排序：将有n个元素的表视为n个长度为1的表，两两合一，成为n&#x2F;2（向上取整）个长度为1或者2的<del>部分</del>有序表；继续两两归并，直至成为一个长度为n的有序表。</li><li>空间复杂度：O(n),对辅助数组的重复利用</li><li>时间复杂度：<em>可参考建堆时间复杂度</em>，为<code>O(n)*⌈log2n⌉ = O(n*log2n)</code></li><li>稳定</li><li>使用于顺序表与链表</li><li>对于k路归并排序，所需要的趟数为<code>⌈logkn⌉</code></li><li>**注意：**归并本身并不涉及排序，只是合并已排序的有序段</li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="算法-8"><a href="#算法-8" class="headerlink" title="算法"></a>算法</h4><p>略</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><ul><li>不基于比较与移动</li><li>基数（Radix）（r）指的是数字或字符的进制基数，数字为十进制，基数为10</li><li><img src="/img/2025_3_30/001.png" alt="404"></li><li><img src="/img/2025_3_30/002.png" alt="404"></li><li><img src="/img/2025_3_30/003.png" alt="404"></li><li><img src="/img/2025_3_30/004.png" alt="404"></li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h4 id="算法-9"><a href="#算法-9" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CountSort</span><span class="params">(ElemType a[],ElemType b[],<span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="comment">//a存放初始序列，b存放排好序的序列</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,c[k];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; n;i++)&#123;</span><br><span class="line">        c[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span> ;i &lt; k;i++)&#123;</span><br><span class="line">        c[i] = c[i] + c[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        b[c[a[i]] - <span class="number">1</span>] = a[i];<span class="comment">//为什么要减一，大于等于a[i]的有c[a[i]]个元素，个数减一才是位数</span></span><br><span class="line">        c[a[i]] = c[a[i]] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><ul><li><img src="/img/2025_3_30/005.png" alt="404"></li><li>注意：<img src="/img/2025_3_30/006.png" alt="404"></li><li>k &#x3D; O(n) 表示数据范围 k 和元素数量 n 同数量级（即 k 不超过 n 的常数倍）。</li><li>k &gt; O(nlog₂n)可以表示：k 的增长速度快于 nlog₂n</li></ul><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><h4 id="外部排序的方法"><a href="#外部排序的方法" class="headerlink" title="外部排序的方法"></a>外部排序的方法</h4><ul><li>怎么排序：采用归并排序-&gt;1. 将外存中的文件分为l份，依次读入内存，依次使用内排排序，再写入外存 2. 对这些归并段归并</li><li>详细介绍：<img src="/img/2025_3_30/007.png" alt="404"></li><li>输入、输出缓冲区：<img src="/img/2025_3_30/008.png" alt="404"></li></ul><h3 id="多路平衡归并与败者树"><a href="#多路平衡归并与败者树" class="headerlink" title="多路平衡归并与败者树"></a>多路平衡归并与败者树</h3><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><ul><li><img src="/img/2025_3_30/009.png" alt="404"></li><li><img src="/img/2025_3_30/010.png" alt="404"></li><li><img src="/img/2025_3_30/011.png" alt="404"></li></ul><h3 id="置换、选择排序"><a href="#置换、选择排序" class="headerlink" title="置换、选择排序"></a>置换、选择排序</h3><h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><img src="/img/2025_3_28/001.png" alt="404"><br>这道题可以使用冒泡排序的思想，但时间复杂度会达到O(n^2)。接下来使用一种基于快排思想的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span> , j = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; [i]%<span class="number">2</span> != <span class="number">0</span>)&#123;i++&#125;;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; [j]%<span class="number">2</span> == <span class="number">0</span>)&#123;j--&#125;;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="type">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度为O(1)</span></span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p><img src="/img/2025_3_28/002.png" alt="404"><br>很容易想到先排序后定位，但这样时间O(n*logn)是最小的。<br>接下来介绍平均时间复杂度为O(n)的算法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  a[1···n]</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kth_elem</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = a[low];</span><br><span class="line">    <span class="type">int</span> low_temp = low;</span><br><span class="line">    <span class="type">int</span> high_temp = high;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high]&gt;pivot)&#123;high--;&#125;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt; pivot)&#123;low++;&#125;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line">    a[low] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////--//</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rank = low -low_temp+<span class="number">1</span>;<span class="comment">//计算当前pivot是第几小的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rank == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[low];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rank &gt; k)&#123;</span><br><span class="line">        kth_elem(a,low_temp,low<span class="number">-1</span>,k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        kth_elem(a,low+<span class="number">1</span>,high_temp,k-rank);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>就金秀贤事件表达自己的看法</title>
      <link href="/2025/03/23/%E5%B0%B1%E9%87%91%E7%A7%80%E8%B4%A4%E4%BA%8B%E4%BB%B6%E8%A1%A8%E8%BE%BE%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9C%8B%E6%B3%95/"/>
      <url>/2025/03/23/%E5%B0%B1%E9%87%91%E7%A7%80%E8%B4%A4%E4%BA%8B%E4%BB%B6%E8%A1%A8%E8%BE%BE%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9C%8B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="为什么要写这篇文章？"><a href="#为什么要写这篇文章？" class="headerlink" title="为什么要写这篇文章？"></a>为什么要写这篇文章？</h3><p>或许大家对《来自星星的你》这部电视剧有或多或少的了解，我曾在之前的博客中高度评价这部剧- - - 塑造了都敏俊与千颂伊跨越时空的恋情，显得纯真而美好。但现在金秀贤的“私生活丑闻”被公之于众，与其公众形象形成了巨大反差，我觉得有必要探讨“韩国、演艺与性”。</p><h3 id="艺人与其饰演的角色"><a href="#艺人与其饰演的角色" class="headerlink" title="艺人与其饰演的角色"></a>艺人与其饰演的角色</h3><p>我并不和有些人一样，觉得某个演员演技高超，便热烈地追求某个演员，就像金秀贤饰演的都敏俊一样，我并不喜欢金秀贤，而是彻头彻尾的都敏俊与千颂伊。这可以由以下几方面来理解：</p><ol><li>理想与现实的落差：</li></ol><p>电视剧是一种艺术，艺术来源于生活，但却又高于生活，就如同海市蜃楼一样，令沙漠中饥渴交迫的信徒癫狂，闷着头向前，到头来发现只不过是梦幻一场。将电视剧与现实情节高度重合是不切实际的，不妨将两者定义为弱耦合关系。电视剧中的各种片段都有着特定的背景与完美的偶然性。就都敏俊与千颂伊的会面而言，已经称得上极小概率事件了，同时两人又是邻居，为本就巧合的事件添砖加瓦，再到后来千颂伊作为都敏俊的学生，误打误撞又让成为了她的经纪人······若有人在这部电视剧播出前给你讲这些情节，我想你会认为：这人是不是脑子受过伤？确实如此，我想绝大多数人会有这样的想法，而这样的想法恰恰是大众级的、普遍的想法，那么一些经纪公司为了流量必须逆大众化，编出如此浮夸的剧本上映于大荧幕，博得观众的眼球、疯狂地吞吐流量。这学期在上《毛概》（肯定没有这个名字的树，这里简写）时，毛泽东指出：<strong>新民主主义的文化是大众的</strong>，即此，禁得起大众考验的文化作品方得流传千古。</p><p>显然，逆大众化不等于大众化，进而引出理想与现实。理想中的演员饰演的角色是完璧无暇的、是光鲜亮丽的、是沁人心脾的。但现实中的这个人会是如何呢？若是将其与现实中的这个人建立一一映射关系，那这种未经考察与检验的行为绝非智慧的行为。</p><ol start="2"><li>标签的光鲜掩盖不住内在的乌烟瘴气</li></ol><p>演员演员，重在“演”字。演员饰演的角色再极致，那终究是演的，与其本人品质无任何关系。艺人们顶着流量的光环，却不下功夫练艺修德，尝到一点甜头后，便在虚拟的剧本中迷失了人生的方向，弄得世人啼笑皆非，背负着千古的骂名。孔子在《周易·系辞下》中警示道：“德不配位，必有灾殃。”。从之前“范冰冰阴阳合同”，到“郑爽代孕”，前有“罗志祥多人运动”，后有“吴亦凡强奸少女”。艺人们在道德的路途上越走越远，渐渐地丢掉了自己的初心，跌入了资本的怪圈，“套路比思想更深，五官比三观更正”实则为大部分艺人们的真实写照。</p><p>以“偶像练习生”为代表的青年男性，不追求斯巴达类的健壮与威猛，反而向往阴柔与娇嫩，真是让我恶心。如果中国不限制的发展这种邪风，很有可能重蹈韩国的路。</p><p>提到韩国，不免想到“性，巫术，政治傀儡”。在这里列举几条数据：</p><ul><li><a href="https://news.qq.com/rain/a/20250114A03HIG00">吸毒人数超40万，18岁高中生成贩毒头目：韩国正在成为“亚洲毒王”</a></li><li><a href="https://zhuanlan.zhihu.com/p/434735781">韩国为何会成为世界第一情色大国？十几年扫黄为何越扫越黄？</a></li><li><a href="https://www.news.cn/globe/20250121/e3b85d8bb78f484aac3ac5820ad1ce7c/c.html">前所未有困局中的韩国政坛</a></li><li><a href="https://news.qq.com/rain/a/20250315A03HIY00">20万个体户消失，数据比1997年更惨，韩国经济正在塌陷？</a></li><li><a href="https://www.huxiu.com/article/4108048.html">韩国总统，靠“巫术”治国？</a></li><li><a href="https://news.qq.com/rain/a/20241226A08PK300">青瓦台魔咒真的存在吗？韩国12位历任总统，11人没有好下场</a></li></ul><p>作为美国的一枚政治棋子，韩国人永远生活在政治囚笼里，被美国玩弄于股掌之间，在大国的汹涌浪潮里随波逐流，一遍遍地书写着历史的悲剧。为了遏制韩国的发展，美国暗中大肆推行“娘炮文化”，以致整个社会风气成为“当明星的赚钱的不二法则”，年轻人们不考虑如何富国强国而是怎么搔首弄姿，博眼球，赚流量。可谓“商女不知亡国恨，隔江犹唱后庭花”。</p><ol start="3"><li>社会价值</li></ol><p>推动社会发展是检验文化作品的标准之一。为什么《西游记》经久不衰；《亮剑》至今被人津津乐道；《末代皇帝》历久弥新。其背后无疑有着坚实的文化底蕴作为支撑，这些作品不仅具有艺术价值，而且深刻反映了社会现实、历史背景和人性思考，从而超越了时代和地域的限制，成为经典。</p><p>没有文化作为支撑的作品，再好也只是昙花一现，经不起推敲。</p><h3 id="金秀贤性丑闻"><a href="#金秀贤性丑闻" class="headerlink" title="金秀贤性丑闻"></a>金秀贤性丑闻</h3><ol><li>序号“1”的内容节选自网络：</li></ol><p>1 命运转折点（15岁）</p><p>我叫金赛纶，是一名演员。</p><p>我站在红毯上，闪光灯刺得我眼睛生疼。</p><p>耳边是此起彼伏的呼喊声：“赛纶！看这里！”“玻璃蝴蝶！笑一个！”玻璃蝴蝶——这是媒体给我起的绰号。</p><p>他们说我是透明的、脆弱的，像一只在阳光下闪烁的蝴蝶，美丽却易碎。</p><p>可他们不知道，这只蝴蝶早已被资本的手捏住了翅膀，无法挣脱。那年我十五岁，刚刚签约了金秀贤的经纪公司。</p><p>他是我的前辈，也是我的恋人——至少在那时，我是这么认为的。他二十七岁，成熟、温柔，像一座灯塔，照亮了我迷茫的青春。</p><p>我以为他是我的救赎，却没想到，他是我命运的转折点。</p><p>我记得他第一次牵起我的手时，轻声说：“赛纶，你是我见过最特别的女孩。”</p><p>他的眼神温柔得让我沉溺，可后来我才明白，那温柔背后藏着的是掌控与欲望。</p><p>2014年，他在一次采访中说：“我41岁时，会娶一个21岁的新娘</p><p>”当时我还在为他辩护，说这只是玩笑话。</p><p>可如今回想起来，那句话像一根刺，深深地扎进了我的心里。</p><p>2 控制与崩塌（2022年酒驾事件）2022年，我的世界彻底崩塌了。</p><p>那天晚上，公司的高层逼我参加一场酒局。他们说这是“必要的社交”，可我知道，这不过是资本的陷阱。</p><p>我被灌了一杯又一杯的酒，直到意识模糊。我开始有些慌张了，中途慌忙开车离开，但我已经分不清方向了。事故发生后，因为心里的害怕，我选择了逃逸。那一刻，我的脑子里一片空白，只剩下恐惧。</p><p>第二天，新闻铺天盖地地报道：“童星金赛纶酒驾逃逸！”我的名字被钉在了耻辱柱上，而公司却“慷慨”地替我支付了7亿韩元的赔偿金。可这所谓的“慷慨”背后，是一纸债务合同。我签下了自己的名字，却不知道，那是我终身的枷锁。</p><p>我的事业彻底毁了。《猎人们》的剧组宣布换角，金秀贤经济公司说因为我的抑郁发作取消拍摄。我躲在房间里，不敢开灯，不敢看手机。我的手腕上多了几道伤痕，创可贴成了我唯一的遮掩。可那些伤痕，不仅仅是皮肤上的，更是心里的。</p><p>3 生存挣扎（2023-2024年）2023年，我开始了咖啡店的兼职工作。</p><p>我以为这是新的开始，可现实却狠狠地扇了我一耳光。有一天，一位顾客认出了我，偷偷拍下我的照片发到了网上。</p><p>标题是：“曾经的玻璃蝴蝶，如今沦为咖啡店服务员。”评论区里满是嘲笑和讽刺。我低头看着自己的银行账户，里面只剩下327万韩元。那一刻，我感到前所未有的绝望。深夜，我常常躲在楼梯间里哭泣。手腕上的伤痕隐隐作痛，创可贴已经换了一张又一张。我知道，那些伤痕不仅仅是疼痛的象征，更是我对生活的无力反抗。我试图站起来，可每一次都被现实狠狠地按回原地。</p><p>2024年，我收到了金秀贤公司三大律师联名发来的催债函。那封信像一把刀，狠狠地刺进了我的心脏。而与此同时，新闻里却在报道金秀贤购置了300亿韩元的豪宅。我看着电视屏幕，眼泪无声地滑落。曾经的温柔与承诺，如今看来不过是一场笑话。</p><p>4 绝望反击（2024年3月）2024年3月，我终于决定反击。那天深夜，我颤抖着手指，在社交平台上发布了一张与金秀贤的贴脸合照。照片里的我笑得天真无邪，而他则是一如既往的温柔。</p><p>我配文：“谢谢你，让我学会了什么是爱。”点击发送的那一刻，我的心脏几乎要跳出胸腔。我已经选择了那么多张亲密照中伤害最小的照片，可笑竟然到这个时候还在照顾他的体面。仅仅几秒后，我删除了那条动态。可已经来不及了。截图像病毒一样在网络上蔓延，舆论瞬间爆炸。公司立刻发表声明，称那张照片是“恶意合成”，并指责我“精神不稳定，试图抹黑前辈”。我看着那条声明，眼泪模糊了视线。他们甚至连一句解释的机会都不肯给我。</p><p>我打开手机，翻出与金秀贤的短信记录。那些卑微的哀求像一把刀，一次次割开我的自尊：“求求你，让我喘口气。”“我真的撑不下去了。”“你能不能……帮帮我？”可他的回复永远是冷漠的：“别闹了。”“公司会处理。”“你自己惹的祸，自己承担。”</p><p>5 死亡仪式（2025年2月16日）2025年2月16日，我选择了离开。这一天是他的生日，我刻意选在这一天，想让我的死亡成为他永远的阴影。我在房间里点燃了一支蜡烛，火光摇曳，映照着我苍白的面容。我的骨灰将与这支蜡烛的灰烬重叠，成为我最后的控诉。我的遗物里，藏着一张《吉他手》的通告单。那是我曾经最期待的作品，可如今上面写满了“对不起”。</p><p>对不起父母，对不起粉丝，对不起那个曾经满怀梦想的自己。我的手机里还有一个加密相册，里面是我们曾经的合影。其中一张，我穿着浴袍，依偎在他怀里，笑得像个孩子。可那笑容背后，是无尽的痛苦与挣扎。我的家人决定追诉他未成年性侵的罪名。律师告诉我，追诉期将从我成年那天开始计算。可我知道，即使法律能还我一个公道，我也再也回不来了。</p><p>6 社会镜像（终章）网友们后知后觉，他们在社交平台上发起联名请愿，要求封杀金秀贤。他的粉丝数持续下跌，可我知道，这一切并不会真正改变什么。资本依然强大，权力性剥削依然普遍，童星保护制度依然缺失。我的死亡，成了这个社会的镜像。它映照出娱乐圈的黑暗，映照出权力的丑陋，也映照出人性的冷漠。可最终，这一切都会被遗忘。新的“玻璃蝴蝶”会诞生，新的悲剧会重演。而我，不过是这场无尽循环中的一个注脚。</p><ol start="2"><li>面临着什么</li></ol><p>韩国《刑法》规定，与13周岁-16周岁的未成年人发生性关系或对其实施不雅行为的已满19周岁的人，应受到强奸罪、准强奸罪、强迫性侵害的处罚。因此，若金赛纶家属曝光情况属实，且金秀贤与金赛纶交往后满16周岁前发生性关系，他可能面临刑事犯罪指控。</p><ol start="3"><li>我的评论</li></ol><p>跟未成年女人发生关系，还算个男人吗？不敢直面成年女性转而对未成年人下手的样子真是丑陋呀！《毛概》课上，老师说，韩国的女性很惨，现在看来的确如此，迷奸、轮奸、性招待，被美国大兵强奸，被国内男人PUA，韩国N号房丑闻：一场26万人参与的集体“性侵”；整容、隆胸、丰臀体，对母亲给与的身体嗤之以鼻只为迎合财阀的癖好，没有长得最漂亮的女人，只有更漂亮的女人；陪酒、陪玩、陪睡觉，付出所有的所有只为在畸形的政治制度下赚取微薄的收入以仅仅维持自己的生存。</p><p>当大学沦为男人的妓院，当红灯区变得司空见惯，当一切的一切都显得那么合理的时候，那将如同岸边的海水慢慢退潮，准备迎接滔天海啸的来临。</p><p>玩弄一个个女人，到底多有意思，让某些人乐此不疲。韩国现在已经这样了，同时也就这样了。</p><p>连总统夫人都是陪酒女，靠身体上位，哎，真是开了眼了。天才在左，疯子在南韩。</p><h3 id="我的感想"><a href="#我的感想" class="headerlink" title="我的感想"></a>我的感想</h3><p>生而为人，人一辈子追求的是什么，是性吗？？？我想，如果我到了老年，若因和多少女人发生关系而沾沾自喜，那可就糟糕透了！</p><p>俞敏洪说：“大学四年是一个人的思维、思考能力、看问题的角度、价值观、哲学态度能够被影响和改变的时间段。”。我觉得自己现在仍然在边缘行走，希望自己能够养成正确的价值观，做一个不老实的老实人。</p><p>善恶只在一念之间，凡事三思而后行。“一念天堂，一念地狱，”，心有向善，则有天堂；心有恶念，则坠地狱。多存善念，少生恶意，心怀宽阔，心有约束。</p><p>人在花丛，自有百媚千红的诱惑;人在水岸，自有千帆阅尽的了然。若心有琴弦，自有心歌放飞;心有明媚，自有花儿摇曳。</p><p>说了这么多牛皮的话，但当真正的诱惑来临时，我也不知道自己会怎么判断。但有一点我十分确信：我的定力会比别人大些。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p><img src="/img/2025_3_23/001.jpg" alt="404"></p><p>举头三尺有神明，不畏人知畏己知。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 深度议论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>毛概知识点整理</title>
      <link href="/2025/03/21/%E6%AF%9B%E6%A6%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2025/03/21/%E6%AF%9B%E6%A6%82%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="III-社会主义改造理论"><a href="#III-社会主义改造理论" class="headerlink" title="III.社会主义改造理论"></a>III.社会主义改造理论</h2><h3 id="从新民主主义到社会主义的转变"><a href="#从新民主主义到社会主义的转变" class="headerlink" title="从新民主主义到社会主义的转变"></a>从新民主主义到社会主义的转变</h3><h4 id="新民主主义是一个过渡性的社会"><a href="#新民主主义是一个过渡性的社会" class="headerlink" title="新民主主义是一个过渡性的社会"></a>新民主主义是一个过渡性的社会</h4><ol><li>新民主主义社会不是一个独立的社会形态，而是由新民主主义向社会主义转变的过渡性社会形态。</li><li>新民主主义社会中存在5种经济成分：</li></ol><ul><li>社会主义性质的国营经济</li><li>半社会主义性质的合作社经济：忙时合作、闲时自顾自</li><li>农民和手工业者的个体经济</li><li>私人资本主义经济</li><li>国家资本主义经济：国家有一定的控制权</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毛概 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-查找</title>
      <link href="/2025/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"/>
      <url>/2025/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="顺序查找和折半查找"><a href="#顺序查找和折半查找" class="headerlink" title="顺序查找和折半查找"></a>顺序查找和折半查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><ol><li>可分为<strong>一般线性表的顺序查找</strong>和<strong>按关键字的有序线性表的查找</strong></li><li>适用于顺序表与链表。遍历方式为下标与next指针。</li></ol><h5 id="一般线性表的顺序查找"><a href="#一般线性表的顺序查找" class="headerlink" title="一般线性表的顺序查找"></a>一般线性表的顺序查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SeqList L,ElemType key)</span>&#123;</span><br><span class="line">    L.data[<span class="number">0</span>] = key;        <span class="comment">//sentry</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="type">int</span> i = L.length;L.data[i] != key;--i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义length为5，数组下标1-5为存储data单元，0作为哨兵（本题中）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码引入了“哨兵”，用于<strong>避免不必要的判断语句</strong>。就其而言，不用些越界判断条件<code>i&gt;=0</code>了</p></blockquote><p>那么能不能在链式存储结构中使用哨兵呢？看看下面这个代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元素类型和链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">// 假设元素类型为 int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data;          <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>     <span class="comment">// 指针域</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序查找函数（带哨兵）</span></span><br><span class="line">LNode* <span class="title function_">seq_search_with_sentinel</span><span class="params">(LinkList L, ElemType key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 链表为空，直接返回 NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建哨兵节点，并将其值设置为 key</span></span><br><span class="line">    LNode sentinel;</span><br><span class="line">    sentinel.data = key;</span><br><span class="line">    sentinel.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将哨兵节点添加到链表的末尾</span></span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// 指向首元节点</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = &amp;sentinel; <span class="comment">// 将哨兵节点链接到链表末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找过程</span></span><br><span class="line">    LNode *p_find = L-&gt;next; <span class="comment">// 从头节点的下一个节点开始查找</span></span><br><span class="line">    <span class="keyword">while</span> (p_find-&gt;data != key) &#123;</span><br><span class="line">        p_find = p_find-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复链表结构，移除哨兵节点</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否找到目标节点</span></span><br><span class="line">    <span class="keyword">if</span> (p_find != &amp;sentinel) &#123;</span><br><span class="line">        <span class="keyword">return</span> p_find; <span class="comment">// 找到目标节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 未找到目标节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链表（头插法）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_list</span><span class="params">(LinkList L, ElemType arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 初始化头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        LNode *new_node = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        new_node-&gt;data = arr[i];</span><br><span class="line">        new_node-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_list</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    LinkList L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 创建头节点</span></span><br><span class="line">    ElemType arr[] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    create_list(L, arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表内容: &quot;</span>);</span><br><span class="line">    print_list(L);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找测试</span></span><br><span class="line">    ElemType key = <span class="number">5</span>;</span><br><span class="line">    LNode *result = seq_search_with_sentinel(L, key);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到元素: %d\n&quot;</span>, result-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到元素: %d\n&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放链表内存</span></span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LNode *temp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结合“将哨兵节点添加到链表的末尾”，说明需要遍历两次链表，虽然时间复杂度仍是O(n)，但意义并不大。</p></blockquote><p>总结：</p><ol><li>ASL_S&#x3D;(n+1)&#x2F;2    ASL_F&#x3D;n+1:(比较次数)</li><li>缺点，n较大时效率低</li></ol><h5 id="有序线性表的顺序查找"><a href="#有序线性表的顺序查找" class="headerlink" title="有序线性表的顺序查找"></a>有序线性表的顺序查找</h5><ol><li>不成功时的ASL<br><img src="/img/2025_3_18/001.png" alt="404"></li></ol><h4 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SeqList L,ElemType key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = L-&gt;length<span class="number">-1</span>;mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="comment">//注意这里为什么是等于，因为low与high始终在闭区间内运算，当low=high时，仍有一个值没有运算。</span></span><br><span class="line">        mid = low +(high-low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.data[mid] &gt; L.data[key])&#123;</span><br><span class="line">            high = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(L.data[mid] &lt; L.data[key])&#123;</span><br><span class="line">            low = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>需求有序排列</li><li>仅适用于有序线性表（可以随机定位），不适合链式存储。<br><img src="/img/2025_3_18/002.png" alt="404"></li><li>时间复杂度为O(logn)，可以理解为每次排除一半的元素。</li></ol><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><ol><li>先将整个表分块（称为<strong>索引表</strong>），每个块中的元素不大于下一个块中的最小元素；再将索引表中的元素分为<strong>查找表</strong>。即这个过程有两个表。</li><li>ASL &#x3D; ASL(索引表) + ASL(查找表)</li></ol><ul><li>若它们均采用顺序查找（总表长度为n,索引表被分为b块，查找表被分为s块）。ASL &#x3D; (b+1)&#x2F;2 + (s+1)&#x2F;2，这里有n&#x3D;sb。</li></ul><h3 id="树形查找"><a href="#树形查找" class="headerlink" title="树形查找"></a>树形查找</h3><h4 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h4><h5 id="说明与定义"><a href="#说明与定义" class="headerlink" title="说明与定义"></a>说明与定义</h5><ol><li>构造二叉排序树不是为了排序，而是为了加快插入与删除</li><li>二叉排序树为递归定义：左子树结点值 &lt; 根节点值 &lt; 右子树结点值。因此中序遍历会得到递增的序列</li></ol><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BiTree T , ElemType key)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; T-&gt;data != key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;data &lt; key)&#123;</span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;       <span class="comment">//查找不到会返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">BSTNode* <span class="title function_">BST_Search</span><span class="params">(BiTree T, ElemType key)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归基（终止条件）：如果当前节点为空或节点的值等于key，返回当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span> || T-&gt;data == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用：根据key的大小决定向左子树还是右子树查找</span></span><br><span class="line">    <span class="keyword">if</span> (T-&gt;data &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Search(T-&gt;rchild, key);  <span class="comment">// 查找右子树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Search(T-&gt;lchild, key);  <span class="comment">// 查找左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BST_Insert</span><span class="params">(BiTree T,ElemType k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree));</span><br><span class="line">        T-&gt;data = k;</span><br><span class="line">        T-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;      <span class="comment">//faild</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data &gt; k)&#123;</span><br><span class="line">        <span class="comment">//BST_Insert(T-&gt;lchild,k);          注意加上return，逐层返回</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data &lt; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BST_Create</span><span class="params">(BiTree* T,ElemType str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        BST_Init(T,str[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li>二叉排序树的删除</li><li></li></ul><p><img src="/img/2025_3_18/003.png" alt="404"></p><ul><li>删除再插入结点，可能与原来的树不同</li></ul><h5 id="查找效率的分析"><a href="#查找效率的分析" class="headerlink" title="查找效率的分析"></a>查找效率的分析</h5><p>主要取决于树的高度。若左右子树的高度之差的绝对值不超过1（平衡二叉树），它的平均查找长度为O(logN)；若是只有一根分支的单支树，则为O(N)</p><h5 id="比较二分查找与二叉排序树"><a href="#比较二分查找与二叉排序树" class="headerlink" title="比较二分查找与二叉排序树"></a>比较二分查找与二叉排序树</h5><p><img src="/img/2025_3_18/004.png" alt="404"></p><h4 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h4><p>避免二叉树高度增长太快，降低二叉排序树的性能，引入了平衡二叉树。平衡二叉树要求左右子树的高度差（平衡）的绝对值不大于1，即只能是-1、0、1</p><h5 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h5><p>若插入一个结点导致了AVL的不平衡，则找到离插入结点最近的非法平衡因子结点，对以其为根的子树，旋转，手动调整其为平衡。（不计结论手动尝试也行）。</p><p>平衡二叉树的插入即构造过程。</p><h5 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h5><p>平衡二叉树的删除即：回溯到到被删除的结点的路径上的离该结点最近的不平衡的结点，如果调整后子树高度减一，可能需要对该结点的祖先调整平衡。</p><h5 id="平衡二叉树的查找"><a href="#平衡二叉树的查找" class="headerlink" title="平衡二叉树的查找"></a>平衡二叉树的查找</h5><p><img src="/img/2025_3_18/005.png" alt="404"><br><img src="/img/2025_3_18/006.png" alt="404"></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>在更新结点时，会频繁调整AVL的全局拓扑结构，花费代价大。适当的放款条件，便引入了红黑树。</p><p>性质：</p><ul><li>只有红节点与黑结点</li><li>根节点为黑节点</li><li>叶节点、NULL、虚构结点都是黑色的</li><li>红节点不能相邻</li><li>任何一个节点到相同的任何一个叶节点的路径上经过的黑节点数量相同</li></ul><h3 id="B数和B-树"><a href="#B数和B-树" class="headerlink" title="B数和B+树"></a>B数和B+树</h3><h4 id="B树及其基本操作"><a href="#B树及其基本操作" class="headerlink" title="B树及其基本操作"></a>B树及其基本操作</h4><p>m阶B树：平衡因子均为0的m路平衡查找树，或为NULL树，或满足以下性质</p><ul><li>每个节点最多有m棵子树，即最多有m-1个关键字</li><li>若根节点不是叶节点，则至少有2棵子树，即1个关键字</li><li>除了根节点外的<strong>非叶子节点</strong>，至少有⌈m&#x2F;2⌉棵子树，即至少⌈m&#x2F;2⌉-1个关键字（当m&#x3D;&#x3D;5，⌈5&#x2F;2⌉&#x3D;&#x3D;⌈2.5⌉&#x3D;&#x3D;3）</li><li>非叶节点的结构如下：<code>P0 K0 P1 K1 P2</code>，P为指向子树根节点的指针，K为关键字（递增排序）</li><li>叶节点（这里指的是<strong>失败节点</strong>）出现在同一层次上</li></ul><h5 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h5><p>查找到关键字–成功；查找到叶节点（指针为空）–查找失败</p><h5 id="高度（不包括不带信息的那层）"><a href="#高度（不包括不带信息的那层）" class="headerlink" title="高度（不包括不带信息的那层）"></a>高度（不包括不带信息的那层）</h5><p>设n为关键字，h为高度，m为阶数</p><ol><li>n &lt;&#x3D; (m-1)*(1 + m + m^2 + ··· +m^(h-1)) &#x3D; m^h -1<br>即：    h &gt;&#x3D; logm(n+1)</li></ol><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ol><li>哈希函数</li></ol><p>将查找表中的<strong>关键字</strong>映射成<strong>该关键字对应的地址</strong>，Hash(Key) &#x3D; Address</p><ol start="2"><li>冲突</li></ol><p>把两个或者两个以上的不同的关键字映射到同一地址。冲突难以避免，要设计好处理冲突的方法。</p><ol start="3"><li>哈希表</li></ol><p>根据关键字直接访问的数据结构。理想情况下的哈希表查找时间复杂度与元素个数无关，为O(1)</p><ol start="4"><li>同义词</li></ol><p>发生冲突的不同关键字</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI入门</title>
      <link href="/2025/03/12/AI%E5%85%A5%E9%97%A8/"/>
      <url>/2025/03/12/AI%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>笔者在阅读<strong>全球掀起DeepSeek复现狂潮，一文汇总！</strong> 的时候，对其中的众多概念表示无法理解。转念一想，不妨做一篇博客，收录核心的<strong>有关AI的词汇</strong>。</p><h3 id="人工智能（AI）"><a href="#人工智能（AI）" class="headerlink" title="人工智能（AI）"></a>人工智能（AI）</h3><p>人工智能是让机器<strong>模拟人类智能行为</strong>的科学与技术。它涵盖多个领域，如机器学习、深度学习、自然语言处理（NLP）、计算机视觉等。</p><h3 id="生成式AI"><a href="#生成式AI" class="headerlink" title="生成式AI"></a>生成式AI</h3><p>生成式AI是AI的一个分支，专注于生成新内容（如文本、图像、音频、视频）。它的核心是学习数据的分布，并从中生成类似的新数据。</p><blockquote><p>例子：ChatGPT（生成文本）、DALL·E（生成图像）、Stable Diffusion（生成图像）。</p></blockquote><h3 id="预训练（Pre-training）"><a href="#预训练（Pre-training）" class="headerlink" title="预训练（Pre-training）"></a>预训练（Pre-training）</h3><p>它通过在大规模数据集上训练模型，使其学习通用的语言或视觉特征，然后再针对特定任务进行微调。</p><h3 id="微调（Fine-tuning）"><a href="#微调（Fine-tuning）" class="headerlink" title="微调（Fine-tuning）"></a>微调（Fine-tuning）</h3><p>微调是在预训练模型的基础上，用特定任务的数据进一步训练模型，使其适应具体任务。</p><h3 id="蒸馏（Distillation）"><a href="#蒸馏（Distillation）" class="headerlink" title="蒸馏（Distillation）"></a>蒸馏（Distillation）</h3><p>蒸馏是一种模型压缩技术，目的是将大型模型（教师模型）的知识转移到小型模型（学生模型）中，使小模型在保持高性能的同时减少计算资源需求。</p><ul><li>过程：</li></ul><ol><li>训练一个大型、高性能的教师模型。</li><li>让教师模型生成“软标签”（概率分布），而不是硬标签（具体类别）。</li><li>训练学生模型模仿教师模型的输出。</li></ol><ul><li>优点：小模型更轻量、更快，适合部署在手机、嵌入式设备等资源受限的场景。</li><li>例子：DistilBERT 是 BERT 的蒸馏版本，参数更少但性能接近。</li></ul><h3 id="模型剪枝（Model-Pruning）"><a href="#模型剪枝（Model-Pruning）" class="headerlink" title="模型剪枝（Model Pruning）"></a>模型剪枝（Model Pruning）</h3><p>是一种模型压缩技术，旨在通过移除神经网络中不重要的部分（如权重、神经元或层）来减少模型的大小和计算量，同时尽量保持模型的性能。剪枝可以帮助模型在资源受限的设备（如手机、嵌入式设备）上高效运行。</p><h3 id="后训练"><a href="#后训练" class="headerlink" title="后训练"></a>后训练</h3><p>基于预训练基础，指在模型完成训练后，对其进行进一步优化或处理的过程。这些优化通常是为了提高模型的效率、性能或适应性，而不需要重新训练整个模型。后训练技术在现代深度学习中非常重要，尤其是在资源受限的场景中（如移动设备、嵌入式系统）。</p><h3 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h3><p>一种深度学习模型架构，广泛应用于生成式AI（如 GPT、BERT）。它的核心是自注意力机制，可以捕捉长距离依赖关系。</p><h3 id="Prompt（提示词）"><a href="#Prompt（提示词）" class="headerlink" title="Prompt（提示词）"></a>Prompt（提示词）</h3><p>用户输入的指令或问题，用于引导生成式AI生成特定内容。</p><h3 id="Token（词元）"><a href="#Token（词元）" class="headerlink" title="Token（词元）"></a>Token（词元）</h3><p>生成式AI处理文本的基本单位，可以是单词、子词或字符。</p><h3 id="损失函数（Loss-Function）"><a href="#损失函数（Loss-Function）" class="headerlink" title="损失函数（Loss Function）"></a>损失函数（Loss Function）</h3><p>衡量模型预测与真实值差异的函数，用于指导模型优化。</p><h3 id="过拟合（Overfitting）"><a href="#过拟合（Overfitting）" class="headerlink" title="过拟合（Overfitting）"></a>过拟合（Overfitting）</h3><p>模型在训练数据上表现很好，但在新数据上表现差，通常是因为模型过于复杂或训练数据不足。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>指在机器学习模型（尤其是深度学习模型）中可训练参数的个数</p><ul><li>模型容量：参数越多，模型的表达能力越强，能够学习更复杂的模式和关系。</li><li>计算资源：参数越多，模型需要的计算资源（如内存、算力）也越多。</li><li>训练数据需求：参数越多的模型通常需要更多的训练数据，以避免过拟合。</li></ul><p>总之：参数数量类似于大脑中的神经元连接数。参数越多，模型“思考”能力越强，但也需要更多“能量”（计算资源）；参数越多，模型性能可能越好，但训练和推理成本也越高。因此，实际应用中需要在性能和效率之间找到平衡。</p><p><img src="/img/2025_3_12/001.png" alt="404"><br>B &#x3D; Billion（十亿参数）：表示模型的参数量级，直接影响计算复杂度和显存占用。</p><p>DeepSeek 1.5B：15亿参数（小型模型，适合轻量级任务）<br>DeepSeek 7B：70亿参数（主流规模，平衡性能与资源）<br>DeepSeek 70B：700亿参数（高性能需求场景）<br>DeepSeek 671B：6710亿参数（超大规模，对标PaLM&#x2F;GPT-4）</p><h3 id="RAG（检索增强生成）"><a href="#RAG（检索增强生成）" class="headerlink" title="RAG（检索增强生成）"></a>RAG（检索增强生成）</h3><p>是检索（Retrieval）、增强（Augmented）、生成（Generation）三个词的首字母组合。以DeepSeek为例，当你下达了“网络搜索”的命令，DS会去网络上检索有关信息（R），然后将答案整合（A），通过LLM生成（G）一段通顺的文本。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图</title>
      <link href="/2025/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
      <url>/2025/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>图G由顶点V和边E组成，记为G&#x3D;(V,E)，V一定非空，E可以空。<br>V&#x3D;{v1,v2,……,vn}，|V|表示顶点个数<br>E&#x3D;{(u,v)|u∈V,v∈V}，|E|表示边的条数</p><ul><li><p>有向图<br><code>&lt;v,w&gt;</code>称为从v到w的弧，也称v邻接到w。v为弧尾，w为弧头。</p></li><li><p>无向图<br><code>(v,w)或者(w,v)</code>说，w与v互为邻接点</p></li><li><p>简单图与多重图<br>简单图：1-不存在重复边（两个顶点的边数不多于一条）；2-不存在到自身的边<br>多重图：反之</p></li><li><p>完全图<br>若图的顶点数为n，如果|E|&#x3D;n*(n-1)&#x2F;2，称为无向完全图；如果|E|&#x3D;n*(n-1)，称为有向完全图。</p></li><li><p>子图<br>设有两个图G&#x3D;(V,E)，G’&#x3D;(V’,E’)，若V’∈V，E’∈E,则称G’是G的子图。</p></li><li><p>生成子图<br>若满足V(G’) &#x3D; V(G)，则称G’为G的生成子图</p></li><li><p>连通、连通图、连通分量（无向图范畴）<br>连通：两点之间存在路径<br>连通图：任意两点之间都是连通的<br>连通分量：无向图中的<strong>极大连通子图</strong></p></li></ul><blockquote><p>若一个图有n个顶点，若边数小于n-1，则为非连通图；若它是非连通图，则边数最多为<code>(n-1)(n-2)/2</code></p></blockquote><ul><li>强连通、强连通图、强连通分量（有向图范畴）<br>强连通：两点之间有双向路径<br>强连通图：任意两点之间都是强连通的<br>强连通分量：~</li></ul><blockquote><p>若一个有向图有n个顶点，若其为强连通图，最少需要n条边。</p></blockquote><ul><li>生成树<br><strong>连通图</strong>的生成树：包含全部顶点的极小连通子图（顶点数若为n，则其边数为n-1）<br>生成森林：在非连通图中，连通分量的生成树构成了非连通图的生成森林</li></ul><blockquote><p>极大||极小 - 连通子图：前者：尽可能包含多的点与边；后者：尽可能少的包含边。</p></blockquote><ul><li><p>顶点的度、入度、出度<br>无向图中：度(TD)：依附于顶点的边的条数。度数和&#x3D;边数*2。<br>有向图中：</p><ul><li><p>入度(ID)：以顶点为终点的有向边的数目</p></li><li><p>出度(OD)：以顶点为起点的有向边的数目</p></li><li><p>度：结点的入度加出度</p><p>入度之和等于出度之和等于边数</p></li></ul></li><li><p>边的权、网<br>边上的权值。带权的图成为带权图，也成为网</p></li><li><p>弧<br>有向图的边</p></li><li><p>稠密图、稀疏图<br>只是模糊的相对的概念。一般当|E|&lt;|V|log|V|时，将其视为稀疏图</p></li><li><p>路径、路径长度、回路<br>路径：指的是顶点序列（eg:v1,v2,v3）<br>路径长度：路径上边的数目<br>回路（环）：第一个顶点和最后一个顶点相同的路径。n个顶点的图中，若路径大于n-1，则存在回路。</p></li><li><p>简单路径、简单回路<br>简单路径：顶点不重复出现<br>简单回路：除第一个顶点、最后一个顶点，其他顶点不重复出现的回路。</p></li><li><p>距离<br>两个顶点间的最短路径，若不存在则为∞</p></li><li><p>有向树<br>有向图满足一个顶点入度为0，其余顶点入度均为1。</p></li></ul><h3 id="图的存储及其基本操作"><a href="#图的存储及其基本操作" class="headerlink" title="图的存储及其基本操作"></a>图的存储及其基本操作</h3><h4 id="邻接矩阵法-adjacency-matrix"><a href="#邻接矩阵法-adjacency-matrix" class="headerlink" title="邻接矩阵法(adjacency matrix)"></a>邻接矩阵法(adjacency matrix)</h4><p><img src="/img/2025_3_13/001.png" alt="404"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxVertexNum 100   <span class="comment">//顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType   <span class="comment">//顶点对应的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType    <span class="comment">//边对应的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vex[MaxVertexNum];   <span class="comment">//顶点表</span></span><br><span class="line">    EdgeType edge[MaxVertexNum][MaxVertexNum];      <span class="comment">//边表</span></span><br><span class="line">    <span class="type">int</span> vernum , edgenum;           <span class="comment">//图的当前顶点数与边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><ol><li>空间复杂度为O(n^2)，其中n为顶点的个数</li><li>当仅表示边是否存在时，可以用0\1的枚举类型定义边表</li><li>基于邻接矩阵度的计算</li></ol><ul><li>无向图：结点i的度，为第i行非0\∞元素的个数</li><li>有向图：结点i的出度，为i行非0\∞元素个数；结点i的入度，为第i列非0\∞元素的个数</li></ul><ol start="4"><li>用邻接矩阵很容易确定两个结点间是否有边；但确定总边数花费较大。</li><li>稠密图适合采用邻接矩阵</li><li>若一个图的邻接矩阵为A，则<code>A^n[i][j]</code>代表<strong>从结点i到结点j的路径长度为n的个数</strong>（参考离散数学）</li></ol><h4 id="邻接表法-adjacency-list"><a href="#邻接表法-adjacency-list" class="headerlink" title="邻接表法(adjacency list)"></a>邻接表法(adjacency list)</h4><blockquote><p>为减少邻接矩阵的浪费而生，采用顺序存储结合链式存储</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> Max 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span>     <span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvertex;    <span class="comment">//与头结点邻接的顶点编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span></span><br><span class="line">    <span class="comment">//InfoType info;        //权</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">建议保留typedef中的标签，即typedef struct ArcNode中的ArcNode</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果省略标签（struct ArcNode 中的 ArcNode），则在结构体内部无法使用 struct ArcNode *nextarc，因为编译器不知道 ArcNode 是什么。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span>       <span class="comment">//顶点表信息</span></span><br><span class="line">    VertexType data;        <span class="comment">//顶点**信息**</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">firstarc</span>;</span></span><br><span class="line">&#125;VNode,AdjList[Max];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AdjList 是一个数组类型，表示一个包含 Max 个 VNode 的数组。AdjList[Max] 则表示一个具体的数组实例，数组的大小为 Max，每个元素都是一个 VNode 结构体。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vertexnum,edgenum;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    AdjList vertices;</span></span><br><span class="line"><span class="comment">    vertices是一个数组</span></span><br><span class="line"><span class="comment">    例如：ALGraph a; a.vertices;假设图中有 3 个顶点（a.vertexnum = 3），边的数量为 2（a.edgenum = 2），那么：</span></span><br><span class="line"><span class="comment">    a.vertices[0] 表示第 1 个顶点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    a.vertices[1] 表示第 2 个顶点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    a.vertices[2] 表示第 3 个顶点。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>为什么要区分</li></ol><ul><li>顶点和边的性质不同：</li></ul><p>顶点是图的基本单元，通常包含额外的信息（如名称、权重等）。<br>边表示顶点之间的关系，通常只关注连接的目标顶点和边的权重（如果有）。</p><ul><li>存储结构不同：</li></ul><p>顶点表是一个数组或链表，存储所有顶点的信息。<br>边表是一个链表，存储与某个顶点相连的所有边。</p><ol start="2"><li>G为无向图，则所需的存储空间为：O(|V|+2|E|);G为由向图，则所需的存储空间为：O(|V|+|E|)</li><li>稀疏图可采用邻接表法，节省空间</li><li>给顶点，找到临边容易。</li><li>无向图求顶点的度：遍历该结点对应的边表。有向图由出度：同上。有向图求入度，遍历所有顶点的边表。</li><li>一个图的邻接表不唯一</li><li>若有向图使用邻接表法表示，有n个顶点，e条边。若删除与顶点v相关的所有边：</li></ol><p>需要删除顶点v的入边与出边</p><p>以下是删除顶点 v所有入边的伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delete_in_edges</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> 所有顶点:          <span class="comment"># 遍历所有顶点，O(n)</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> u的邻接表:  <span class="comment"># 遍历u的所有出边，O(deg(u))</span></span><br><span class="line">            <span class="keyword">if</span> neighbor == v:</span><br><span class="line">                删除 u→v 的边</span><br></pre></td></tr></table></figure><p><img src="/img/2025_4_16/001.png" alt="404"></p><p>以下删除出边<br><img src="/img/2025_4_16/002.png" alt="404"></p><ol start="8"><li>对于n个顶点，e条边的无向图：建立邻接表，需要n+2*e次操作，时间复杂度为O(n+e)</li></ol><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>是有向图的链式存储结构。<br>每个弧用一个结点表示，每个顶点也用一个结点表示</p><p><img src="/img/2025_3_14/001.png" alt="404"></p><ol><li>弧结点</li></ol><ul><li>TailVertex：弧尾编号</li><li>HeadVertex：弧头编号</li><li>hlink：弧头相同的下一个结点</li><li>tlink：弧尾相同的下一个结点</li><li>info：弧的相关信息</li></ul><ol start="2"><li>顶点结点</li></ol><ul><li>data：顶点相关信息</li><li>firstin：第一个弧头朝向该顶点的弧</li><li>fitstout：第一个弧尾朝向该顶点的弧</li></ul><ol start="3"><li>十字链表容易确定出度与入度</li><li>图的十字链表不唯一，然而一个十字链表可以确定一个唯一的图</li></ol><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><p>无向图的链式存储结构</p><p><img src="/img/2025_3_14/002.png" alt="404"></p><ol><li>边结点</li></ol><ul><li>ivex：指示该边依附的两个顶点的编号之一</li><li>ilink：下一条依附于顶点ivex的边</li><li>jvex：指示该边依附的两个顶点的编号之一</li><li>jlink：下一条依附于jvex的边</li><li>info：信息</li></ul><ol start="2"><li>顶点结点</li></ol><ul><li>data</li><li>firstedge：第一条依附于该顶点的边</li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>对图中所有顶点访问、且只访问一次</p><h4 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h4><ol><li>伪代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[max];</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;G.vernum;i++)&#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.vermun;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            BFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用邻接表实现BFS</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(ALGraph G,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    visit(i);</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    EnQueue(&amp;Q,i);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(&amp;Q,v);</span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[v].firstarc;p;p=p-&gt;nextarc)&#123;       <span class="comment">//p为指向节点的指针</span></span><br><span class="line">            w = p-&gt;adjvex;      <span class="comment">//w为节点的编号</span></span><br><span class="line">            <span class="keyword">if</span>(visited[w] = <span class="literal">false</span>)&#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(&amp;Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用邻接矩阵实现BFS</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(MGraph G,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    visit(i);</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    EnQueue(&amp;Q,i);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(&amp;Q,v);</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vernum;w++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[w] == <span class="literal">false</span> &amp;&amp; G.edge[v][w] == <span class="number">1</span>)&#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(&amp;Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS性能分析"><a href="#BFS性能分析" class="headerlink" title="BFS性能分析"></a>BFS性能分析</h4><ol><li>空间复杂度：涉及到辅助队列，为O(|V|)</li><li>时间复杂度：</li></ol><p><img src="/img/2025_4_16/003.png" alt="404"></p><p><img src="/img/2025_4_16/004.png" alt="404"></p><h4 id="BFS单源最短路径"><a href="#BFS单源最短路径" class="headerlink" title="BFS单源最短路径"></a>BFS单源最短路径</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS_Mini_Distance</span><span class="params">(Graph G,<span class="type">int</span> u)</span>&#123;</span><br><span class="line">    <span class="comment">//d[i]表示u到i的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vernum;i++)&#123;</span><br><span class="line">        d[i] = ∞;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    EnQueue(&amp;Q,u);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(&amp;Q,u);</span><br><span class="line">        <span class="keyword">for</span>(w=FirstNeighbor(G,u);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,u,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                d[w] = d[u]+<span class="number">1</span>;</span><br><span class="line">                EnQueue(&amp;Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*BFS（广度优先搜索）能够正确计算无权图（或边权相同的图）的单源最短路径，原因在于它的 &quot;层次遍历&quot;（Level Order Traversal） 特性。具体来说，BFS 按照 &quot;距离源点 u 由近到远&quot; 的顺序访问顶点，因此 首次访问某个顶点 w 时，所记录的路径长度 d[w] 一定是最短的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">后续如果还有其他路径到达 w，由于 BFS 已经优先访问了更短的路径，所以不会再更新 d[w]。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h4><ol><li>代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[max];</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; G.vexnum;i++)&#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            DFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>DFS的实现（使用邻接表）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(ALGraph G,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    visit(i);</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">        j=p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">            DFS(G,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>DFS的实现（使用邻接矩阵）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph G,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    visit(i);</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; G.vexnum;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[j]==<span class="literal">false</span> &amp;&amp; G.edge[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            DFS(G,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>山西晋城高铁站旁的公园之旅</title>
      <link href="/2025/03/09/%E5%B1%B1%E8%A5%BF%E6%99%8B%E5%9F%8E%E9%AB%98%E9%93%81%E7%AB%99%E6%97%81%E7%9A%84%E5%85%AC%E5%9B%AD%E4%B9%8B%E6%97%85/"/>
      <url>/2025/03/09/%E5%B1%B1%E8%A5%BF%E6%99%8B%E5%9F%8E%E9%AB%98%E9%93%81%E7%AB%99%E6%97%81%E7%9A%84%E5%85%AC%E5%9B%AD%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="“当作一次晚间附近公园散步”"><a href="#“当作一次晚间附近公园散步”" class="headerlink" title="“当作一次晚间附近公园散步”"></a>“当作一次晚间附近公园散步”</h3><p>山西晋城理河南焦作并不远，坐高铁穿过太行山脉，却也只需要近30分钟抵达晋城东站。我想，顷刻之间就可以出省，不妨试一试，就当作一次晚间公园的散步了，看看外省的风景、品读别样的人间故事。</p><h3 id="“速通公园？别闹。”"><a href="#“速通公园？别闹。”" class="headerlink" title="“速通公园？别闹。”"></a>“速通公园？别闹。”</h3><blockquote><p>这是我的行走路线<br><img src="/img/2025_3_9/005.png" alt="404"></p></blockquote><blockquote><p>这是我一开始计划走的路线<br><img src="/img/2025_3_9/006.png" alt="404"></p></blockquote><blockquote><p>行程<br><img src="/img/2025_3_9/007.png" alt="404"></p></blockquote><p>计划终归是赶不上变化：我于15：45从学校出发，16：15到达北火车站，这时已经开始检票，16：25坐上火车，16：31火车开动，17：01出晋城东站，在行走、观光了约90分钟后，回到晋城东站站前广场，约18：40进入车站，逛了中欧班列进口超市后等待，约19：10坐上车，20：50抵达图书馆自习，22：10回到宿舍。</p><p>我原本计划走的路线，但终究是错付了，时间根本来不及。一开始自己觉得这公园也没这么大吧，也没像上面这样测距，还在想着逛完这个公园去哪？50分钟就逛完了该咋办？自己买16：31的车会不会太早等等。现在看来，真是当局者迷、旁观者清，当时的自己挺傻的。</p><p>自己总是这样的，一开始规划的什么什么，到最后可能并不会达到什么，而是剑走偏锋，虽然结局差强人意，但毕竟与自己的本意不符，难免有些伤感。一开始不会考虑这么多，想着事情一定是按照自己的本意向前推动的，但结局并不是这样，冷静的分析这些“囧事”，虽在意料之外，却也在情理之中。吸取经验教训、一笑而过了。</p><p>看来以后还要增强自己的规划能力、提升自己的规划技巧、磨练自己的规划本领、增长自己的规划见识。</p><h3 id="“Scenery”"><a href="#“Scenery”" class="headerlink" title="“Scenery”"></a>“Scenery”</h3><p><img src="/img/2025_3_9/008.jpg" alt="404"><br>像韩国的小法国村里的建筑一样，用实木代替钢筋混凝土，木柱上缠绕着发光灯带，亦或理解为欧式庄园风格、同时兼顾中式对称美学，好，好。</p><p><img src="/img/2025_3_9/009.jpg" alt="404"><br>很有科技感</p><p><img src="/img/2025_3_9/010.jpg" alt="404"><br>李商隐公园的亭子，我蹬自行车60分钟，高铁只需要9分钟。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI-第四次工业革命-Trae</title>
      <link href="/2025/03/03/AI-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%B7%A5%E4%B8%9A%E9%9D%A9%E5%91%BD-Trae/"/>
      <url>/2025/03/03/AI-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%B7%A5%E4%B8%9A%E9%9D%A9%E5%91%BD-Trae/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Trae"><a href="#Trae" class="headerlink" title="Trae"></a>Trae</h3><h4 id="今日重磅消息："><a href="#今日重磅消息：" class="headerlink" title="今日重磅消息："></a>今日重磅消息：</h4><p>3月3日，字节跳动发布AI编程工具Trae国内版，模型搭载doubao-1.5-pro，支持切换满血版DeepSeek R1&amp;V3。这是国内首个AI原生集成开发环境工具（AI IDE）。<br><img src="/img/2025_3_3/001.png"></p><h4 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h4><p>我用其写”基于Vue-DeepSeekAPI的对话”，10分钟不到就完成了，效果还不错。</p><img src="/img/2025_3_3/002.png" width="20%"><p>等待一会儿后</p><img src="/img/2025_3_3/003.png" width="50%"><p>本项目只需要开发者了解基础技术栈的知识，具体实现直接AI即可，指数倍的缩短的研发周期。标志着软件开发正进入AI全面赋能时代。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p><img src="/img/2025_3_3/004.png" alt="404"><br>即小小的Bug，重新打开项目即可消除</p><h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><p>该软件具有生成项目的功能，待技术成熟后定试一试。</p><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><h4 id="一则报告"><a href="#一则报告" class="headerlink" title="一则报告"></a>一则报告</h4><p>报告一：《AI in Action: Beyond Experimentation to Transform Industry 2025》</p><iframe src="https://reports.weforum.org/docs/WEF_Quantum_Technologies_Key_Strategies_and_Opportunities_for_ICT_Leaders_2025.pdf" width="100%" height="500px"></iframe><p><a href="https://reports.weforum.org/docs/WEF_AI_in_Action_Beyond_Experimentation_to_Transform_Industry_2025.pdf">文章链接</a></p><h4 id="AI-IoT"><a href="#AI-IoT" class="headerlink" title="AI+IoT"></a>AI+IoT</h4><p>就从笔者的专业领域—物联网出发，探究“AI+IoT+Medicine”能够带来什么：</p><ol><li>由于人口老龄化、人均年龄的上升、科技日新月异的发展等等。人们可以通过<strong>智能手环</strong>来检测自己的身体状态，当然区别于现在2025年常规单一检测软件的综合检验效果，我给它的定位是：</li></ol><ul><li>当人们不舒服时，就症状向手环的AI发起询问请求，AI给出潜在的疾病可能性，再由手环上的传感器决策，最终落实到医院的最终检验报告单，实现疾病的“早发现，早治疗”。</li><li>当人们无感觉时，手环持续监测人们的身体，AI定期推送不同的“检测身体”的一些活动任务，比如说“慢跑一圈后有什么除了累之外特殊的异样”，有异样，根据其按照上一条进行剪枝、决策；没有异样，继续监测。或者是“定期询问人：昨晚睡得怎么样？”以此来收集信息。就像一个私人医生管家一样照顾人类。</li></ul><ol start="2"><li>智能家居的二次革命</li></ol><p>现在传统的智能家居莫非于“摄像头联网、自动拉开窗帘等”，若使AI介入，例如：</p><ul><li>控制火候：根据AI的检索，使火候自适应于相应的菜，让菜更加美味</li><li>自动调节室温：AI学习人类的行为居住模式，自动调节室内温度，提升舒适度并节能。</li><li>洗涤衣服：根据LLM图像识别，对不同的衣服施加以不同的洗涤方式，例如，怎么洗毛衣-30°C温水洗涤</li></ul><h4 id="随感"><a href="#随感" class="headerlink" title="随感"></a>随感</h4><ol><li><p>AI世界的发展迎来前所未有之大变局-笔者22年上大学的时候，对“人工只能”这两个字嗤之以鼻，因为未曾看见落地的项目，总觉得它好像古巴比伦国王为妻子修建的空中花园一样——美好而不切实际，23年首次接触了ChatGPT，觉得它有时候可以写代码，挺有意思的，但仍觉得无所谓，24年ChatGPT升级到4o与o1，同时伴随着“智能对话”：该AI对话者有真实人类停顿的能力与处理你抢话的能力，再加上上传图片、文本，对这些附件的识别与处理，生成式人工智能迈上了一个新的历史性台阶。这个时候我国的大模型有“文心一言、豆包、kimi”等，虽比不上某大型LLM，但是差强人意。</p></li><li><p>DeepSeek横空出世，颠覆了历史。</p></li></ol><ul><li><p>V3对标4o<br><img src="/img/2025_3_11/002.png" alt="404"></p></li><li><p>R1对标o1<br><img src="/img/2025_3_11/003.png" alt="404"></p></li><li><p>思考方式的对标<br>应用端或者API，将完整的思考方式“可视化”，这是ChatGPT不具有的能力。</p></li><li><p>开源<br>美国闭门造车，终究是站在了历史错误的一面，DeepSeek完全开源，让许多没有硬件、软件能力造LLM的国家凭借DeepSeek的开源技术，用极低的成本与人力资源复刻属于自己的大模型，遏制了美帝国主义的极端霸权行为。</p></li></ul><p>从此，大模型时代很可能会进入一个分水岭：超强性能的模型不再独属于算力巨头，而是属于每个人。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Trae </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025_2_28骑行博爱县</title>
      <link href="/2025/02/28/2025-2-28%E9%AA%91%E8%A1%8C%E5%8D%9A%E7%88%B1%E5%8E%BF/"/>
      <url>/2025/02/28/2025-2-28%E9%AA%91%E8%A1%8C%E5%8D%9A%E7%88%B1%E5%8E%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/2025_2_28/002.jpg" alt="404"><br>落日余晖与铁路道交相辉映，颇具古典化与现代化</p><p><img src="/img/2025_2_28/003.jpg" alt="404"><br>我去过很多城市的公园，真正让我流连忘返、念念不忘的很少，这座公园便是其中一个。北望太行山脉、南瞰县城风貌、东临人民大道、西靠交通枢纽，我不禁赞叹它优越的地理位置，仿佛命中注定一般，这地方终会有这样一座公园；园中高挑中空的中式拱桥，台痕上满布着裂痕，它镌刻着时间的年轮，勾勒出变迁的轨迹、能够登顶的别样的古亭，静静地伫立在最高处，像一位年老的长者，俯瞰着众生百态，体察着人间冷暖、当然，别忘了空气中微微凉爽的和风与风掠过水面激荡起的阵阵波纹，鸭子随着微波而游走，大抵是在与其和舞一曲。这园中不单单有我的脚印，有我脚印的地方还有我的车辙印，穿过草地、掠过树梢、划过木桥，这园中不单单有我的车辙印，有车辙印的地方还有我热情而澎湃的内心。</p><p>李商隐公园中的最高处：我去年来到这里的时候，石壁上镌刻着许许多多凌乱而歪歪扭扭的中文或英文：有象征的美好爱情的彼此姓名，字迹工整却又略显笨拙；有以粗石为笔、以古亭为底，为这一番天地作画的；还有登上最高处想着抒发一番豪情壮志刻下某某到此一游以此舒展胸襟抱负的。</p><p>随着光阴的流逝，岁月的痕迹渐渐爬上古亭的每一处毛孔，它淡退了朱红雕刻的古砖，隐去了斑驳耀耀的琉璃壁画。如今这古亭被颜料重新粉刷，流金的昔日迈着沉重的步伐走下山去，别样的现代兴致冲冲地跑上山来。到底是为了辉煌的现在而发表赞歌，还是为曾经字里行间的情真意切而留恋呢。</p><p>爱情的蜜语也许曾给他们带来欢乐、意气风发的言论也曾是照亮的某人片刻的伤感，幼稚的画作也曾是年轻学生的短暂陪伴，曾今的它们被钉在古亭的历史柱上，散发着熠熠光辉，便拥有了短暂的意义，纵使我们认为所有的事情不需要都需要有意义，但有意义仍是主旋律，没有意义的事情与有意义的事情相得益彰，当做没有意义的事情时，并不是因为着重是也不过是因为其本身罢了。</p><p>仔细看时，那些刻的力度重的字或图，仍然屹立在石壁上，不因任何外力而改变，是永恒的，是不朽的，是传奇的。</p><p>我在这园中踱步，当荷塘落满黑暗然后再渐渐泛起月光，路灯的光亮划破广袤而又寂寥的苍天，我发觉我应该回去了。</p><p>回去的路上，路过喜德盛自行车店，我走进去，问老板是否有GT350，因为看了短视频的描述，总觉得这车别有一番姿态。攀谈中，老板告诉我，骑行的人多半是有些抑郁的，而我并不赞同这个观点。骑车是澎湃的、是热烈的，身体和思想，总有一个在路上。再一个老板提到318公路骑行，我对此坚决反对，网上充斥着大量描绘318国道沿途壮丽的风景，却对背后的艰难险阻只字不提，都头来，只会把别人坑的越来越惨。除了这两个观点，我于心底暗暗反对，其他诸如“砾石车单盘、定制禧玛诺套件”等，得虚心请教。</p><p>老板是个善良的人。他跟我说，他的女儿今年高二，在重点高中，看到她早出晚归的很是万番心疼，自己唯一能做的便是待她回家对学习的事缄口不谈，他也不期望她考上重点大学，过的开心快乐就好了。是的，上天给了我们一双眼睛，是用它来发现生活的美好，并非睁眼闭眼课本资料（喜欢读书的人请忽略），当你抬起头，多看看周围的世界，你会发现原来生活这么美。好好生活才是我们最重要的修行，是我们终身学习、活得开心的本事。请让孩子在爱与规矩中成长。</p><p><strong>21:00</strong>回到了学校，明早醒来便是3月1日了。</p><blockquote><p>轻轻的我走了，正如我轻轻的来，我挥一挥衣袖，不带走一片云彩<br>                                                      《再别康桥》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 骑行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树</title>
      <link href="/2025/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
      <url>/2025/02/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>即用数组来存储，从上到下，从左到右，将编号为i的结点存在数组下标为i-1的位置上。<br>适合于完全二叉树与满二叉树；对一般二叉树不友好，浪费空间。</p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    element data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">left</span> , *<span class="title">right</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历与线索二叉树"><a href="#二叉树的遍历与线索二叉树" class="headerlink" title="二叉树的遍历与线索二叉树"></a>二叉树的遍历与线索二叉树</h3><h4 id="先序遍历的递归操作"><a href="#先序遍历的递归操作" class="headerlink" title="先序遍历的递归操作"></a>先序遍历的递归操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchlid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历的递归操作"><a href="#中序遍历的递归操作" class="headerlink" title="中序遍历的递归操作"></a>中序遍历的递归操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历的递归操作"><a href="#后序遍历的递归操作" class="headerlink" title="后序遍历的递归操作"></a>后序遍历的递归操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历要保证&quot;左孩子在右孩子前、且它们都在根节点前被访问&quot;才能访问根节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在递归遍历中，递归工作栈的深度为树的深度，高度为n的二叉树的遍历时间复杂度为O(n)</p><h4 id="先序遍历的非递归操作"><a href="#先序遍历的非递归操作" class="headerlink" title="先序遍历的非递归操作"></a>先序遍历的非递归操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p = p -&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S,p);</span><br><span class="line">            p = p -&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历的非递归操作"><a href="#中序遍历的非递归操作" class="headerlink" title="中序遍历的非递归操作"></a>中序遍历的非递归操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitStack(&amp;S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p = p -&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S,p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p -&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历的非递归操作"><a href="#后序遍历的非递归操作" class="headerlink" title="后序遍历的非递归操作"></a>后序遍历的非递归操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    BiTNode *p = T;</span><br><span class="line">    BiTNode *r = <span class="literal">NULL</span>;</span><br><span class="line">    InitStack(*S);</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span> &amp;&amp; !IsEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GetTop(S,p);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild != r)&#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Pop(S,p);</span><br><span class="line">                visit(p);</span><br><span class="line">                r=p;    <span class="comment">//r为刚刚访问过的元素</span></span><br><span class="line">                p=<span class="literal">NULL</span>; <span class="comment">//把p置空。因为已经出栈并访问的结点，它的子孙一定被访问，把p置空，从栈中再取新的结点。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>完全二叉树<code>12345</code>会触发<code>p-&gt;rchild != r</code></li></ul><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="由遍历序列确定二叉树"><a href="#由遍历序列确定二叉树" class="headerlink" title="由遍历序列确定二叉树"></a>由遍历序列确定二叉树</h4><ol><li><p>由先序序列和中序序列确定二叉树</p></li><li><p>由中序序列和后序序列确定二叉树</p></li><li><p>由中序序列和层次序列确定二叉树</p></li><li><p>由<strong>先序序列或者后序序列</strong>与<strong>层次序列</strong>不能确定二叉树</p></li></ol><h4 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree</span><br></pre></td></tr></table></figure><h4 id="构造中序线索二叉树"><a href="#构造中序线索二叉树" class="headerlink" title="构造中序线索二叉树"></a>构造中序线索二叉树</h4><p>实质上是中序二叉树线索化：即遍历中序二叉树，将其“升级”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数：将二叉树线索化</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pre指向上一个访问过的结点</span></span><br><span class="line"><span class="comment">    p指向下一个结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadNode *p,ThreadNode *pre)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(&amp;(p-&gt;lchild),&amp;pre);<span class="comment">//递归，线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchlid == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchlid = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InTree(&amp;(p-&gt;rchild),&amp;pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    函数：通过中序遍历建立中序线索二叉树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadNode  *T)</span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(&amp;T,&amp;pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带头结点的中序线索二叉树"><a href="#带头结点的中序线索二叉树" class="headerlink" title="带头结点的中序线索二叉树"></a>带头结点的中序线索二叉树</h4><p>头结点lchild指向根节点；rchild指向遍历序列最后一个结点。<br>遍历得到的第一个结点lchild指向head；最后一个结点rchild指向head。</p><h4 id="中序线索二叉树的遍历"><a href="#中序线索二叉树的遍历" class="headerlink" title="中序线索二叉树的遍历"></a>中序线索二叉树的遍历</h4><ol><li>求结点下一个结点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadTree *<span class="title function_">FirstNode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag != <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;lchild</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>求结点p的后继</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadTree *<span class="title function_">NextNode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> FirstNode(&amp;p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>中序遍历线索二叉树</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(ThreadNode *T)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p=FirstNode(&amp;T);p!=<span class="literal">NULL</span>;p=NextNode(&amp;p))&#123;</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="二叉树按照顺序存储方式存储，求编号为i、j两个结点最近的公共祖先的值。"><a href="#二叉树按照顺序存储方式存储，求编号为i、j两个结点最近的公共祖先的值。" class="headerlink" title="二叉树按照顺序存储方式存储，求编号为i、j两个结点最近的公共祖先的值。"></a>二叉树按照<strong>顺序存储方式</strong>存储，求编号为i、j两个结点最近的公共祖先的值。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="title function_">Comm_Ancestor</span><span class="params">(SqTree T,<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T[i] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; T[j] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">                i = i / <span class="number">2</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = j / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求用二叉链表存储的二叉树的深度"><a href="#求用二叉链表存储的二叉树的深度" class="headerlink" title="求用二叉链表存储的二叉树的深度"></a>求用<strong>二叉链表</strong>存储的二叉树的深度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*递归算法*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BtDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//空树</span></span><br><span class="line">    &#125;</span><br><span class="line">    ldep = BtDepth(T-&gt;lchild);</span><br><span class="line">    rdep = BtDepth(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(ldep &gt; rdep)&#123;</span><br><span class="line">        <span class="keyword">return</span> ldep + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rdep + <span class="number">1</span>;    <span class="comment">//加一是加的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*非递归算法*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BtDepth</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span> ,last = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>,level = <span class="number">0</span>;     <span class="comment">//last指向每层的最后一个结点</span></span><br><span class="line">    BiTree Q[Max];  <span class="comment">//设置队列，数据类型为二叉树结点指针，max要足够大</span></span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    BiTree p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)&#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild)&#123;</span><br><span class="line">            Q[++rear] = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild)&#123;</span><br><span class="line">            Q[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == front)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            last = rear;<span class="comment">//指向下层</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树按二叉链表形式存储，怎么判断这棵二叉树是不是完全二叉树"><a href="#二叉树按二叉链表形式存储，怎么判断这棵二叉树是不是完全二叉树" class="headerlink" title="二叉树按二叉链表形式存储，怎么判断这棵二叉树是不是完全二叉树"></a>二叉树按<strong>二叉链表</strong>形式存储，怎么判断这棵二叉树是不是完全二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">IsCom</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BiTree p = <span class="literal">NULL</span>;</span><br><span class="line">    InitQueue(&amp;Q);  <span class="comment">//采用顺序队列</span></span><br><span class="line">    EnQueue(&amp;Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(&amp;Q,p);</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            EnQueue(&amp;Q,p-&gt;lchild);</span><br><span class="line">            EnQueue(&amp;Q,p-&gt;rchild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">                DeQueue(&amp;Q,p);</span><br><span class="line">                <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树按照二叉链表形式存储，求有两个孩子结点的个数"><a href="#二叉树按照二叉链表形式存储，求有两个孩子结点的个数" class="headerlink" title="二叉树按照二叉链表形式存储，求有两个孩子结点的个数"></a>二叉树按照<strong>二叉链表</strong>形式存储，求有两个孩子结点的个数</h4><blockquote><p>不难想到使用层次遍历结合全局变量，但还可以递归</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Nodes</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Nodes(T-&gt;lchild)+Nodes(T-&gt;rchild)+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Nodes(T-&gt;lchild)+Nodes(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>建立递归模型是有助于分析的</p></blockquote><h4 id="二叉树B使用链式结构存储，交换它的左右结点"><a href="#二叉树B使用链式结构存储，交换它的左右结点" class="headerlink" title="二叉树B使用链式结构存储，交换它的左右结点"></a>二叉树B使用<strong>链式结构存储</strong>，交换它的左右结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(BiTree B)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B)&#123;</span><br><span class="line">        swap(B-&gt;lchild);</span><br><span class="line">        swap(B-&gt;rchild);</span><br><span class="line">        BiTree temp = <span class="literal">NULL</span>;</span><br><span class="line">        temp = B-&gt;lchild;</span><br><span class="line">        B-&gt;lchild = B-&gt;rchild;</span><br><span class="line">        B-&gt;rchild = temp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本题采用了后续遍历的思想。为什么是后续而不是前序、中序。因为后续最后遍历根节点，如果在遍历根节点前就已经完成了交换根节点左右子树的行为，再递归到根节点的右子树，实际上仍然是对根节点左子树的重复操作。</p></blockquote><h4 id="二叉树使用二叉链表形式存储，求先序遍历中第k个结点的值（1"><a href="#二叉树使用二叉链表形式存储，求先序遍历中第k个结点的值（1" class="headerlink" title="二叉树使用二叉链表形式存储，求先序遍历中第k个结点的值（1&lt;&#x3D;k&lt;&#x3D;n）"></a>二叉树使用<strong>二叉链表形式存储</strong>，求先序遍历中第k个结点的值（1&lt;&#x3D;k&lt;&#x3D;n）</h4><blockquote><p>本题可以在先序遍历的非递归算法中做手脚。亦或采用递归算法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span> ; <span class="comment">//global var</span></span><br><span class="line">ElemType <span class="title function_">find</span><span class="params">(BiTree T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == k)&#123;</span><br><span class="line">        <span class="keyword">return</span> T-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    ch = find(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">if</span>(ch != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = find(T-&gt;rchild,k);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>烧脑，</p></blockquote><h4 id="二叉树以二叉链表形式存储，删除每一个值为x的结点"><a href="#二叉树以二叉链表形式存储，删除每一个值为x的结点" class="headerlink" title="二叉树以二叉链表形式存储，删除每一个值为x的结点"></a>二叉树以二叉链表形式存储，删除<strong>每一个</strong>值为x的结点</h4><blockquote><p>本题分两个函数:删除函数与遍历函数<br>遍历函数采用后序遍历，即保证根节点的存在性</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        Delete(T-&gt;lchild);</span><br><span class="line">        Delete(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Search</span><span class="params">(BiTree T,Element x)</span>&#123;</span><br><span class="line">    BiTree Q[];     <span class="comment">//一维指针数组</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data == x)&#123;</span><br><span class="line">        Delete(T);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    DeQueue(&amp;Q,T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;lchild-&gt;data == x)&#123;</span><br><span class="line">                Delete(T-&gt;child);</span><br><span class="line">                T-&gt;child = <span class="literal">NULL</span>;    <span class="comment">//置空</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                EnQueue(&amp;Q,T-&gt;lchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T-&gt;rchild-&gt;data == x)&#123;</span><br><span class="line">                Delete(T-&gt;rchild);</span><br><span class="line">                T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                EnQueue(&amp;Q,T-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在二叉树中，打印值为x的结点的所有祖先（值为x的结点不多于1个）"><a href="#在二叉树中，打印值为x的结点的所有祖先（值为x的结点不多于1个）" class="headerlink" title="在二叉树中，打印值为x的结点的所有祖先（值为x的结点不多于1个）"></a>在二叉树中，打印值为x的结点的所有祖先（值为x的结点不多于1个）</h4><blockquote><p>祖先：从根节点A到结点K的<strong>唯一路径</strong>上的所有除K以外的其他结点<br>采用后续遍历，遍历到结点x时，栈中所有的元素即为x的祖先</p></blockquote><ul><li>变种：设p\q为二叉树上的结点，找到它们最近的公共祖先</li></ul><blockquote><p>对原栈与辅助栈匹配</p></blockquote><h4 id="二叉树采用二叉链表形式存储，求非空二叉树b的宽度（具有节点数最多的那一层结点的个数）"><a href="#二叉树采用二叉链表形式存储，求非空二叉树b的宽度（具有节点数最多的那一层结点的个数）" class="headerlink" title="二叉树采用二叉链表形式存储，求非空二叉树b的宽度（具有节点数最多的那一层结点的个数）"></a>二叉树采用二叉链表形式存储，求非空二叉树b的宽度（具有节点数最多的那一层结点的个数）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BiTree data[Max];</span><br><span class="line">    <span class="type">int</span> level[Max];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125;Qu;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTWidth</span><span class="params">(BiTree b)</span>&#123;</span><br><span class="line">    BiTree p ;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>；</span><br><span class="line">    Qu.front = Qu.rear = <span class="number">-1</span>;</span><br><span class="line">    Qu.rear++;</span><br><span class="line">    Qu.data[Qu.rear] = b;</span><br><span class="line">    Qu.level[Qu.rear] = <span class="number">1</span>;      <span class="comment">//根节点层次为1</span></span><br><span class="line">    <span class="keyword">while</span>(Qu.rear &gt; Qu.front)&#123;</span><br><span class="line">        Qu.front++;</span><br><span class="line">        p = Qu.data[Qu.front];      <span class="comment">//出队结点</span></span><br><span class="line">        k = Qu.level[Qu.front];     <span class="comment">//出队结点的层次</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Qu.rear++;</span><br><span class="line">            Qu.data[Qu.rear] = p-&gt;lchild;</span><br><span class="line">            Qu.level[Qu.rear] = k+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            Qu.rear++;</span><br><span class="line">            Qu.data[Qu.rear] = p-&gt;rchild;</span><br><span class="line">            Qu.level[Qu.rear] = k+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;    <span class="comment">//同一层最多的结点个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;      <span class="comment">//n统计第k层结点个数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;      <span class="comment">//迭代器</span></span><br><span class="line">    k = <span class="number">1</span>;      <span class="comment">//表示从第一层开始查找</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= Qu.rear)&#123;</span><br><span class="line">        n = <span class="number">0</span>;      </span><br><span class="line">        <span class="keyword">while</span>(i&lt;=Qu.rear &amp;&amp; Qu.level[i] == k)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        k = Qu.level[i];</span><br><span class="line">        <span class="keyword">if</span>(k&gt;max)&#123;</span><br><span class="line">            max = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="对一棵满二叉树，已知先序遍历字符串，求后序遍历字符串"><a href="#对一棵满二叉树，已知先序遍历字符串，求后序遍历字符串" class="headerlink" title="对一棵满二叉树，已知先序遍历字符串，求后序遍历字符串"></a>对一棵满二叉树，已知先序遍历字符串，求后序遍历字符串</h4><blockquote><p>采用递归的思想</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreToPost</span><span class="params">(ElemType pre[],<span class="type">int</span> l1,<span class="type">int</span> h1,ElemType post[],<span class="type">int</span> l2,<span class="type">int</span> h2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> half = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(h1&gt;l1)&#123;</span><br><span class="line">        post[h2] = pre[l1];</span><br><span class="line">        half=(h1-l1)/<span class="number">2</span>;</span><br><span class="line">        PreToPost(pre,l1+<span class="number">1</span>,l1+half,post,l2,l2+half<span class="number">-1</span>);</span><br><span class="line">        PreToPost(pre,l1+half+<span class="number">1</span>,h1,post,l2+half,h2<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ElemType *pre = <span class="string">&quot;ABCDEFG&quot;</span>;</span><br><span class="line">ElemType post[Max];</span><br><span class="line">PreToPost(pre,<span class="number">0</span>,<span class="number">6</span>,post,<span class="number">0</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h4 id="设计一个算法将二叉树的叶节点从左到右链接成为一个单链表，表头指针为head，二叉树使用二叉链表方式存储，叶节点的右孩子来存放单链表指针"><a href="#设计一个算法将二叉树的叶节点从左到右链接成为一个单链表，表头指针为head，二叉树使用二叉链表方式存储，叶节点的右孩子来存放单链表指针" class="headerlink" title="设计一个算法将二叉树的叶节点从左到右链接成为一个单链表，表头指针为head，二叉树使用二叉链表方式存储，叶节点的右孩子来存放单链表指针"></a>设计一个算法将二叉树的叶节点从左到右链接成为一个单链表，表头指针为head，二叉树使用二叉链表方式存储，叶节点的右孩子来存放单链表指针</h4><blockquote><p>遍历二叉树的叶子节点，前序、中序、后序都是先访问左节点，再访问右节点。这里采用中序遍历</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkList head = <span class="literal">NULL</span>,pre = <span class="literal">NULL</span>;</span><br><span class="line">LinkList <span class="title function_">InOrder</span><span class="params">(BiTree bt)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt)&#123;</span><br><span class="line">        InOrder(bt-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                pre = bt;</span><br><span class="line">                head =bt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre-&gt;rchlid = bt;</span><br><span class="line">                pre = bt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InOrder(bt-&gt;rchild);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n),栈复杂度O(n)。</p><h4 id="判断两棵树是否相似。相似：T1、T2都为空或者都只有一个结点；或者它们的左子树是相似的；且他们的右子树是相似的"><a href="#判断两棵树是否相似。相似：T1、T2都为空或者都只有一个结点；或者它们的左子树是相似的；且他们的右子树是相似的" class="headerlink" title="判断两棵树是否相似。相似：T1、T2都为空或者都只有一个结点；或者它们的左子树是相似的；且他们的右子树是相似的"></a>判断两棵树是否相似。相似：T1、T2都为空或者都只有一个结点；或者它们的左子树是相似的；且他们的右子树是相似的</h4><blockquote><p>注意理解递归调用的返回值的去向，x调用y，y返回值返回给x</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">similar</span><span class="params">(BiTree T1,BiTree T2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> leftS = <span class="number">0</span> ,rightS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(T1 == <span class="literal">NULL</span> || T2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        leftS = similar(T1-&gt;lchild &amp;&amp; T2-&gt;lchild);</span><br><span class="line">        rightS = similar(T1-&gt;rchild &amp;&amp; T2-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> leftS &amp;&amp; rightS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="森林用孩子兄弟表示法存储，求叶节点数"><a href="#森林用孩子兄弟表示法存储，求叶节点数" class="headerlink" title="森林用孩子兄弟表示法存储，求叶节点数"></a>森林用孩子兄弟表示法存储，求叶节点数</h4><blockquote><p>牢记递归的思想<br>遍历到的结点有孩子：计数该节点+兄弟<br>没有孩子：本身是叶节点（+1），+兄弟</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element data;</span><br><span class="line">    CSNode *firstchild,*firstbro;</span><br><span class="line">&#125;CSNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Count</span><span class="params">(CSNode T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;firstchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Count(T-&gt;firstbro)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Count(T-&gt;firstchild) + Count(T-&gt;firstbro);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树用孩子兄弟表示法存储，求其高度"><a href="#树用孩子兄弟表示法存储，求其高度" class="headerlink" title="树用孩子兄弟表示法存储，求其高度"></a>树用孩子兄弟表示法存储，求其高度</h4><blockquote><p>仍是采用递归的思想：将<strong>求树的高度</strong>转化为求<strong>第一子女树的高度||兄弟子树高度</strong>中的最大者。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Height</span><span class="params">(CSTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> hc = <span class="number">0</span> ,hb = <span class="number">0</span> ;</span><br><span class="line">    hc = Height(T-&gt;firstchild);</span><br><span class="line">    hb = Height(T-&gt;firstbro);</span><br><span class="line">    <span class="keyword">if</span>(hc + <span class="number">1</span> &gt; hb)&#123;</span><br><span class="line">        <span class="keyword">return</span> hc + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ol><li>双亲表示法-顺序存储</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> <span class="title">node</span>[<span class="title">max</span>];</span></span><br><span class="line">    <span class="type">int</span> n;      <span class="comment">//节点数</span></span><br><span class="line">&#125;PNode;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：可用树的存储结构存二叉树，但不能反之。<br><strong>优点</strong>：快速找到每个孩子的双亲结点，但找到孩子须遍历整个表。</p><ol start="2"><li>孩子表示法-顺序存储</li></ol><p><strong>优点</strong>：快速找到每个孩子的孩子结点，但找到双亲须遍历整个表。</p><ol start="3"><li>孩子兄弟表示法-链式存储</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element date;</span><br><span class="line">    CSTree firstchild,nextsibling;</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><p><strong>优点</strong>：方便实现<code>树-&gt;二叉树</code>的转换</p><h4 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h4><ol><li>树-&gt;二叉树</li><li>森林-&gt;二叉树</li><li>二叉树-&gt;树</li><li>二叉树-&gt;森林</li></ol><p><strong>规则</strong>：左孩子、右兄弟</p><h4 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h4><ol><li>树的遍历</li></ol><ul><li><p>先根遍历（相当于其二叉树形态的先序遍历）</p></li><li><p>后根遍历（相当于其二叉树形态的中序遍历）</p></li></ul><ol start="2"><li>森林的遍历</li></ol><ul><li><p>先序遍历（相当于其二叉树形态的先序遍历）</p></li><li><p>中序遍历（相当于其二叉树形态的中序遍历）</p></li></ul><ol start="3"><li>总结</li></ol><h3 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h3><h4 id="哈夫曼树与哈夫曼编码"><a href="#哈夫曼树与哈夫曼编码" class="headerlink" title="哈夫曼树与哈夫曼编码"></a>哈夫曼树与哈夫曼编码</h4><ol><li>几个概念</li></ol><p><img src="/img/2025_3_9/001.jpg" alt="404"></p><ul><li>路径长度：路径上的分支数目</li><li>权：结点被赋予的数</li><li><strong>结点的</strong>带权路径长度（WPL）：路径长度 * 权</li><li><strong>树的</strong>带权路径长度（WPL）：树中所有<strong>叶节点</strong>的WPL之和</li></ul><ol><li>哈夫曼树的构造过程</li></ol><p><img src="/img/2025_3_9/002.png" alt="404"><br>即两个权值最小的点结合，结合后的点作为其和仍参与比较</p><ol start="3"><li>哈夫曼树的性质</li></ol><p><img src="/img/2025_3_9/003.png" alt="404"></p><ol start="4"><li>哈夫曼编码</li></ol><ul><li>固定长度编码：对每个字符使用<strong>相等</strong>长度的二进制位</li><li>可变长度编码：对每个字符使用<strong>不等</strong>长度的二进制位</li><li>前缀编码：没有一个编码是另一个编码的前缀（确定性）</li><li>与定长编码的比较<br><img src="/img/2025_3_9/004.png" alt="404"></li></ul><blockquote><p>左右分支0\1没有明确规定等情况，会出现构造<strong>不唯一的哈夫曼树</strong>的情况，虽然这些哈夫曼树不唯一，但是它们的WPL是相同的且为最优。</p></blockquote><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>数组形式的集合，初始默认值为<code>-1</code>。当其值<code>&gt;=0</code>时，代表的是父节点<em>不是双亲</em>的数组下标；当其值<code>&lt;0</code>时，其绝对值为孩子<code>+1</code></p><ol><li>基本实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  结构定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> S[])</span>&#123; <span class="comment">// 传地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i&lt;SIZE ; i++)&#123;</span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Find-查找某个元素的根</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(d)；d为树的深度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        x = S[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Union-合并两个集</span></span><br><span class="line"><span class="comment">// 时间复杂度为O(1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2)  <span class="keyword">return</span>;     <span class="comment">//不操作</span></span><br><span class="line">    S[Root2] = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Union操作的优化</li></ol><blockquote><p>极端情况下，n个元素构成的树的最大深度为n，则find的时间复杂度为O(n)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Root1 == Root2)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[Root1] &lt; S[Root2])&#123;</span><br><span class="line">        S[Root1]+=S[Root2];</span><br><span class="line">        S[Root2] = Root1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        S[Root2]+=S[Root1];</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用以上这种方法构造的集合树，深度不超过logn的向下取整+1</p><ol start="3"><li>改进的find操作</li></ol><p>即将欲找到的结点路径上的所有结点（包括它），都挂载到根上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fine</span><span class="params">(<span class="type">int</span> S[] , <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> root = x ;  <span class="comment">//root代表根</span></span><br><span class="line">    <span class="keyword">while</span>(S[root] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        root = S[root];</span><br><span class="line">    &#125;<span class="comment">// 找到根节点</span></span><br><span class="line">    <span class="keyword">while</span>(x != root)&#123;</span><br><span class="line">        <span class="type">int</span> t = S[x];   <span class="comment">//t指向x的父节点</span></span><br><span class="line">        S[x] = root;    <span class="comment">//x挂载到根下</span></span><br><span class="line">        x = t ;     <span class="comment">//更新x的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Vue+DeepSeekAPI的在线AI问答</title>
      <link href="/2025/02/26/%E5%9F%BA%E4%BA%8EVue-DeepSeekAPI%E7%9A%84%E5%9C%A8%E7%BA%BFAI%E9%97%AE%E7%AD%94/"/>
      <url>/2025/02/26/%E5%9F%BA%E4%BA%8EVue-DeepSeekAPI%E7%9A%84%E5%9C%A8%E7%BA%BFAI%E9%97%AE%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><ol><li><p>什么是Flask<br>Flask是一个非常小的PythonWeb框架；Flask 被称为”微框架”，因为它使用简单的核心，得用扩展增加其他功能。</p></li><li><p>如何安装</p></li></ol><ul><li>使用命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure><p>来查看当前的python版本，需要满足其大于3.6</p><ul><li>使用python的包安装工具pip安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Flask</span><br></pre></td></tr></table></figure><ul><li>验证是否安装成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show Flask</span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ol><li>什么是Nginx<br>Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器</li></ol><ul><li><p>正向代理与反向代理</p><ol><li>正向代理：是一个位于客户端与目标服务器之间的服务器（即代理服务器），即实现对客户端请求的转发与目标服务器响应的转发。</li></ol><p>  在访问境外网站时，用户可以使用正向代理技术。<br>  <img src="/img/2025_2_28/001.png" alt="404"><br>  通过正向代理服务器来访问目标服务器，目标服务器并不知道用户的ip，也不知道访问自己的是一个代理<br>  2. 正向代理的用途</p><ul><li>突破访问限制：访问国外网络</li><li>提高访问速度：代理服务器中配置有较大的硬盘缓冲区，用户通过代理访问某资源后，该资源会将部分信息缓存在代理服务器中，为了用户以后再次读取</li><li>隐藏客户端真实IP：免受攻击</li></ul><ol start="3"><li>反向代理：代理服务器来代理目标服务器，接受用户请求，将请求转发给目标服务器，并将结果返回给用户。<br>  <img src="/img/2025_2_28/004.png" alt="404"><br>  这时候，用户不知道真正的目标服务器是谁，也不知道自己访问的是一个代理</li><li>反向代理的用途</li></ol><ul><li>隐藏服务器真实IP</li><li>负载均衡：根据所有真实服务器的负载情况，把请求发送到不同真实服务器上</li><li>提高访问速度：同上</li><li>提供安全保障：反向代理可作为应用层的防火墙，为网站提供对基于Web的攻击行为（例如DoS&#x2F;DDoS）的防护。</li></ul><ol start="5"><li>总结</li></ol><ul><li>正向代理是客户端架设的；反向代理是服务器架设的。</li></ul></li></ul><ol start="2"><li>什么是Axios<ol><li>Axios 是一个流行的 <code>JavaScript 库</code>，用于在 Web 浏览器和 <code>Node.js</code> 中发起 <code>Http 请求</code>和处理响应。</li></ol></li></ol><h2 id="2025-2-26："><a href="#2025-2-26：" class="headerlink" title="2025-2-26："></a>2025-2-26：</h2><p>在deepseek上充值API额度，使用python程序在本地调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填写你的 API Key</span></span><br><span class="line">API_KEY = <span class="string">&quot;*************************&quot;</span>  </span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://api.deepseek.com/chat/completions&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Authorization&quot;</span>: <span class="string">f&quot;Bearer <span class="subst">&#123;API_KEY&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;model&quot;</span>: <span class="string">&quot;deepseek-chat&quot;</span>,  <span class="comment"># 指定使用 R1 模型（deepseek-reasoner）或者 V3 模型（deepseek-chat）</span></span><br><span class="line">    <span class="string">&quot;messages&quot;</span>: [</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是一个专业的助手&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;你是谁？&quot;</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;stream&quot;</span>: <span class="literal">False</span>  <span class="comment"># 关闭流式传输</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, headers=headers, json=data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    result = response.json()</span><br><span class="line">    <span class="built_in">print</span>(result[<span class="string">&#x27;choices&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;message&#x27;</span>][<span class="string">&#x27;content&#x27;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求失败，错误码：&quot;</span>, response.status_code)</span><br></pre></td></tr></table></figure><p>运行程序使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python filename.py</span><br></pre></td></tr></table></figure><p>根据上面代码，得出运行代码是在向AI提问“你是谁”</p><h2 id="2025-2-27"><a href="#2025-2-27" class="headerlink" title="2025-2-27"></a>2025-2-27</h2><h2 id="站长工具"><a href="#站长工具" class="headerlink" title="站长工具"></a>站长工具</h2><p><a href="https://tool.chinaz.com/">404</a></p><p>功能：对网站全方位查询，例如检测是否被墙</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Vue </tag>
            
            <tag> DeepSeek </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客增加豆瓣个人界面</title>
      <link href="/2025/02/25/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%B1%86%E7%93%A3%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/"/>
      <url>/2025/02/25/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%B1%86%E7%93%A3%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hexo添加豆瓣个人页面"><a href="#Hexo添加豆瓣个人页面" class="headerlink" title="Hexo添加豆瓣个人页面"></a>Hexo添加豆瓣个人页面</h2><ol><li>安装<code>hexo-douban</code>插件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-douban --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>在博客站点的配置文件<code>_config.yml</code>中添加以下内容</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">douban:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">xxxx</span>  <span class="comment"># 豆瓣ID，https://www.douban.com/people/xxxxxx/&quot; ，其中的”xxxxxx”就是个人ID。（只包含数字）</span></span><br><span class="line">  <span class="attr">builtin:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;标题名字&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;首界面显示一句话&#x27;</span></span><br><span class="line">  <span class="attr">movie:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;那标题名字&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;首界面显示一句话&#x27;</span></span><br><span class="line">  <span class="attr">game:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">&#x27;标题名字&#x27;</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">&#x27;首界面显示一句话&#x27;</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10000</span> <span class="comment"># 超时的时间，单位是毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 是否将生成页面的功能嵌入hexo s和hexo g中，默认是false,另一可选项为true。</span></span><br><span class="line">    <span class="comment"># 如果配置了builtin参数为true，那么除了可以使用hexo douban命令之外，hexo g或hexo s也内嵌了生成页面的功能。</span></span><br><span class="line">    <span class="comment"># 原来的hexo d变得模棱两可，需要使用hexo deploy</span></span><br></pre></td></tr></table></figure><p><a href="https://www.douban.com/">豆瓣网链接</a></p><ol start="3"><li>如果上面的配置都没有问题，就可以使用以下地址访问</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/books</span><br><span class="line">http://localhost:4000/movies</span><br><span class="line">http://localhost:4000/games</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时books、movies、games不需要使用hexo new page xxx来创建，配置hexo-douban后会自动创建。</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在导航栏中添加相应的选项</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line"><span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line"><span class="attr">Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line"><span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line"><span class="string">List||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">  <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line"><span class="attr">Link:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line"><span class="attr">About:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>默认子目录是展开的，如果你想要隐藏，在子目录里添加 hide 。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">List||fas</span> <span class="string">fa-list||hide:</span></span><br><span class="line">  <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">  <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-串</title>
      <link href="/2025/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/"/>
      <url>/2025/02/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="串（String）"><a href="#串（String）" class="headerlink" title="串（String）"></a>串（String）</h2><h3 id="逻辑结构：受限线性表"><a href="#逻辑结构：受限线性表" class="headerlink" title="逻辑结构：受限线性表"></a>逻辑结构：受限线性表</h3><h3 id="存储结构："><a href="#存储结构：" class="headerlink" title="存储结构："></a>存储结构：</h3><h4 id="定长顺序存储表示"><a href="#定长顺序存储表示" class="headerlink" title="定长顺序存储表示"></a>定长顺序存储表示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[Max];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><h4 id="堆分配存储表示"><a href="#堆分配存储表示" class="headerlink" title="堆分配存储表示"></a>堆分配存储表示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h4 id="链式存储表示"><a href="#链式存储表示" class="headerlink" title="链式存储表示"></a>链式存储表示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size被自定义，表示一个结构体中存放多少个字符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> size 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[size];</span><br><span class="line">    LString *next;</span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure><h4 id="堆分配存储表示的详解"><a href="#堆分配存储表示的详解" class="headerlink" title="堆分配存储表示的详解"></a>堆分配存储表示的详解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; HString;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initHString</span><span class="params">(HString *str, <span class="type">const</span> <span class="type">char</span> *source)</span> &#123;</span><br><span class="line">    str-&gt;length = <span class="built_in">strlen</span>(source);</span><br><span class="line">    str-&gt;ch = (<span class="type">char</span> *)<span class="built_in">malloc</span>((str-&gt;length + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>)); <span class="comment">// 分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (str-&gt;ch == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(str-&gt;ch, source); <span class="comment">// 复制字符串内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeHString</span><span class="params">(HString *str)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(str-&gt;ch); <span class="comment">// 释放内存</span></span><br><span class="line">    str-&gt;ch = <span class="literal">NULL</span>;</span><br><span class="line">    str-&gt;length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HString myString;</span><br><span class="line">    initHString(&amp;myString, <span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;String: %s\n&quot;</span>, myString.ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Length: %d\n&quot;</span>, myString.length);</span><br><span class="line"></span><br><span class="line">    freeHString(&amp;myString); <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!(&#x2F;img&#x2F;2025_3_16&#x2F;001.png)</p><h3 id="串的简单模式匹配"><a href="#串的简单模式匹配" class="headerlink" title="串的简单模式匹配"></a>串的简单模式匹配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">SMatch</span><span class="params">(<span class="type">char</span> a[], <span class="type">char</span> b[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *ptra = a;</span><br><span class="line">    <span class="type">char</span> *temp = ptra;</span><br><span class="line">    <span class="type">char</span> *ptrb = b;</span><br><span class="line">    <span class="keyword">while</span> (*ptra != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        temp = ptra;</span><br><span class="line">        ptrb = b;</span><br><span class="line">        <span class="keyword">while</span> (*ptra == *ptrb &amp;&amp; *ptrb != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            ptra++;</span><br><span class="line">            ptrb++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*ptrb == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptra = temp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> a[] = <span class="string">&quot;ijijij&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[] = <span class="string">&quot;ijijij&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Com(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单模式匹配算法的时间复杂度为O(mn)</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ol><li>字符串的前缀、后缀与部分匹配值</li></ol><p><img src="/img/2025_3_19/001.png" alt="404"><br>此方法作为为手算Next数组的方法的理论来源</p><ol start="2"><li><p>KMP算法旨在减少主串与辅串回溯的次数，降低算法的时间复杂度。核心是利用匹配失败后的信息。</p></li><li><p>假设主串S的长度为m，辅串T的长度为n，理论上最坏情况下迭代<code>m-n+1</code>轮，同时每轮进行<code>n</code>次比对，一共比较了<code>(m-n+1)*n</code>次，当<code>m&gt;&gt;n</code>时，时间复杂度为<code>O(m*n)</code>。KMP算法可将时间复杂度降低为<code>O(m+n)</code>。</p></li><li><p>如何求next数组</p></li></ol><ul><li><code>next[j] = -1</code>：<code>j = 0</code>。表示如果辅串第一个字符不匹配，则主串指针递增，辅串指针不变。</li><li><code>next[j] = x</code>:<code>x = 最长相等前后缀长度</code>。为什么要取最长？这样想，若next值尽量的大，则说明前面已经匹配的越多，那么辅串向后移动的位数也越少，如果不取最大值，引发辅串向后移动位数太多，<strong>可能</strong>会错过匹配的选项。主串指针改变，辅串指针改变。</li><li><code>next[j] = 0</code>：<code>其他情况</code>。最坏情况下，从辅串第一个字符开始比较。主串指针不变，辅串指针该变。</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">match</span> <span class="params">(<span class="type">char</span>* P, <span class="type">char</span>* S)</span></span>&#123; <span class="comment">// KMP 算法</span></span><br><span class="line">    <span class="type">int</span>* next = <span class="built_in">buildNext</span>(P); <span class="comment">// 构造 next 表</span></span><br><span class="line">    <span class="type">int</span> m = (<span class="type">int</span>) <span class="built_in">strlen</span> (S), i = <span class="number">0</span>; <span class="comment">// 文本串指针</span></span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>) <span class="built_in">strlen</span>(P), j = <span class="number">0</span>; <span class="comment">//模式串指针</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n &amp;&amp; i &lt; m) <span class="comment">// 自左向右逐个比对字符</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; j || S[i] == P[j]) <span class="comment">// 若匹配，或 P 已移除最左侧</span></span><br><span class="line">            &#123;i++; j++;&#125; <span class="comment">// 则转到下一字符</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">// 模式串右移（注意：文本串不用回退）</span></span><br><span class="line">    <span class="keyword">delete</span> [] next; <span class="comment">// 释放 next 表</span></span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求Next数组</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">buildNext</span><span class="params">(<span class="type">char</span>* P)</span> </span>&#123; <span class="comment">// 构造模式串 P 的 next 表</span></span><br><span class="line">    <span class="type">size_t</span> m = <span class="built_in">strlen</span>(P), j = <span class="number">0</span>; <span class="comment">// “主”串指针</span></span><br><span class="line">    <span class="type">int</span>* N = <span class="keyword">new</span> <span class="type">int</span>[m]; <span class="comment">// next 表</span></span><br><span class="line">    <span class="type">int</span>  t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 模式串指针</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t])&#123; <span class="comment">// 匹配</span></span><br><span class="line">            j++; t++;</span><br><span class="line">            N[j] = t; <span class="comment">// 此句可改进为 N[j] = (P[j] != P[t] ? t : N[t]);</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="comment">// 失配</span></span><br><span class="line">        t = N[t];</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考文献<br><a href="https://leetcode.cn/leetbook/read/array-and-string/cpoo6/">leetcode关于KMP的图片粗略解释</a><br>王道计算机考研2025版本</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自行车中长途骑行赛博log</title>
      <link href="/2025/02/22/%E8%87%AA%E8%A1%8C%E8%BD%A6%E4%B8%AD%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C%E8%B5%9B%E5%8D%9Alog/"/>
      <url>/2025/02/22/%E8%87%AA%E8%A1%8C%E8%BD%A6%E4%B8%AD%E9%95%BF%E9%80%94%E9%AA%91%E8%A1%8C%E8%B5%9B%E5%8D%9Alog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="自行车中长途骑行赛博log"><a href="#自行车中长途骑行赛博log" class="headerlink" title="自行车中长途骑行赛博log"></a>自行车中长途骑行赛博log</h2><p><img src="/img/2025_2_22/006.png" alt="404"></p><h2 id="“工欲善其事，必先利其器”"><a href="#“工欲善其事，必先利其器”" class="headerlink" title="“工欲善其事，必先利其器”"></a>“工欲善其事，必先利其器”</h2><p>周五上午需要上课，中午午休一会儿，下午2:00左右出发，太阳6点多落山。根据以上条件，我将理论时间控制在4小时左右，<em>（事实证明这样是错的，就像愚蠢的土拨鼠）</em>，于是我在新乡市获嘉县与沁阳市中选择了路线较不复杂繁琐的前者。午休过后，带好必要的装备：头盔、眼镜、码表、护罩等，便出发了。</p><p>天空灰蒙蒙的，像是镀了层薄薄的灰色珐琅，校园里也安静的出奇，只听见轮胎摩擦大地发出的哧哧声。</p><h2 id="“别墅区”"><a href="#“别墅区”" class="headerlink" title="“别墅区”"></a>“别墅区”</h2><p><img src="/img/2025_2_22/007.png" alt="404"><br>在医保主题公园（很奇怪，地图上并不显示这个公园）附近，有一排农村自建房，咋一看好像不足为奇，但当我定睛细看时，不得不发出惊叹，特别是黄色的房子，兼具现代艺术与居住舒适性，除了地理位置有些偏僻，其他方面堪称完美。等我长大也想住在这样的房子里，但是考虑到孩子上学，还是得住在城里，“鱼与熊掌不可兼得”，为了自己居住条件的自我认为的完美而耽搁了孩子的教育，得不偿失。</p><h2 id="“中道的抉择”"><a href="#“中道的抉择”" class="headerlink" title="“中道的抉择”"></a>“中道的抉择”</h2><p><img src="/img/2025_2_22/001.png" alt="404"><br>在快走到目的地时，辅路突然变窄，主路为单向双车道，而且伴随着重卡的频繁呼啸而过。<strong>道路千万条，安全第一条</strong>，骑行者对路况安全不以为意、漠不关心而导致的车毁人亡事件数不胜数。一件件安全警示路镌刻在历史的里程碑上，如同悬挂在其他骑行者头上的达摩克利斯之剑。正所谓唐太宗李世民之言：以人为鉴，方可明得失。骑友的惨痛教训启示着我，我还应该继续向前吗？但是终点就在不远处，岂能为了潜在可能的风险，而背弃这次出发的初衷吗？</p><p>我思来想去，觉得还是回去稳妥，毕竟三十六计 ，走为上计嘛。深层原因是认为冒着生命危险，去追求并非如此有价值的目的地，得不偿失。</p><p>于是我便重整旗鼓，再次出发。碰见一个路口，我想着，<strong>再往前走走吧，下一个路口再掉头</strong>，又走了一小会儿后，路变得十分宽敞。这里引用《桃花源记》中形容桃花源的一句话：初极狭，才通人。复行数十步，豁然开朗。于是我便一鼓作气，直怼终点。</p><h2 id="“公园刺客”"><a href="#“公园刺客”" class="headerlink" title="“公园刺客”"></a>“公园刺客”</h2><p>地图上显示的两个大公园，其中一个公园，围墙很高，而且上面缠绕着铁丝网，这是“公园”，还是“攻园”呢？我环绕其一周，发现它被铁门禁锢着，不让任何人进去，里面也没开发。哎，被刺到了。第二个公园很好，但也只是相比前一个而言，当然要是说它们根本没有可比性的话，也基本上是中肯之言。同样绕其一周，可以说是平平无奇的塑胶场地、淡淡的湖水、未开发的小土路；也可以说是塑胶场地上男孩们踢足球肆意挥洒着汗水，彰显着舞动的靓丽青春、是落日映照着湖水，凸显着水面上波光粼粼的魅影，落霞与孤鹜齐飞，秋水共长天一色、是山地车驰骋在泥土路上，扬起飞天的尘埃，心情随着大地的跳动而澎湃涌动。</p><p>黄昏携带者一丝暮色，落日余晖的金光透过树叶的缝隙，星星点点的星光洒在林荫道上，沉淀的芳香也弥漫在一往无前的路上，而每一道星光也照亮了通往未来的方向。</p><p><img src="/img/2025_2_22/002.png" alt="404"><br><img src="/img/2025_2_22/003.png" alt="404"><br><img src="/img/2025_2_22/004.png" alt="404"></p><h2 id="“老板的恩惠”"><a href="#“老板的恩惠”" class="headerlink" title="“老板的恩惠”"></a>“老板的恩惠”</h2><p>骑到修武的一家批发超市前，实在是精疲力尽，宛如“行尸走肉”，我就停下去买水。我向其索要热水，老板竟让我选饮料，然后他再接盆热水加热，我向他连声道谢。之后便等待加热的完成，几分钟后，老板说好了，由于水热，他手也热，便让手凉的我拿出来。这时我注意到了一个细节，他的妻子也想试着拿出来!看到这一幕，我是很感动的。本可袖手旁观，熟视无睹，却选择伸出援手，做出力所能及之事。在任何时代，善良极其稀少，但它永远存在，代表着人性的真、善、美。<br><img src="/img/2025_2_22/005.png" alt="404"></p><h2 id="“黎明前的黑暗”"><a href="#“黎明前的黑暗”" class="headerlink" title="“黎明前的黑暗”"></a>“黎明前的黑暗”</h2><p>最后10km着实骑不动了，乳酸在大腿处疯了似地翻涌，肌肉也在发出痛苦的哀嚎，努力的想呼一大口气，却也用尽了全身的力气。四周望去，便是无尽的黑暗，空气中弥漫着湿冷的雾气，心中更加觉得渺茫。由黑暗中漫步，再堕入黑暗中去。不骑不行啊，又没人渡我回校。克莱尔•麦克福尔的著作《摆渡人》的封皮上写道：如果命运是一条孤独的河流，谁会是你的摆渡人呢？我想，最好的摆渡人，就是自己。道阻且长，行则将至；行而不辍，未来可期。</p><p>但这次黑暗中骑行并不理想，冷且不安全。</p><h2 id="“骑行运动没有保质期”"><a href="#“骑行运动没有保质期”" class="headerlink" title="“骑行运动没有保质期”"></a>“骑行运动没有保质期”</h2><p>认准了一项爱好，就坚持下去。我认为骑行有以下好处：</p><ul><li>强化腿部肌肉，提升自身耐力。对身体大有裨益。</li><li>满足自己对陌生远方城市的好奇心。因为自己总对未知的事物感到好奇，便有着强烈的欲望去探索它。</li><li>放松自己。骑行回来累了，也就不做其它杂七杂八的事情了，老老实实地休息了，也不想入非非了。</li><li>人脉了扩充。得益于骑行，我认识了大创得国奖的同学、对骑行有着丰富经验的骑手等等优秀的人，有时候我们慢悠悠地骑行，彼此聊聊天，这也是一种学习的形式。<br><img src="/img/2025_2_22/008.png" alt="404"></li></ul><h2 id="“启示录”"><a href="#“启示录”" class="headerlink" title="“启示录”"></a>“启示录”</h2><p>不能只考虑理论时间，充分结合自身情况，才能做出最正确的选择。</p><p>希望自己能再把骑行这份爱好坚持下去，使之成为终身爱好而非仅仅时大学爱好，读万卷书，行万里路。</p><p>人在闲散的状态中，在懒惰的习性里，在欲望的驱使下，及其容易剑走偏锋，若不懂得自省，总将会迷失人生的路，也迟早会为此付出代价。与其冒着滋生不确定性的风险，不如过早的将其扼杀。（说的严重了，我也并不勤快，这里只作‘理论上的表述’）</p><img src="/img/2025_2_22/009.jpg" alt="404" width="70%">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 骑行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言相关知识点（持续更新）</title>
      <link href="/2025/02/19/C%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2025/02/19/C%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本章内容持续收录C语言的一些知识点</p></blockquote><h2 id="表达式必须是可以修改的左值"><a href="#表达式必须是可以修改的左值" class="headerlink" title="表达式必须是可以修改的左值"></a>表达式必须是可以修改的左值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">a + b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>表达式 a + b 不是一个左值，因为它不能被修改。如果您尝试将 a + b 赋值为 3，则会收到一个编译错误，提示“表达式必须是可以修改的左值”。</p><h2 id="指针与指向指针的指针"><a href="#指针与指向指针的指针" class="headerlink" title="指针与指向指针的指针"></a>指针与指向指针的指针</h2><p>由于C语言的函数传值机制，修改值需要用指针。而修改指针就得用指向指针的指针（**）。—以单链表的初始化为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(LinkNode** l)</span> &#123;</span><br><span class="line">    LinkNode* p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    *l = p;</span><br><span class="line">    (*l)-&gt;data = <span class="number">98</span>;</span><br><span class="line">    (*l)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    LinkNode* r;</span><br><span class="line">    init(&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, r-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针一般用于顺序存储结构，指向指针的指针一般用于链式存储结构。</p><p>对于链式结构还可以通过返回指针来构建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkNode* p = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">// 动态分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data = <span class="number">3</span>;   <span class="comment">// 初始化数据</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;      <span class="comment">// 返回头节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    LinkList r = init();  <span class="comment">// 初始化头节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r-&gt;data);  <span class="comment">// 输出头节点的数据</span></span><br><span class="line">    <span class="built_in">free</span>(r);                <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接初始化传入的头结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(LinkNode* l)</span> &#123;</span><br><span class="line">    l-&gt;data = <span class="number">3</span>;   <span class="comment">// 直接初始化传入的头节点</span></span><br><span class="line">    l-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    LinkNode r;    <span class="comment">// 定义一个头节点</span></span><br><span class="line">    init(&amp;r);      <span class="comment">// 初始化头节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r.data);  <span class="comment">// 输出头节点的数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux课程总结（持续更新中）</title>
      <link href="/2025/02/18/Linux%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
      <url>/2025/02/18/Linux%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>前言：启动某个程序:查找程序在硬盘上安装位置，然后将其加载到内存运行。真正能控制硬件(CPU,显示器,内存)的只有OS kernel。但由于安全,复杂等原因用户不能直接接触内核，则在user与kernel增加一层“代理”（UI与命令行程序）。来接收用户操作,简单处理后传给 kernel。</p><ol><li>Shell是一个命令行程序,连接user与Linux kernel，让user更高效用Linux kernel。运行一个命令，大部分情况下Shell都会调用内核暴露出来的接口。这就是在使用内核。</li><li>Shell也支持编程。Shell也是一种脚本语言(Script),解释型语言的别称是脚本语言(Script)。</li></ol><h3 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h3><ol><li>核心版本</li><li>发行版本</li></ol><h3 id="Shell与Bash"><a href="#Shell与Bash" class="headerlink" title="Shell与Bash"></a>Shell与Bash</h3><ul><li>Shell</li></ul><p>Shell 是用户与操作系统内核之间的接口，允许用户通过输入命令与系统交互。它可以是命令行界面（CLI）或图形用户界面（GUI），但通常指 CLI。Shell 接收用户输入的命令，解释并执行它们。</p><ul><li>Bash</li></ul><p>Bash（Bourne Again Shell）是 Shell 的一种，由 Brian Fox 为 GNU 项目开发。它基于 Bourne Shell（sh），增加了更多功能，如命令行编辑、命令历史、脚本编程等。Bash 是许多 Linux 发行版的默认 Shell。</p><p>区别</p><ul><li>定义：</li></ul><p>Shell 是用户与操作系统交互的接口。</p><p>Bash 是 Shell 的一种实现。</p><ul><li>功能：</li></ul><p>Shell 提供基本的命令解释和执行功能。</p><p>Bash 在 Shell 的基础上增加了更多高级功能，如命令行编辑、命令历史等。</p><ul><li>兼容性：</li></ul><p>Shell 通常指 Bourne Shell（sh）。</p><p>Bash 兼容 sh，并扩展了更多功能。</p><ul><li>使用场景：</li></ul><p>Shell 适用于基本的命令行操作。</p><p>Bash 更适合复杂的脚本编写和交互式使用。</p><h3 id="Shell命令与Bash命令"><a href="#Shell命令与Bash命令" class="headerlink" title="Shell命令与Bash命令"></a>Shell命令与Bash命令</h3><ol><li>Shell 命令</li></ol><p>Shell 命令 是指通过 Shell（命令行解释器）执行的命令。</p><p>Shell 是一个统称，包括多种不同的 Shell 实现，比如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bash（Bourne Again Shell）</span><br><span class="line"></span><br><span class="line">sh（Bourne Shell）</span><br><span class="line"></span><br><span class="line">zsh（Z Shell）</span><br><span class="line"></span><br><span class="line">csh（C Shell）</span><br><span class="line"></span><br><span class="line">fish（Friendly Interactive Shell）</span><br></pre></td></tr></table></figure><p>无论你使用哪种 Shell，都可以执行一些基本的命令，比如 ls、cd、echo 等。这些命令是 Shell 通用的。</p><ol start="2"><li>Bash 命令</li></ol><p>Bash 命令 是特指在 Bash Shell 中执行的命令。<br>Bash 是 Shell 的一种，因此 Bash 命令也是 Shell 命令的一部分。<br>Bash 支持一些额外的功能和语法，比如：</p><ul><li>命令行编辑（使用方向键修改命令）</li><li>命令历史（通过 history 查看）</li><li>更强大的脚本编程功能（如数组、条件判断、循环等）:例如，${VAR:-default} 这种语法是 Bash 特有的，其他 Shell 可能不支持。</li></ul><ol start="3"><li>为什么容易混淆？</li></ol><p>因为 Bash 是目前最常用的 Shell，很多人默认使用的就是 Bash，所以经常把“Shell 命令”和“Bash 命令”混为一谈。<br>如果你在 Linux 或 macOS 的终端中输入命令，大概率是在 Bash 中运行的，所以你会觉得“Shell 命令”和“Bash 命令”是一回事。</p><ol start="4"><li>如何区分？</li></ol><p>如果你在写脚本或执行命令时，使用的是 Bash 特有的功能（比如 [[ ]] 条件判断、${VAR} 变量扩展等），那么这些就是 Bash 命令。<br>如果你使用的是非常基础的命令（比如 ls、cd、echo），这些是 Shell 命令，几乎所有的 Shell 都支持。</p><ol start="5"><li>总结</li></ol><p>Shell 命令 是通用的，适用于所有 Shell。</p><p>Bash 命令 是 Shell 命令的一部分，特指 Bash 支持的命令和语法。</p><p>如果你不确定自己用的是哪种 Shell，可以运行以下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$SHELL</span> <span class="comment">#如果显示 /bin/bash，说明你正在使用 Bash。</span></span></span><br></pre></td></tr></table></figure><h3 id="Shell界面"><a href="#Shell界面" class="headerlink" title="Shell界面"></a>Shell界面</h3><p>Linux系统提供的命令需要在shell环境下运行，需要从图形界面进入shell界面，即<strong>终端（konsole）</strong></p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><ul><li>bash命令的一般格式：命令名+选项+参数</li><li>正常执行后返回0，否则返回非零值（通过命令$?）查看</li><li>一行放不下，用反斜杠\来中继</li><li>连续的空格会被解释为单个空格</li></ul><h3 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h3><ol><li>who命令：显示用户名+终端名+注册时间</li><li>echo命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> i am chy</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> i    am     a      good     boy <span class="comment">#多个空格按一格</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;i    am     a      good     boy&#x27;</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>date命令：显示日期</li><li>cal命令：显示日历</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cal <span class="comment">#显示当前月份</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cal 10 <span class="comment">#显示公元10年的月份</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cal 2 2025 <span class="comment">#不言而喻</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cal Feb 2025 <span class="comment">#更洋气</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>clear命令：清屏</li><li>passwd命令：修改密码</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol><li><code>.</code>是当前目录；<code>..</code>是当前目录的父目录；使用<code>cd</code>可以切换到家目录；最上层的目录称为根目录（root），用<code>/</code>表示。</li><li>以<code>.</code>开头的是隐藏文件；以<code>-</code>开头的是普通文件；以<code>d</code>开头的是目录文件；以<code>l</code>开头的是符号链接文件。</li><li>Linux的四种文件类型<ul><li>普通文件</li><li>目录文件</li><li>设备文件（访问硬件的驱动程序(Linux 内核的一部分)的接口）</li><li>符号链接文件</li></ul></li></ol><h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><h4 id="文件显示命令"><a href="#文件显示命令" class="headerlink" title="文件显示命令"></a>文件显示命令</h4><ol><li>cat命令：显示文件、连接两个或多个文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> f1 <span class="comment">#显示f1内容</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> f1 f2 <span class="comment">#同时显示f1与f2内容</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> f1 f2 &gt; f3 <span class="comment">#把文件f1与f2中的内容合并放到f3中，如果 f3 原本有内容，执行该命令后会被完全替换，且无法恢复。使用&gt;&gt;追# 加，terminal不会显示任何事物</span></span></span><br></pre></td></tr></table></figure><p><img src="/img/2025_2_26/001.png" alt="404"></p><ol start="2"><li>more命令：每次显示一屏</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more -dc f1 <span class="comment">#-d 显示友好信息    -c 先清屏</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">more -c -10 f1 <span class="comment">#每10行显示一次，显示前先清屏</span></span></span><br></pre></td></tr></table></figure><ul><li>space：显示下一屏</li><li>enter：显示下一行</li><li>B：上一屏</li><li>Q：退出</li></ul><ol start="3"><li>less命令：同more命令<br>增强处在于：</li></ol><ul><li>使用<code>⬆</code>与<code>⬇</code>切换行</li></ul><ol start="4"><li>head命令：显示文件开头若干行（默认10）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -5 f1 <span class="comment"># 显示5行</span></span></span><br></pre></td></tr></table></figure><ol start="5"><li>tail命令：显示末尾若干行（默认10）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> +20 f1 <span class="comment"># 从文件20行显示到最后</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -c 10 f1 <span class="comment"># 显示f1最后10个字符</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f f1 <span class="comment">#The -f flag makes tail keep the file open and continuously print new lines as they are appended.</span></span></span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">To <span class="built_in">exit</span>, press Ctrl+C</span> </span><br></pre></td></tr></table></figure><ol start="6"><li>touch命令：修改指定文件时间标签或者创建一个空文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> f1 <span class="comment"># 创建文件f1</span></span></span><br></pre></td></tr></table></figure><p><img src="/img/2025_4_29/002.png" alt="404"></p><h4 id="匹配、排序、显示指定内容的命令"><a href="#匹配、排序、显示指定内容的命令" class="headerlink" title="匹配、排序、显示指定内容的命令"></a>匹配、排序、显示指定内容的命令</h4><ol><li>grep命令：查找指定的词或者短语</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -F hello f1 <span class="comment"># 在f1中查找hello所在的‘行’。-F表明此时hello为单纯字符串</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -r <span class="string">&#x27;print&#x27;</span> d1 <span class="comment"># 以递归方式查询目录d1子目录下的所有文件</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -E <span class="string">&#x27;[Mm]i || [Yy]j&#x27;</span> f1 f2 <span class="comment"># 此时字符串为正则表达式 Expression</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep -i <span class="string">&#x27;main&#x27;</span> f1 <span class="comment"># 比较时不区分大小写</span></span> </span><br></pre></td></tr></table></figure><ol start="2"><li>sort命令：排序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sort testfile </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sort</span> 命令将以默认的方式将文本文件的第一列以 ASCII 码的次序排列，并将结果输出到标准输出。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> testfile      <span class="comment"># testfile文件原有排序</span></span>  </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> testfile <span class="comment"># 重排结果</span></span>  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85  </span><br><span class="line">test 30 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span> testfile -k 2</span></span><br><span class="line">test 30  </span><br><span class="line">Linux 85 </span><br><span class="line">Hello 95  </span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>uniq命令：去重</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">uniq testfile </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> testfile      <span class="comment">#原有内容</span></span>  </span><br><span class="line">test 30  </span><br><span class="line">test 30  </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85  </span><br><span class="line">Linux 85 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uniq</span> testfile     <span class="comment">#删除重复行后的内容</span></span>  </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查文件并删除文件中重复出现的行，并在行首显示该行重复出现的次数。使用如下命令：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uniq</span> -c testfile      <span class="comment">#删除重复行后的内容</span></span>  </span><br><span class="line">3 test 30             #前面的数字的意义为该行共出现了3次  </span><br><span class="line">4 Hello 95            #前面的数字的意义为该行共出现了4次  </span><br><span class="line">2 Linux 85            #前面的数字的意义为该行共出现了2次 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当重复的行并不相邻时，<span class="built_in">uniq</span> 命令是不起作用的，即若文件内容为以下时，<span class="built_in">uniq</span> 命令不起作用：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> testfile1      <span class="comment"># 原有内容</span></span> </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85 </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85 </span><br><span class="line">test 30  </span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 方法</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sort</span>  testfile1 | <span class="built_in">uniq</span></span></span><br><span class="line">Hello 95  </span><br><span class="line">Linux 85 </span><br><span class="line">test 30</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查找和比较文件的命令"><a href="#查找和比较文件的命令" class="headerlink" title="查找和比较文件的命令"></a>查找和比较文件的命令</h4><ol><li>comm命令：比较两个已经排好序的文件（逐行比较）</li></ol><ul><li><code>-123</code>表示<strong>不显示</strong>第一列（仅在f1中出现的行）、第二列（仅在f2中出现的行）、第三列（在f1与f2中出现的行）</li></ul><ol start="2"><li>diff命令：（不要求两个文件事先排好序）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test3]# diff log2014.log log2013.log </span><br><span class="line">3c3 # 3 change 3 前者的第三行与后者的第三行</span><br><span class="line">&lt; 2014-03 # 前者</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">2013-03 <span class="comment"># 后者</span></span></span><br><span class="line">8c8</span><br><span class="line">&lt; 2013-07</span><br><span class="line">---</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">2013-08</span></span><br><span class="line">11,12d10    # 11 12 delete 10 ，前者11 12行有下面这些东西。10 为前一个文件的11 12 行的内容在第二个文件的第10行后缺失# 了</span><br><span class="line">&lt; 2013-11</span><br><span class="line">&lt; 2013-12</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/2025_4_29/003.png" alt="404"></p><ol start="3"><li>cmp命令：（发现差异会标出差异的位置）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cmp -b ex1 ex2</span></span><br><span class="line">ex1 ex2 differ:byte 1,line 1 is 144 d 43 #</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">意思是第一行第一字节不同，ex1上是e，编码144，ex2上是#</span> </span><br></pre></td></tr></table></figure><ol start="4"><li>find：（在指定的目录下查找相应的文件）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;m*.c&quot;</span> <span class="comment">#在当前目录下查找以m开头.c结尾的文件。.表示当前目录。-name 选项用于根据文件名进行匹配。</span></span></span><br></pre></td></tr></table></figure><h4 id="复制、删除和移动文件的命令"><a href="#复制、删除和移动文件的命令" class="headerlink" title="复制、删除和移动文件的命令"></a>复制、删除和移动文件的命令</h4><ol><li>cp命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> mfile /home/fox/exam1 <span class="comment"># 将mfile复制到/home/fox下，并改名为exam1</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -r /home/fox /home/cat <span class="comment"># 将目录/home/fox下所有**文件及其子目录**复制到目录/home/cat中</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -i /home/fox /home/cat <span class="comment"># i是交互式的，覆盖前会提示</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>rm命令：（删除）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -i <span class="built_in">test</span> example <span class="comment"># 交互式删除文件。test 和 example：这是要删除的两个文件名。</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -r * <span class="comment"># 递归地删除指定目录及其下属的各级子目录和相应的文件。</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -f filename  <span class="comment"># Force-delete a specific file</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> -d empty_dir  <span class="comment"># Remove an empty directory</span></span></span><br></pre></td></tr></table></figure><ul><li>if you accidentally press Enter after:<ul><li>rm -f (with no filename): The command will wait for input from stdin</li><li>rm -f * or rm -f &#x2F;: Would delete ALL files (catastrophic without backups)</li></ul></li></ul><ol><li>mv命令：（对文件或者目录重命名，或者将文件从一个目录移动到另一目录中）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> ex1 new1 <span class="comment"># 改名字</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> /home/doc/* . <span class="comment"># 把/home/doc下的所有文件移到当前目录</span></span></span><br></pre></td></tr></table></figure><h4 id="文件内容统计命令"><a href="#文件内容统计命令" class="headerlink" title="文件内容统计命令"></a>文件内容统计命令</h4><ol><li>wc命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> -clw f1 f2 <span class="comment"># -c:字节数 -l:行数 -w:字数</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> f1 <span class="comment">#同上</span></span></span><br></pre></td></tr></table></figure><h3 id="目录及其操作命令"><a href="#目录及其操作命令" class="headerlink" title="目录及其操作命令"></a>目录及其操作命令</h3><h4 id="各种目录"><a href="#各种目录" class="headerlink" title="各种目录"></a>各种目录</h4><p><img src="/img/2025_4_29/004.png" alt="404"><br><img src="/img/2025_4_29/005.png" alt="404"><br><img src="/img/2025_4_29/006.png" alt="404"></p><h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><ol><li>显示绝对路径</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>相对路径<br>相对路径不唯一</li></ol><h4 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h4><ol><li>mkdir命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> f1.txt <span class="comment"># 在当前目录下创建f1.txt</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -m 700 f1.txt <span class="comment"># Creates a directory named test under /home/helena/ with permissions set to 700.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Owner (7): rwx (Read + Write + Execute)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Group (0): --- (No permissions)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Others (0): --- (No permissions)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Fails <span class="keyword">if</span> /home/helena/ doesn’t exist (no parent directory auto-creation).</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> –pm 750 bin/os_</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Parent directories (e.g., bin/) are created with default permissions (usually 755).</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Only the target directory (os_) gets the specified 750 permissions.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>rmdir命令：<br>注意：不能在子目录下删除父目录，或者在当前目录下删除当前目录。且被删目录应为空目录。</li></ol><ul><li>-p：递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果有非空的目录，则该目录保留下来</li><li>Command to Delete Non-Empty Directories</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /path/to/dirname # R means Recursively </span><br></pre></td></tr></table></figure><ol start="3"><li>关于<code>rm -rf *</code></li></ol><p>The command rm -rf * is a powerful and dangerous Linux&#x2F;Unix command that recursively deletes all files and directories in the current working directory. </p><h4 id="改变工作目录和显示目录内容"><a href="#改变工作目录和显示目录内容" class="headerlink" title="改变工作目录和显示目录内容"></a>改变工作目录和显示目录内容</h4><ol><li>cd命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> .. <span class="comment"># 向上移动一级</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ../.. <span class="comment"># 向上移动两级 。注意这两个文件的空格</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> <span class="comment"># 切换到家目录</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> home/chen <span class="comment">#切换到home/chen</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>ls命令：（列出指定目录内容）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -F <span class="comment"># 列出当前目录内容，并标出文件属性</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/，表示目录；*，表示可执行文件；@，表示符号链接文件；|，表示管道文件；=，表示socket文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -C <span class="comment"># 以多列形式列出目录的内容（实际上跟不加C一样）</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -lai <span class="comment">#长格式、所有文件（显示隐藏文件）、显示I节点号（每个文件或目录都有一个唯一的 inode 号，用于标识文件。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Inode 号类似于文件的“身份证号”。）</span></span><br></pre></td></tr></table></figure><h4 id="链接文件的命令"><a href="#链接文件的命令" class="headerlink" title="链接文件的命令"></a>链接文件的命令</h4><ol><li><p>硬链接<br>创建的链接与原来的文件Inode号不变。</p></li><li><p>软链接<br>创建的链接与原来的文件Inode号发生改变。</p></li><li><p>区别</p></li></ol><p>符号链接（软）确实是一个新文件，它有不同的I节点号；而硬链接并没有建立新文件。<br><img src="/img/2025_4_29/007.png" alt="404"></p><ul><li>为什么硬链接不能跨文件系统？软链接为什么可以？</li></ul><p>硬链接直接指向文件的 inode（磁盘上的物理地址），而不同文件系统的 inode 编号是独立管理的，无法互相识别。<br>软链接存储的是目标文件的路径字符串（如 &#x2F;mnt&#x2F;usb&#x2F;file.txt），不依赖 inode，因此可以跨设备。</p><ul><li>为什么不允许目录硬链接？软链接可以用于目录？</li></ul><p>硬链接当工具（如 find、rm -r）遍历目录时，会进入无限循环：docs&#x2F; → backup&#x2F; → docs&#x2F; → backup&#x2F; → …<br>软链接是独立的文件，存储的是目标路径的字符串，不共享 inode。系统解析软链接时，会跳转到目标路径，不会造成循环引用。</p><ol><li>ln命令：（用来创建链接）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> a1.txt a1.txt.link <span class="comment"># -F为硬链接，默认为硬链接</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> -s a2.txt a2.txt.link <span class="comment"># -s为软链接</span></span> </span><br></pre></td></tr></table></figure><h4 id="改变文件或者目录存取权限的命令"><a href="#改变文件或者目录存取权限的命令" class="headerlink" title="改变文件或者目录存取权限的命令"></a>改变文件或者目录存取权限的命令</h4><p>Linux中有四种用户：1-当前用户(user)；2-当前用户的用户组(group)；3-其他用户(others)；4-超级管理员(root)。其次<code>all</code>代表所有用户<br>Linux中有三种权限：r-读；w-写；e-执行</p><ol><li>chmod命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> a+x ex1 <span class="comment"># 将文件ex1改为所有用户都有可执行权限</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> u=rx,g=x,o= ex1 <span class="comment"># 其他用户无权访问</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 0664 ex1 <span class="comment"># 代表 0 111 111 100 -rwx-rwx-r--</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>unmask命令：（设置新建文件的掩码，默认0022）</li></ol><ul><li>新建文件的原始权限为：0666</li><li>新建目录的原始权限为：0777</li></ul><ol><li>若设置掩码为：0022。则上述变为0666-0022&#x3D;0644；0777-0022&#x3D;0755</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置掩码默认值</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">umask</span></span></span><br><span class="line">0022</span><br></pre></td></tr></table></figure><h4 id="改变用户组和文件主的命令"><a href="#改变用户组和文件主的命令" class="headerlink" title="改变用户组和文件主的命令"></a>改变用户组和文件主的命令</h4><ol><li>chgrp</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-R：递归式，将/home/wc下的文件及其子文件的用户**组**改为chenshi</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chgrp</span> -R chenshi /home/wc</span> </span><br></pre></td></tr></table></figure><ol start="2"><li>chown<br>同上，不过是改变用户</li></ol><h4 id="联机帮助命令"><a href="#联机帮助命令" class="headerlink" title="联机帮助命令"></a>联机帮助命令</h4><ol><li>man</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看<span class="built_in">date</span>命令的用法</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">man <span class="built_in">date</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>help</li></ol><h4 id="有关进程的命令"><a href="#有关进程的命令" class="headerlink" title="有关进程的命令"></a>有关进程的命令</h4><ol><li>ps</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps</span></span><br><span class="line"></span><br><span class="line">PID TTY          TIME CMD</span><br><span class="line">2140 pts/0    00:00:00 bash</span><br><span class="line">2159 pts/0    00:00:00 ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PID：进程ID号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TTY：该进程建立时对应的终端（pts/0、pts/1、pts/2······）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TIME：占用CPU的时间，有些命令虽然运行了很长时间，但真正使用CPU的时间往往很短</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMD：执行进程的命令名。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>nice：修改进程优先级</li><li>kill：杀死进程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> 1999 <span class="comment"># 1999为PID号码</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>sleep：暂停进程</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sleep</span> 100 <span class="comment"># 暂停100秒</span></span></span><br></pre></td></tr></table></figure><h4 id="文件的压缩与解压缩"><a href="#文件的压缩与解压缩" class="headerlink" title="文件的压缩与解压缩"></a>文件的压缩与解压缩</h4><ol><li>gzip：压缩文件（默认）&#x2F;解压缩文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/chen</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip *    <span class="comment"># 将当前所有文件压缩</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip -dv *    <span class="comment"># -d解压缩；-v显示详细信息</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip -l   <span class="comment"># 列出每个压缩文件的信息，但不执行解压缩</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gzip -v --fast *  <span class="comment"># -v显示压缩比；--fast实现快速解压</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>unzip：对<code>.zip</code>文件解压缩</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip hong.zip</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unzip -v hong.zip     <span class="comment"># 显示有关压缩文件的信息，但不解压缩</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>tar：归档</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cvf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar –cvf test.tar <span class="built_in">test</span> <span class="comment"># 生成.tar文件</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c：创建（Create）新的归档文件。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v：显示详细过程（Verbose）。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f：指定归档文件名（File）。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xvf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar –xvf test.tar <span class="comment"># 将 test.tar 中的内容释放到当前目录。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-x：解包（Extract）。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-v：显示详细过程。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f：指定要解包的归档文件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -cvzf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar –cvzf test.tar.gz <span class="built_in">test</span> <span class="comment"># 将 test 文件/目录打包并 用gzip压缩，生成 .tar.gz 文件。</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-z：使用gzip压缩（Zip）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成压缩后的 test.tar.gz，体积比 .tar 更小。</span></span><br></pre></td></tr></table></figure><h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ol><li>vi是文本编辑器；vim是vi improved</li><li>在UNIX&#x2F;Linux系统中都存在vi</li><li>Linux中输入<code>vi</code>其实就是启动了<code>vim</code></li></ol><h3 id="vi的三种工作方式"><a href="#vi的三种工作方式" class="headerlink" title="vi的三种工作方式"></a>vi的三种工作方式</h3><h4 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h4><p>进入vi编辑器后，输入命令</p><ol><li>a(append)：附加命令</li><li>i(insert)：插入命令</li></ol><p>输入这些命令既由<em>命令方式</em>-&gt;<em>输入方式</em></p><h4 id="输入方式"><a href="#输入方式" class="headerlink" title="输入方式"></a>输入方式</h4><p>按下输入的键来输入</p><p>按下esc由<em>输入方式</em>-&gt;<em>命令方式</em></p><h4 id="ex转义方式"><a href="#ex转义方式" class="headerlink" title="ex转义方式"></a>ex转义方式</h4><p><code>:</code>作为ex命令提示符，后跟命令，按下delete终止执行</p><h3 id="进入与退出vi"><a href="#进入与退出vi" class="headerlink" title="进入与退出vi"></a>进入与退出vi</h3><h4 id="进入vi"><a href="#进入vi" class="headerlink" title="进入vi"></a>进入vi</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi example.c</span></span><br></pre></td></tr></table></figure><h4 id="退出vi"><a href="#退出vi" class="headerlink" title="退出vi"></a>退出vi</h4><ol><li><code>:wq</code>：保存并退出</li><li><code>:ZZ</code>：当有改动时，才写入</li><li><code>X</code>：同2</li><li><code>:q!</code>：强制退出</li></ol><h3 id="命令模式下的命令"><a href="#命令模式下的命令" class="headerlink" title="命令模式下的命令"></a>命令模式下的命令</h3><h4 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h4><ol><li><code>i</code>命令：光标在哪，就在光标处的前一位置插入</li><li><code>I</code>命令：光标在哪<strong>行</strong>，就在行首插入</li></ol><h4 id="附加命令"><a href="#附加命令" class="headerlink" title="附加命令"></a>附加命令</h4><ol><li><code>a</code>命令：光标在哪，就在光标处的后一位置插入</li><li><code>A</code>命令：光标在哪<strong>行</strong>，就在行尾插入</li></ol><h4 id="打开命令（开辟新行）"><a href="#打开命令（开辟新行）" class="headerlink" title="打开命令（开辟新行）"></a>打开命令（开辟新行）</h4><ol><li><code>o</code>：在当前行的下面新开一行</li><li><code>O</code>：在当前行的上面新开一行</li></ol><h4 id="移动光标的其他命令"><a href="#移动光标的其他命令" class="headerlink" title="移动光标的其他命令"></a>移动光标的其他命令</h4><p><img src="/img/2025_4_29/008.png" alt="404"></p><p>gg到第一行<br>G到最后一行<br>nG到第n行</p><h4 id="命令模式下移动光标"><a href="#命令模式下移动光标" class="headerlink" title="命令模式下移动光标"></a>命令模式下移动光标</h4><ol><li><p><code>l</code>;<code>Space</code>;<code>→</code>：向右移动。<br><code>3+l</code>  &#x3D;&#x3D;  <code>3+Space</code></p></li><li><p><code>h</code>;<code>BackSpace</code>;<code>←</code>：向左移动</p></li><li><p><code>k</code>;<code>↑</code>：向上移动</p></li><li><p><code>enter</code>;<code>↓</code>;<code>j</code>：向下移动</p></li></ol><h4 id="命令模式下文本修改"><a href="#命令模式下文本修改" class="headerlink" title="命令模式下文本修改"></a>命令模式下文本修改</h4><ol><li><p><code>x</code>;<code>X</code>：前者向左删除；后者向右删除<br>用法：3x</p></li><li><p><code>dd</code>：删除整行</p></li></ol><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><h4 id="光标的移动"><a href="#光标的移动" class="headerlink" title="光标的移动"></a>光标的移动</h4><ol><li><p>方向键：移动光标<br>注意：</p><blockquote><p>关于Linux下shell界面按上下左右方向键出现ABD的问题<br>这个问题有两种可能，一种是由于当前用户使用的shell是&#x2F;bin&#x2F;sh的原因。在添加用户的时候没有添加用户的指定shell类型，因此默认<br>为&#x2F;bin&#x2F;sh。<br>可以用shell类型命令：echo $SHELL 查看当前用户的shell类型，如果是&#x2F;bin&#x2F;sh，使用：chsh -s &#x2F;bin&#x2F;bash username或者使用<br>usermod -s &#x2F;bin&#x2F;bash username命令修改shell类型。<br>另一种是当前用户的shell类型是&#x2F;bin&#x2F;bash但是还是会有这个问题，这时可以在终端输入：export TERM&#x3D;linux。<br>这个是因为ubuntu的版本的TERM的问题。</p></blockquote></li><li><p>BackSpace：回退到某一位置开始重做</p></li></ol><h4 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h4><p>即输入你想输入的文本</p><h3 id="ex转义模式"><a href="#ex转义模式" class="headerlink" title="ex转义模式"></a>ex转义模式</h3><ol><li>常用命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">:20   <span class="comment"># 移动到第20行</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">:/this    <span class="comment">#  从当前行向后查找this</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">:?thils   <span class="comment"># 向前</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">: 15 , 100 d  <span class="comment"># 删除15-100行</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">: . , +5d     <span class="comment">#删除当前行和他后面的5行</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g/s1/p    <span class="comment"># 打印全文中含有s1的行</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">:%s / I / i / g <span class="comment"># s-&gt;substitute 将I换为i 且是global替换</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">:<span class="built_in">set</span> nu <span class="comment"># 设置行号</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">:<span class="built_in">set</span> nonu <span class="comment"># 取消行号</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">:n <span class="comment"># 到第n行</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Linux-Shell程序设计"><a href="#Linux-Shell程序设计" class="headerlink" title="Linux Shell程序设计"></a>Linux Shell程序设计</h2><p>之前写的大多数命令，shell都作为<strong>命令解释程序</strong>出现，下面将介绍<strong>Shell程序设计语言</strong>（默认为Bash）。</p><h3 id="Shell脚本的概述、建立与执行"><a href="#Shell脚本的概述、建立与执行" class="headerlink" title="Shell脚本的概述、建立与执行"></a>Shell脚本的概述、建立与执行</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在第一行写上<code>#!/bin/bash</code>表明下面的脚本是用Bash编写的</p><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>使用vi编辑器</p><h4 id="三种执行方式"><a href="#三种执行方式" class="headerlink" title="三种执行方式"></a>三种执行方式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash &lt; ScriptName</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bash ScriptName para1 para2 ···</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3-将shell脚本的权限设置为可执行，然后在提示符下直接执行它</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./criptName</span></span><br></pre></td></tr></table></figure><h3 id="显示与执行历史命令"><a href="#显示与执行历史命令" class="headerlink" title="显示与执行历史命令"></a>显示与执行历史命令</h3><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">history</span></span></span><br><span class="line">81 pwd</span><br><span class="line">82 history</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">历史事件号越大，表明越是最近执行的命令</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示10条</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">history</span> 10</span></span><br></pre></td></tr></table></figure><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p><img src="/img/2025_3_11/001.png" alt="404"></p><h4 id="配置历史命令环境"><a href="#配置历史命令环境" class="headerlink" title="配置历史命令环境"></a>配置历史命令环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chen12@ubuntu:~$ echo $HISTFILE</span><br><span class="line">/home/chen12/.bash_history</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：$+HISTFILE：是显示其值</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="variable">$HISTSIZE</span> = 600</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释：设置可存储600条命令</span></span><br></pre></td></tr></table></figure><h3 id="名称补全"><a href="#名称补全" class="headerlink" title="名称补全"></a>名称补全</h3><p>名称补全可以补全命令与参数，但不能补全选项</p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名用于简化输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">别名的定义</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">alias</span> ..=<span class="string">&#x27;cd ..&#x27;</span>  <span class="comment"># 注意等号间不能有空格，注意用&#x27;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">my = /home/bc     <span class="comment"># 定义变量my，并赋值</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll <span class="variable">$my</span>        <span class="comment"># my表示引用变量值      # 注意：换名是在读脚本时完成的，而非运行脚本时完成的</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消别名</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unalias</span> ll  <span class="comment"># 删除别名为ll的记录</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unalias</span> -a    <span class="comment"># 删除所有别名</span></span></span><br></pre></td></tr></table></figure><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通配符</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">* 匹配任意字符的0次、1次、多次出现</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">? 匹配任意一个字符</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[字符组]  匹配该字符组限定的任意一个字符,!（惊叹号），**注意**如果它紧跟在一对方括号的左方括号（[）之后，则表示不在一对方括号中# 所列出</span></span><br><span class="line">的字符f[!1-9].c表示以f开头，后面一个字符不是数字1-9的.c文件名。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">! 非</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*()，匹配括号内字符的0次、1次、多次出现</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">+()，匹配括号内字符的1次、多次出现</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">?()，匹配括号内字符的0次、1次出现</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">@()，匹配括号内字符的1次</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!()，非</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 注意各模式之间用|分隔开</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ll file.*(.c|.o)</span></span><br></pre></td></tr></table></figure><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><ul><li>由<code>&quot;&quot;</code>即双引号括起来的内容均当作普通字符对待。但是<code>$    \   倒引号</code>除外，<code>$</code>表示变量替换；<code>\</code>表示转义字符，后面可以跟<code>$ \ &quot; 倒引号</code>，表示后面这个字符不作特殊处理；<code>倒引号</code>表示命令替换 。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ehco <span class="string">&quot;current time is `data`&quot;</span></span></span><br><span class="line">current time is  2025年 03月 18日 星期二 20:32:43 PDT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">home=$(<span class="built_in">pwd</span>)   <span class="comment"># 等号两边不能有空格，这是shell变量赋值的要求</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;home dic is <span class="variable">$home</span>&quot;</span></span></span><br><span class="line">home dic is /home/chen12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;file*.()&quot;</span></span></span><br><span class="line">file*.()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;current &#x27;<span class="variable">$home</span>&#x27;&quot;</span></span></span><br><span class="line">current &#x27;/home/chen12&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>单引号。由单引号括起来的字符均作为普通字符（包括转义字符）出现。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">str=<span class="string">&#x27;echo &quot;directory is $home&quot;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$str</span></span></span><br><span class="line">echo &quot;directory is $home&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span>与<span class="variable">$home</span>，都失去了原有的意义</span></span><br><span class="line"></span><br><span class="line">chen12@ubuntu:~$ echo &#x27;The time is &#x27;data&#x27;,the file is $home/abc&#x27;</span><br><span class="line">The time is data,the file is $home/abc</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>倒引号。被shell解释为命令行，在执行时，会先执行命令行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">chen12@ubuntu:~$ echo current dir is `pwd`</span><br><span class="line">current dir is /home/chen12</span><br><span class="line"></span><br><span class="line">chen12@ubuntu:~$ today=`date`</span><br><span class="line">chen12@ubuntu:~$ echo today is $today</span><br><span class="line">today is 2025年 03月 21日 星期五 03:03:07 PDT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 注意嵌套使用时需要使用转义符进行转义</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">转义字符可用作续行符</span></span><br><span class="line">chen12@ubuntu:~$ 42423424\</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">2342\</span></span><br><span class="line"><span class="language-bash">&gt; 2325555</span></span><br><span class="line">4242342423422325555: command not found</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入、输出重定向符"><a href="#输入、输出重定向符" class="headerlink" title="输入、输出重定向符"></a>输入、输出重定向符</h3><p>执行一个shell命令时，通常会自动打开三个标准文件：标准输入文件、标准输出文件、标准出错输出文件。<br><img src="/img/2025_3_21/001.png" alt="404"></p><h4 id="输入重定向符"><a href="#输入重定向符" class="headerlink" title="输入重定向符"></a>输入重定向符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">score &lt; file1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">score是一个可执行程序，用C语言编写</span></span><br><span class="line"></span><br><span class="line">chen12@ubuntu:~$ vi a1.sh</span><br><span class="line">echo hhh</span><br><span class="line">echo ddd</span><br><span class="line">echo sss</span><br><span class="line">echo aaaaaa</span><br><span class="line"></span><br><span class="line">chen12@ubuntu:~$ bash &lt; a1.sh</span><br><span class="line">hhh</span><br><span class="line">ddd</span><br><span class="line">sss</span><br><span class="line">aaaaaa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">wc</span> &lt; a1.sh</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将指定文件的输出定向到某个文件中（原来的文件会被清楚，这是“覆盖式”写入）</span></span><br><span class="line">chen12@ubuntu:~$ who &gt; a1.sh</span><br><span class="line">chen12@ubuntu:~$ cat a1.sh</span><br><span class="line">chen12   :0           2025-03-21 02:55 (:0)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="输出附加定向符"><a href="#输出附加定向符" class="headerlink" title="输出附加定向符"></a>输出附加定向符</h4><p><code>&gt;&gt;</code>，原有内容不被破坏</p><h4 id="复用输入与输出重定向"><a href="#复用输入与输出重定向" class="headerlink" title="复用输入与输出重定向"></a>复用输入与输出重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">wc</span> -l &lt; infile &gt; outfile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计输入的行数,将文件 infile 的内容作为 <span class="built_in">wc</span> 的输入,将 <span class="built_in">wc</span> 的输出结果写入文件 outfile</span></span><br></pre></td></tr></table></figure><h4 id="即时文件定向符"><a href="#即时文件定向符" class="headerlink" title="即时文件定向符"></a>即时文件定向符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chen12@ubuntu:~$ grep &quot;hello&quot; &lt;&lt; eof</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hello</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">rr</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hello</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">tthello</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">eof</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">tthello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即以<span class="string">&#x27;eof&#x27;</span>开头，以<span class="string">&#x27;eof&#x27;</span>结尾</span></span><br></pre></td></tr></table></figure><p>使用即时文件定向符的好处：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">chen12@ubuntu:~$ sort</span><br><span class="line">a</span><br><span class="line">q</span><br><span class="line">w</span><br><span class="line">e</span><br><span class="line">a</span><br><span class="line">e</span><br><span class="line">q</span><br><span class="line">w</span><br><span class="line">chen12@ubuntu:~$ sort &lt;&lt; uu</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">aa</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ab</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ac</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">uu</span></span><br><span class="line">aa</span><br><span class="line">ab</span><br><span class="line">ac</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：放入即时文件比<strong>便输入数据、边处理</strong>方便。</p><h4 id="与文件描述字有关的重定向"><a href="#与文件描述字有关的重定向" class="headerlink" title="与文件描述字有关的重定向"></a>与文件描述字有关的重定向</h4><p>标准输入、标准输出、标准错误输出的文件描述字分别为0、1、2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc m1.c 2&gt; errfile</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把编译过程中产生的错误信息输出到errfile中</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：2与&gt;之间不能有Space</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">command</span> $&gt;file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等价于</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">command</span> &gt; file 2&gt;&amp; 1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实现把标准输出和标准错误输出到同一个文件中</span></span><br></pre></td></tr></table></figure><ul><li><code>command &gt; file 2&gt;&amp; 1</code>的实现逻辑<br>  <img src="/img/2025_4_29/009.png" alt="404"></li></ul><h3 id="注释、管道线、后台命令"><a href="#注释、管道线、后台命令" class="headerlink" title="注释、管道线、后台命令"></a>注释、管道线、后台命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="comment">#!后面的为绝对路径名</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l <span class="variable">$HOME</span> | <span class="built_in">wc</span> -l</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | grep m?.c | <span class="built_in">wc</span> -l</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">wc</span> -l 统计文件行数，即文件数目</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc m1.c&amp;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&amp;使之成为后台命令，仅当CPU空闲时运行后台命令</span></span><br></pre></td></tr></table></figure><p>关于<code>ls -l 与 ll</code>在ubantu上意义不同的说明：<br><img src="/img/2025_4_1/001.png" alt="404"></p><h3 id="命令操作符"><a href="#命令操作符" class="headerlink" title="命令操作符"></a>命令操作符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwd ; who ; cd /da/shd ; date</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">前面的命令执行成功与否，不影响后面程序的运行</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑与&amp;&amp;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑或||</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc m1.c &amp;&amp; <span class="built_in">echo</span> <span class="built_in">yes</span> || <span class="built_in">echo</span> no <span class="comment"># 作为命令是否执行成功的判断标志</span></span></span><br></pre></td></tr></table></figure><h3 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h3><ol><li>shell有两类变量：环境变量（永久），用户自定义变量（暂时，仅限于定义它的程序）</li></ol><h4 id="用户自定义的变量"><a href="#用户自定义的变量" class="headerlink" title="用户自定义的变量"></a>用户自定义的变量</h4><ol><li>变量名</li></ol><p>区分大小写</p><ol start="2"><li>变量赋值</li></ol><p><code>变量名=字符串</code>，注意等号两端没有空格，更改变量即重新赋值</p><ol start="3"><li>引用变量值</li></ol><p>在变量的前面加上<code>$</code>,不加会被认为是普通字符串。不赋值或者赋空值，会显示为空字符串。<br>如果含有空格之类的，需要加上双引号，否则就只识别第一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">s=ing</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> l like <span class="built_in">read</span><span class="variable">$s</span></span></span><br><span class="line">i like reading</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量的值可以作为长字符串的一部分</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为了避免混淆，也可以</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> l like <span class="built_in">read</span><span class="variable">$&#123;s&#125;</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>命令替换</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有两种形式可将命令的执行结果赋给变量</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dir</span>=`<span class="built_in">pwd</span>`</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dir</span>=$(<span class="built_in">pwd</span>)</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>bash提供一维数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">declare</span> -a arrar_name     <span class="comment"># 数组的声明</span></span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">arrar_name=(var1 var2 ...)        <span class="comment"># 或者：声明+整体赋值</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">array_name[0] = var1      <span class="comment"># 个体赋值</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;arrar_name[0]&#125;</span>     <span class="comment"># 个体输出</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;arrar_name[8]&#125;</span>      <span class="comment"># 若此项未定义，则输出空串</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;arrar_name[*]&#125;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;arrar_name[@]&#125;</span>     <span class="comment"># 这样会输出所有元素</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">unset</span> array_name[0]       <span class="comment"># 取消第0个元素的定义</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入、输出命令"><a href="#输入、输出命令" class="headerlink" title="输入、输出命令"></a>输入、输出命令</h3><ol><li>read命令</li></ol><p>read命令从键盘上读取数据，然后赋值给指定变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">read</span> a b c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入数据时，以空格或制表符为分隔符。如果输入的数据多，都算到最后一个变量上。输入数据少，则最后几个变量为空值</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">read</span> -p <span class="string">&quot;enter var&quot;</span> a</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">增加提示信息，p与后面的提示词必有</span></span><br></pre></td></tr></table></figure><ol start="2"><li>echo命令</li></ol><p>若echo命令带有参数e，则其后面的参数可有<strong>转义字符</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -e <span class="string">&quot;enter the file name-&gt;\c&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">\c 作用是光标不换行</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> -n ok</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不换行打印ok</span></span><br></pre></td></tr></table></figure><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">set</span> `<span class="built_in">pwd</span>;<span class="built_in">ls</span>;<span class="built_in">date</span>`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span>是设置位置参数的值</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$1</span> <span class="variable">$3</span> <span class="variable">$&#123;10&#125;</span> <span class="variable">$&#123;12&#125;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">shift</span>     <span class="comment"># shift移动位置参数，2变成1，3变成2等</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">shift</span> 4 <span class="comment">#相当于4个shift</span></span></span><br></pre></td></tr></table></figure><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p><code>let &quot;j=i*6+2&quot;</code>等价于<code>((j=i*6+2))</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当命令中有特殊字符时，用双引号</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">let</span> <span class="string">&quot;v=6|5&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$v</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">((v=<span class="number">6</span>|<span class="number">5</span>))</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$v</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;((12*9))&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">&quot;((12*9))&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$((12*9)</span>)&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">108</span></span><br></pre></td></tr></table></figure><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>if-then-else-fi，一个if对应一个fi</p><h4 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h4><ol><li>使用test命令</li></ol><p><code>if test -f &quot;$1&quot;</code></p><ol start="2"><li>用[]</li></ol><p><code>[ -f &quot;$1&quot; ]</code>注意中括号前后各有一个空格</p><ol start="3"><li>用[[]]</li></ol><p>同理，最好用<strong>双中括号</strong></p><ol start="4"><li>常用的文件测试符号形式与功能</li></ol><p>-e:文件存在与否<br>-f:文件存在且是普通文件<br>-d:文件存在且是目录文件</p><ol start="5"><li>字符串测试运算符形式与功能</li></ol><p>s1 &#x3D; s2:两字符串相等，注意等号左右的空格<br>s1 !&#x3D; s2:两字符串不等<br>s1 &lt; s2:字典顺序</p><ol start="6"><li>数值测试运算符形式与功能</li></ol><p>-eq<br>-ne<br>-lt<br>-le<br>-gt<br>-ge</p><p>!:非<br>-a:与<br>-o:或<br>():括号前加\使括号失去了意义</p><ol start="7"><li>番外</li></ol><p><code>command1 &amp;&amp; echo &quot;success&quot; || echo &quot;no&quot;</code>可判断命令1是否执行成功</p><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><p><img src="/img/2025_4_12/001.png" alt="404"></p><p><code>*)</code>为default<br><code>dir|path)</code>为或</p><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p><img src="/img/2025_4_12/002.png" alt="404"></p><h4 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h4><p>与while语句相反</p><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><ol><li>值表方式</li></ol><p><code>for day in Monday Friday</code></p><ol start="2"><li>算术表达式</li></ol><p><code>for ((i=1;i&lt;=$1;i++))</code></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>break;<br>continue;<br>exit;<br>select;</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[function]function_name()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中<span class="keyword">function</span>可省略</span></span><br></pre></td></tr></table></figure><h4 id="一些简单命令"><a href="#一些简单命令" class="headerlink" title="一些简单命令"></a>一些简单命令</h4><p>jobs：列出当前未完成的作业</p><p>kill：向进程发送指定信号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -9 1893</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">立刻终止PID为1893的进程</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kikk -15 1893</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">让其正常终止</span></span><br></pre></td></tr></table></figure><h4 id="两种遍历方式"><a href="#两种遍历方式" class="headerlink" title="两种遍历方式"></a>两种遍历方式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">脚本 test.sh</span></span><br><span class="line">for arg in &quot;$*&quot;; do</span><br><span class="line">    echo &quot;Argument: $arg&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">shift</span></span></span><br><span class="line">shift times</span><br></pre></td></tr></table></figure><h2 id="gcc—C语言编译系统"><a href="#gcc—C语言编译系统" class="headerlink" title="gcc—C语言编译系统"></a>gcc—C语言编译系统</h2><h3 id="gcc的编译过程"><a href="#gcc的编译过程" class="headerlink" title="gcc的编译过程"></a>gcc的编译过程</h3><p>预处理、编译、汇编、链接。</p><ol><li>预处理</li></ol><p><code>gcc -E source.c -o output.i</code><br>E为只进行预处理<br>-o output.i为指定输出文件</p><p>#include 被替换为头文件内容。</p><p>#define 宏被展开。</p><p>#ifdef &#x2F; #endif 等条件编译被处理。</p><ol start="2"><li>编译</li></ol><p><code>gcc -S source.i -o output.s</code><br>S为只进行编译</p><p>C 代码被转换为 CPU 相关的汇编指令（如 x86、ARM 等架构）。</p><ol start="3"><li>汇编</li></ol><p><code>gcc -c source.s -o output.o</code></p><p>汇编代码（如 mov, call 等）被转换为机器码（.o 文件，ELF 或 COFF 格式）。</p><ol start="4"><li>链接</li></ol><p><code>gcc source.o -o myprogram</code>  # 链接标准库</p><p>合并多个 .o 文件。</p><ol start="5"><li>一步完成</li></ol><p>gcc hello.c -o hello</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><h3 id="文件系统概念"><a href="#文件系统概念" class="headerlink" title="文件系统概念"></a>文件系统概念</h3><p>注意：之所以Linux能支持多种文件系统，是因为Linux采用虚拟文件系统技术。</p><ul><li>虚拟文件系统(Virtual File System&#x2F;VFS)是操作系统和真正的文件系统之间的接口。它将各种不同的文件系统的信息进行转化，形成统一的格式后交给Linux操作系统处理，并将处理结果还原为原文件系统格式。对于Linux而言，它所处理的是统一的虚拟文件系统，而不需要知道文件所采用的真实的文件系统。由于采用了虚拟文件系统技术，Linux支持的文件系统，包括DOS的msdos、Windows XP的fat32、光盘的iso9660，还有实现网络共享的NFS等文件系统。</li></ul><p><img src="/img/2025_4_29/001.png" alt="404"></p><h4 id="做到了什么"><a href="#做到了什么" class="headerlink" title="做到了什么"></a>做到了什么</h4><ul><li><p>当你通过 Linux 的命令（如 ls 或 cat）访问这些设备时，不需要为每种文件系统编写不同的代码。</p></li><li><p>VFS 提供统一的系统调用（如 open()、read()、write()），应用程序只需与 VFS 交互，无需关心底层文件系统的差异。</p></li></ul><h4 id="对比无-VFS-的情况"><a href="#对比无-VFS-的情况" class="headerlink" title="对比无 VFS 的情况"></a>对比无 VFS 的情况</h4><ul><li>如果没有 VFS，应用程序需要针对每种文件系统实现不同的代码路径（如 if (is_fat32) { … } else if (is_ntfs) { … }），导致复杂性和维护成本极高。</li></ul><h3 id="职位"><a href="#职位" class="headerlink" title="职位"></a>职位</h3><ol><li>前端：Vue</li><li>后端：Spring Boot</li><li>测试：测试工具</li><li>售前：demo版本</li><li>运维与交付：对客户培训</li></ol><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li>finalshell：国产远程控制Linux软件</li></ol><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ol><li>“|”是Linux管道命令操作符，简称管道符。使用此管道符“|”可以将两个命令分隔开，“|”左边命令的输出就会作为“|”右边命令的输入，此命令可连续使用，第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。</li></ol><p><img src="/img/2025_2_26/002.png" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VCD/DVD上的.dat文件转换成mp4的方法</title>
      <link href="/2025/02/16/VCD-DVD%E4%B8%8A%E7%9A%84-dat%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%88%90mp4%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2025/02/16/VCD-DVD%E4%B8%8A%E7%9A%84-dat%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E6%88%90mp4%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="点击分享的连接"><a href="#点击分享的连接" class="headerlink" title="点击分享的连接"></a>点击分享的连接</h4><p><a href="https://pan.xunlei.com/s/VO72uvxYmf6PnHxDokJjdq2hA1?pwd=u63t#">点击这里</a></p><h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>前些天姥爷让我把DVD上的视频转到硬盘里，我就答应了，弄了好一会，尝试了各种方法，都以失败告终。我索性不管了，待到离开家前往学校的前一天晚上，我突然想起来此事，于是从10点弄到12点，最终在12点在硬盘上测试通过，宣告着此次事件的成功完成。</p><p>其实这只是一件小事，但是其中有许多令我反思的地方。连我这个家庭成员曾经对家人许下的诺言，一个晚上过去，随着黎明的到来而烟消云散了，跟何况其他人呢？当成功的一刻，我很开心，因为我不想带着遗憾去上学，而这种所谓的遗憾，是我本应该很轻松完成的。</p><p>最后，再次引用王哥对我说的那句话的节选：</p><blockquote><p>希望哥们养成做事严谨的习惯</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VCD/DVD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排水工程</title>
      <link href="/2025/02/15/%E6%8E%92%E6%B0%B4%E5%B7%A5%E7%A8%8B/"/>
      <url>/2025/02/15/%E6%8E%92%E6%B0%B4%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>由于地板是水泥，下雨天水便会积水，我们便想法子，增加一根管子使其排到外面。</p></blockquote><p><img src="/img/2025_2_15/005.png" alt="404"></p><p><img src="/img/2025_2_15/006.png" alt="404"></p><p><img src="/img/2025_2_15/007.png" alt="404"></p><p><img src="/img/2025_2_15/008.png" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>南山行2025/2/15</title>
      <link href="/2025/02/15/%E5%8D%97%E5%B1%B1%E8%A1%8C2025-2-15/"/>
      <url>/2025/02/15/%E5%8D%97%E5%B1%B1%E8%A1%8C2025-2-15/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>今日登顶南山</p></blockquote><p><img src="/img/2025_2_15/001.png" alt="404"></p><p><img src="/img/2025_2_15/002.png" alt="404"></p><p><img src="/img/2025_2_15/003.png" alt="404"></p><p><img src="/img/2025_2_15/004.png" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大创经历</title>
      <link href="/2025/02/14/%E5%A4%A7%E5%88%9B%E7%BB%8F%E5%8E%86/"/>
      <url>/2025/02/14/%E5%A4%A7%E5%88%9B%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目名称：XXX项目<br>职位：项目总负责人（团队规模：5人）<br>时间：XXXX年XX月-XXXX年XX月</p><p>承接团队原定技术框架，在资源与时间受限情况下，统筹协调3名成员分工，完成了：</p><ol><li><p>路演PPT人员的筛选：我在群里发布路演演讲者招聘的通知，有4个人报名，我对他们逐一面试后，最终确定了一人，我的评判标准看是否外向。</p></li><li><p>PPT的润色修改：原来的PPT可能存在诸如排版、语句不通顺的问题。于是我在群里招募懂PPT的，有3个人来报名，我先把PPT的一小部分发给他们，然后看看谁做的好，我结合我4班的一个懂PPT的来评价，最终确定一人</p></li><li><p>财务报表修改：这个我选择了23级会计专业的，她是个女生，很负责，凌晨一点多改好后就给我发来了。</p></li><li><p>我自己：负责从头到尾的人事安排</p></li></ol><p>项目要点：</p><ul><li>定期开会：晚上抽20分钟时间，统一在计算机学院，我给他们培训，用的是我从网上找的资料，比如说该怎么演讲，怎么做PPT等。大家也都听了听，我看也都没拿本，记在手机上了。</li><li>在DDL之前几天就完成了任务，避免了到最后一刻还在修改（之前的五子棋项目亦如此）</li></ul><p>这次项目对我来说意义重大，作为一个总的项目管理者，我一开始接手项目的时候，心里非常非常茫然，一大堆资料，一大堆任务，貌似根本无从下手。同时兼顾学校与课余的其他学习任务和户外自行车运动，十分力不从心。我觉得不能这样一直拖下去，拖着也不能解决问题，反而会让问题越来越大，于是我找让我做项目的同学，向他请教，但是有趣的是，我给他发消息他却不回复我，后来才知道原来是在测试我的能力。我想，那只能我自己干了，于是我就去知乎、百度、小红书、抖音上去找—如何带好一个大创项目。记了两页笔记，然后就按其执行。最后也通过了院赛，晋级到校赛，校赛也没被刷，拿到了一个校级三等奖的奖项。</p><p>得将那一刹那，我那“失踪”的同学立马联系并祝贺我，我也很感激他。他是电气学院的，要跨考计算机，于是我们后来就一起交流学习。25年过年，我给他发了个200红包，他还很惊讶，我说“王哥，这是你应得的，我应该付出这么多”，我很感激他带我见世面。</p><p>我觉得，技术总会迭代，产品总会更新，再厉害的人也会遇到自己不能解决的问题。唯有做项目时尽责任的心，负责任的态度，敢担责任的勇气，始终会和“靠谱”这两个字绑定在一起，才能带好团队，做好项目。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎组件的添加</title>
      <link href="/2025/02/14/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0/"/>
      <url>/2025/02/14/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>今日看到某博主在个人博客中嵌入了搜索引擎，我便也试试。</p></blockquote><h4 id="使用-CSS-渐变"><a href="#使用-CSS-渐变" class="headerlink" title="使用 CSS 渐变"></a>使用 CSS 渐变</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_images/Using_CSS_gradients">点击这里</a></p><h4 id="CSS-文字特效"><a href="#CSS-文字特效" class="headerlink" title="CSS 文字特效"></a>CSS 文字特效</h4><p><a href="https://blog.csdn.net/xw1680/article/details/118065460">点击这里</a></p><h4 id="60-CSS-搜索框代码"><a href="#60-CSS-搜索框代码" class="headerlink" title="60+ CSS 搜索框代码"></a>60+ CSS 搜索框代码</h4><p><a href="https://www.webhek.com/post/free-60-css-search-box-code-snippets/">点击这里</a></p><h4 id="学习Web的小网站"><a href="#学习Web的小网站" class="headerlink" title="学习Web的小网站"></a>学习Web的小网站</h4><p><a href="https://www.webhek.com/">点击这里</a></p><h4 id="实现嵌入搜索功能的核心代码"><a href="#实现嵌入搜索功能的核心代码" class="headerlink" title="实现嵌入搜索功能的核心代码"></a>实现嵌入搜索功能的核心代码</h4><pre><code class="language-html">&lt;div class=&quot;c1&quot;&gt;    &lt;form name=&quot;a1&quot; action=&quot;https://www.bing.com/search&quot; method=&quot;GET&quot; target=&quot;_blank&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;q&quot; placeholder=&quot;请输入搜索内容&quot;&gt; &lt;!--name=&quot;q&quot; 是关键--&gt;        &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt;    &lt;/form&gt;&lt;/div&gt; </code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享几篇关于WordPress的文章</title>
      <link href="/2025/02/14/%E5%88%86%E4%BA%AB%E5%87%A0%E7%AF%87%E5%85%B3%E4%BA%8EWordPress%E7%9A%84%E6%96%87%E7%AB%A0/"/>
      <url>/2025/02/14/%E5%88%86%E4%BA%AB%E5%87%A0%E7%AF%87%E5%85%B3%E4%BA%8EWordPress%E7%9A%84%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="WordPress官网"><a href="#WordPress官网" class="headerlink" title="WordPress官网"></a>WordPress官网</h4><p><a href="https://cn.wordpress.org/">点击这里</a></p><h4 id="有哪些知名网站采用WordPress搭建？"><a href="#有哪些知名网站采用WordPress搭建？" class="headerlink" title="有哪些知名网站采用WordPress搭建？"></a>有哪些知名网站采用WordPress搭建？</h4><p><a href="https://www.wbolt.com/wordpress-site-examples.html#non-profit-wordpress-sites">点击这里</a></p><h4 id="WordPress可以搭建的19种网站类型"><a href="#WordPress可以搭建的19种网站类型" class="headerlink" title="WordPress可以搭建的19种网站类型"></a>WordPress可以搭建的19种网站类型</h4><p><a href="WordPress%E5%8F%AF%E4%BB%A5%E6%90%AD%E5%BB%BA%E7%9A%8419%E7%A7%8D%E7%BD%91%E7%AB%99%E7%B1%BB%E5%9E%8B">点击这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue入门</title>
      <link href="/2025/02/13/Vue%E5%85%A5%E9%97%A8/"/>
      <url>/2025/02/13/Vue%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>Vue是渐进式JS框架，免除JS中的DOM操作。渐进式：自底向上逐层应用，可以用Vue某层的功能，也可以与第三方库整合</li><li>用CDN方式引入Vue.js，无需本地安装</li><li>使用framework的好处，进行大型开发时方便管理与维护</li><li>数据绑定（基于MVVM思想）<ul><li>单向绑定：<code>&#123;&#123;&#125;&#125;</code>，这是插值表达式，只能从model流向view。</li><li>双向绑定：v-model，实现展示与交互</li><li>事件绑定：v-on:click</li></ul></li></ol><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>Vue-cli是Vue官方提供的一个脚手架，快速生成Vue项目模板（依赖环境Node.js）<br><img src="/img/2025_2_13/001.png" alt="404"></p><ol><li><p>创建方式 <code>npm create vue@latest</code><br>安装依赖：<code>npm i</code>，之后会出现node_modules文件夹。作用是使ts文件认识jpg、txt等类型的文件</p></li><li><p>文件解读</p></li></ol><ul><li>node_modules：项目依赖包</li><li>public：存放静态文件</li><li>src：源代码</li><li>assets：静态资源</li><li>components：可重用组件</li><li>router：路由配置</li><li>views：页面（视图组件）</li><li>main.js：入口js文件</li><li>App.vue：根组件（入口界面）</li><li>package.json：模块基本信息</li><li>vue.config.js：代理、端口等配置</li></ul><h3 id="vue文件的组成"><a href="#vue文件的组成" class="headerlink" title=".vue文件的组成"></a>.vue文件的组成</h3><ol><li><code>&lt;template&gt;</code>：模板部分，生成HTML代码</li><li><code>&lt;script&gt;</code>：定义模板的数据来源与行为</li><li><code>&lt;style&gt;</code>：CSS样式部分</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-栈与队列</title>
      <link href="/2025/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2025/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol><li><p>是只允许在一端进行插入或者删除的<strong>线性表</strong></p><blockquote><p>每接触一种新的数据结构，要从其逻辑结构，存储结构，运算三方面着手。</p></blockquote></li><li><p>n个不同元素进栈，出栈的方式有卡特兰数个。</p></li></ol><h3 id="栈的顺序存储方式"><a href="#栈的顺序存储方式" class="headerlink" title="栈的顺序存储方式"></a>栈的顺序存储方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">    ELementType data[Max];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>栈空：<code>S.top=-1</code>。栈满：<code>S.top==Max-1</code>。或者分别为<code>0与Max</code>。</p><h3 id="顺序栈的基本操作"><a href="#顺序栈的基本操作" class="headerlink" title="顺序栈的基本操作"></a>顺序栈的基本操作</h3><ol><li>初始化（设置top值）</li><li>入栈</li><li>出栈</li><li>读栈顶元素</li><li>判断空栈</li><li>销毁栈</li></ol><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol><li>队头：出队列的一端</li><li>队尾：入队列的一段</li></ol><h3 id="顺序队列的存储方式"><a href="#顺序队列的存储方式" class="headerlink" title="顺序队列的存储方式"></a>顺序队列的存储方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> element int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    element data[Max];</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line">&#125;SeQueue;</span><br></pre></td></tr></table></figure><h3 id="顺序队列的基本操作"><a href="#顺序队列的基本操作" class="headerlink" title="顺序队列的基本操作"></a>顺序队列的基本操作</h3><ol><li>初始化：front与rear都为0</li><li>判空</li><li>插入：尾指针加一</li><li>删除：头指针加一</li><li>读取队头元素</li></ol><h4 id="顺序队列的假溢出问题"><a href="#顺序队列的假溢出问题" class="headerlink" title="顺序队列的假溢出问题"></a>顺序队列的假溢出问题</h4><p>即是<code>q.rear==Max</code>时并不能说明为空</p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><ol><li>初始化：<code>q.front = q.rear = 0</code></li><li>判空：牺牲一个单元，<code>(q.rear+1)%Max == q.front</code></li><li>入队：<code>q.rear = (q.rear+1)%Max</code></li><li>出队：<code>q.front = (q.front+1)%Max</code></li><li>队列长度：<code>(q.rear+Max-q.front)%Max</code></li></ol><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><ol><li>存储类型</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">front</span>,*<span class="title">rear</span>;</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><ol start="2"><li>操作（均带有头结点）</li></ol><ul><li>初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkQueue <span class="title function_">InitQueue</span><span class="params">(LinkQueue *q)</span>&#123;</span><br><span class="line">    q-&gt;front = q-&gt;rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    q-&gt;front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>课本上使用了C++语言，这里讨论下<strong>点运算符</strong>与<strong>箭头运算符</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当 q 是一个对象（即变量本身）时，使用点运算符 . 来访问其成员。</span></span><br><span class="line"><span class="comment">//当 q 是一个指针（即指向对象的指针）时，使用箭头运算符 -&gt; 来访问其成员。</span></span><br><span class="line"><span class="comment">//两者的关系：q-&gt;front 等价于 (*q).front</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    LinkNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkQueue</span> &#123;</span><br><span class="line">    LinkNode* front;</span><br><span class="line">    LinkNode* rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 场景 1：q 是一个对象</span></span><br><span class="line">    LinkQueue q; <span class="comment">// q 是对象</span></span><br><span class="line">    q.front = <span class="literal">nullptr</span>; <span class="comment">// 使用 . 访问成员</span></span><br><span class="line">    q.rear = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 2：q 是一个指针</span></span><br><span class="line">    LinkQueue* qPtr = <span class="keyword">new</span> <span class="built_in">LinkQueue</span>(); <span class="comment">// qPtr 是指针</span></span><br><span class="line">    qPtr-&gt;front = <span class="literal">nullptr</span>; <span class="comment">// 使用 -&gt; 访问成员</span></span><br><span class="line">    qPtr-&gt;rear = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景 3：解引用指针后使用 .</span></span><br><span class="line">    (*qPtr).front = <span class="literal">nullptr</span>; <span class="comment">// 等价于 qPtr-&gt;front = nullptr;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;q.front: &quot;</span> &lt;&lt; q.front &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;qPtr-&gt;front: &quot;</span> &lt;&lt; qPtr-&gt;front &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> qPtr; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判空</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue *q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>入队</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InQueue</span><span class="params">(LinkQueue *q,element x)</span>&#123;<span class="comment">//是element x，而非LinkNode x</span></span><br><span class="line">    LinkNode p = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear-&gt;next = p;</span><br><span class="line">    q-&gt;rear = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>出队</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue *q,element *x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *p = q-&gt;front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    q-&gt;front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p == q-&gt;rear)&#123;</span><br><span class="line">        q-&gt;front = q-&gt;rear;</span><br><span class="line">    &#125;<span class="comment">//只有一个结点，这样做的目的是使之删除后符合队列为空的条件</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双端队列与输入或输出受限的双端队列"><a href="#双端队列与输入或输出受限的双端队列" class="headerlink" title="双端队列与输入或输出受限的双端队列"></a>双端队列与输入或输出受限的双端队列</h3><h3 id="经典括号匹配算法"><a href="#经典括号匹配算法" class="headerlink" title="经典括号匹配算法"></a>经典括号匹配算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125;SeStack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SeStack* s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//注意</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SeStack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnStack</span><span class="params">(SeStack* s, <span class="type">char</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeStack</span><span class="params">(SeStack* s, <span class="type">char</span>* x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *x = s-&gt;data[(s-&gt;top)--];<span class="comment">//注意*x</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Compare</span><span class="params">(<span class="type">char</span> a[])</span> &#123;</span><br><span class="line">    SeStack s;</span><br><span class="line">    InitStack(&amp;s);</span><br><span class="line">    <span class="type">char</span>* ptr = a;</span><br><span class="line">    <span class="keyword">while</span> (*ptr != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*ptr == <span class="string">&#x27;[&#x27;</span> || *ptr == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            EnStack(&amp;s, *ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*ptr == <span class="string">&#x27;]&#x27;</span> || *ptr == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">char</span> temp;</span><br><span class="line">            <span class="keyword">if</span> (!DeStack(&amp;s, &amp;temp)) &#123;<span class="comment">//注意条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; *ptr != <span class="string">&#x27;&#125;&#x27;</span> ||temp == <span class="string">&#x27;[&#x27;</span> &amp;&amp; *ptr != <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IsEmpty(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Compare(<span class="string">&quot;&#123;&#123;&#125;&#125;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-链表合集</title>
      <link href="/2025/02/11/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E5%90%88%E9%9B%86/"/>
      <url>/2025/02/11/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Del</span><span class="params">(LinkList *L，<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    LinkList *p = L-&gt;next;</span><br><span class="line">    LinkList *pre = L;</span><br><span class="line">    LinkList *temp;</span><br><span class="line">    <span class="keyword">while</span>(p != null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p -&gt;data == x)&#123;</span><br><span class="line">            temp = p;<span class="comment">//temp指向被删节点</span></span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            pre-&gt;next = p;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中的<code>if(p -&gt;data == x)</code>可以被替换为任何条件</p></blockquote><p>2. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Del</span><span class="params">(LinkList *L)</span>&#123;</span><br><span class="line">    LinkList *p = L-&gt;next;</span><br><span class="line">    LinkList *pre = L;</span><br><span class="line">    LinkList *minpre = pre,*minp = p;   <span class="comment">//最小指针前驱以及最小指针</span></span><br><span class="line">    <span class="keyword">while</span>(p != null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt; minp-&gt;data)&#123;</span><br><span class="line">            minp = p ;</span><br><span class="line">            minp = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p ;</span><br><span class="line">        p = p -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    minpre-&gt;next = minp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(minp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(LinkList *L)</span>&#123;</span><br><span class="line">    LinkList * r = null;<span class="comment">//p为工作指针，r为p的后继指针</span></span><br><span class="line">    LinkList *p = L-&gt;next;</span><br><span class="line">    L-&gt;next = null;</span><br><span class="line">    <span class="keyword">while</span>(p != null)&#123;</span><br><span class="line">        r = p-&gt;next;</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        p = r;</span><br><span class="line">    &#125;<span class="comment">//这里使用头插法建立单链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4. </p><blockquote><p>1的变种</p></blockquote><p>5.<br><img src="/img/2025_2_11/001.png" alt="404"></p><blockquote><p>找出两个链表的公共结点，应遵循**“若有一个公共结点，那么他们的最后一个结点必定是重合的”**。根据这一思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为 O（lenl + len2）。</p></blockquote><p>6. </p><ol start="7"><li><p>略</p></li><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetCommon</span><span class="params">(LNode *a,LNode *b,LNode *c)</span>&#123;</span><br><span class="line">    c = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    LinkList pa=a-&gt;next,pb=b-&gt;next;</span><br><span class="line">    LinkList r = c;     <span class="comment">//尾插法，r始终指向尾节点</span></span><br><span class="line">    <span class="keyword">while</span>(pa != null &amp;&amp; pb!= null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)&#123;</span><br><span class="line">temp=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">r-&gt;next = s;    <span class="comment">//1</span></span><br><span class="line">            r=s;        <span class="comment">//2</span></span><br><span class="line">temp-&gt;data = pa-&gt;data;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">pb = pb-&gt;next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pa-&gt;data &gt; pb-&gt;data)&#123;</span><br><span class="line">pb = pb-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pa-&gt;data &lt; pb-&gt;data)&#123;</span><br><span class="line">pa = pa-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = null;<span class="comment">//使用尾插法时，记得最后将尾指针置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>尾插法</p></blockquote><ol start="9"><li><p>略</p></li><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pattern</span><span class="params">(LNode *a,LNode *b)</span>&#123;</span><br><span class="line">    LNode *pa = a;</span><br><span class="line">    LNode *pb = b;</span><br><span class="line">    LNode *pre = pa;</span><br><span class="line">    <span class="keyword">while</span>(pa != null &amp;&amp; pb != null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data == pb-&gt;data)&#123;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            pa = pre-&gt;next;</span><br><span class="line">            pb = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pb == null)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//匹配成功</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Symmetry</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    LinkList q = L-&gt;prev;</span><br><span class="line">    <span class="keyword">while</span>(p!=q || q-&gt;next != p)&#123;    <span class="comment">//不要写成p-&gt;next != q</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data != q-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LNode <span class="title function_">Link</span><span class="params">(LNode *h1,LNode *h2)</span>&#123;</span><br><span class="line">    LinkList ph1 = h1;<span class="comment">//工作指针</span></span><br><span class="line">    LinkList ph2 = h2;<span class="comment">//工作指针</span></span><br><span class="line">    <span class="keyword">while</span>(ph1-&gt;next != h1)&#123;</span><br><span class="line">        ph1 = ph1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ph2-&gt;next != h2)&#123;</span><br><span class="line">        ph2 = ph2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ph1-&gt;next = h2;</span><br><span class="line">    ph2-&gt;next = h1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">Converse</span><span class="params">(LNode *L,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    LinkList p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != null)&#123;</span><br><span class="line">        p = p -&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = L;</span><br><span class="line">    <span class="keyword">while</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;n-k;i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;<span class="comment">//找到新头结点的前一个结点</span></span><br><span class="line">    L = p-&gt;next;</span><br><span class="line">    p-&gt;next = null;<span class="comment">//断环</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li>判断链表是否成环</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isCircle</span><span class="params">(LNode *L)</span>&#123;</span><br><span class="line">    LinkList fast = L,slow=L;</span><br><span class="line">    <span class="keyword">while</span>(fast != null || fast-&gt;next != null)&#123;</span><br><span class="line">        slow = slow -&gt;next;</span><br><span class="line">        fast = fast -&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于构建网页和Web应用的技术</title>
      <link href="/2025/02/08/%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA%E7%BD%91%E9%A1%B5%E5%92%8CWeb%E5%BA%94%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
      <url>/2025/02/08/%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA%E7%BD%91%E9%A1%B5%E5%92%8CWeb%E5%BA%94%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>jQuery<br> 当时的前端多是用来展示的，用此技术足以“应付”。</p></li><li><p>AngularJS<br> 实现了<strong>响应式，模块化</strong>，自此前端可以自行处理较复杂的逻辑。</p></li><li><p>Vue &amp; React<br> 相比于AngularJS，它们则为“骨架”，只包含核心功能，其他的功能由分离的插件支持。引导采用组件化编程，用接口连接组件，方便扩展与维护。基于虚拟DOM树，开销小。</p></li><li><p>JavaScript<br> 一款单线程脚本语言。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>君山行</title>
      <link href="/2025/02/04/%E5%90%9B%E5%B1%B1%E8%A1%8C/"/>
      <url>/2025/02/04/%E5%90%9B%E5%B1%B1%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Cyber-Diary"><a href="#Cyber-Diary" class="headerlink" title="Cyber Diary"></a>Cyber Diary</h2><p>盘龙山公园<br><img src="/img/2025_2_4/002.jpg" alt="404"></p><p>老君山南门<br><img src="/img/2025_2_4/003.jpg" alt="404"></p><p>标记了一处地点<br><img src="/img/2025_2_4/004.jpg" alt="404"></p><p>羊肉汤<br><img src="/img/2025_2_4/005.jpg" alt="404"></p><p>Sunshine<br><img src="/img/2025_2_4/006.jpg" alt="404"></p><p>在这里引用<strong>许渊冲先生</strong>的一句话</p><blockquote><p>生命不是活了多少日子，而是记住了多少日子。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于走亲戚的思考</title>
      <link href="/2025/02/03/%E5%85%B3%E4%BA%8E%E8%B5%B0%E4%BA%B2%E6%88%9A%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2025/02/03/%E5%85%B3%E4%BA%8E%E8%B5%B0%E4%BA%B2%E6%88%9A%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>所谓的亲戚来，带3个小孩，一个小孩抱着遥控器死活不松手，把零食的袋子都拆开，但是都不吃；一个小孩在客厅里拉屎撒尿，家长收拾后扔到院子最近处，非常显眼；一个小孩卸载电视上的应用软件，去年也是这样，自己看完了就卸了。最后走的时候，小孩把茶水撒一地，家长看见置若罔闻、装聋作哑，拍屁股走人，而溜之大吉。不罗列了，是这样谁能忍？年年如此，一昧的忍让与单向牺牲式包容换来的却是恬不知耻、不知悔改！卑微的爱开不出娇艳的花！我找到了孩子父亲的电话号码，就此次事件所带来的恶劣影响，以及应该的做法，说了些话。希望其有所悔改。</p><p>家长教育责任的移位与缺失，孩子边界意识模糊、空间权属混淆。“容忍亲戚越界”不等同于“重视家族团结”。缺乏对私人地域与公共区域的认知，混淆“做客”与“占领”的区别。有些人把血缘当成“免罪金牌”，却忘了“亲人”本该是比“外人”更懂分寸的存在。当“亲戚”二字变成道德绑架的冲锋号，当“孩子还小”沦为野蛮行为的遮羞布，与其维持这种变异的情感勒索，不如将其扼杀在绝望的摇篮之中。</p><p>作为一个成年人，我有权力采取一系列措施保护自己的家庭与生活环境。真正的亲情应建立在相互尊重的基础上，而非一方对另一方的殖民式侵占。必要时，允许关系降级甚至断裂，是对自我价值最高效的捍卫，也是对家人及其环境的保障。很多家庭矛盾就坏在“算了算了”四个字上。亲戚吃准了你怕撕破脸，才敢得寸进尺。请跳出传统道德绑架的历史周期律、突破传统“血浓于水”的桎梏，保卫自己的地盘。反而观之，维护自我价值与保持亲情温暖并非零和博弈，关键在于建立有弹性的边界—如同细胞膜，既保持独立完整，又允许物质能量交换。</p><p><img src="/img/2025_2_3/001.jpg" alt="404"></p><p><img src="/img/2025_2_3/002.jpg" alt="404"></p><p>但我仍觉得自己的表达方式该有提升，敬请批评指正！</p><p><img src="/img/2025_2_3/003.png" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法-顺序表合集</title>
      <link href="/2025/02/02/%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%90%88%E9%9B%86/"/>
      <url>/2025/02/02/%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="对长度为n的顺序表L，编写一个时间复杂度为-O（n）、空间复杂度为-O（1）的算法，该算法删除顺序表中所有值为x的数据元素。"><a href="#对长度为n的顺序表L，编写一个时间复杂度为-O（n）、空间复杂度为-O（1）的算法，该算法删除顺序表中所有值为x的数据元素。" class="headerlink" title="对长度为n的顺序表L，编写一个时间复杂度为 O（n）、空间复杂度为 O（1）的算法，该算法删除顺序表中所有值为x的数据元素。"></a>对长度为n的顺序表L，编写一个时间复杂度为 O（n）、空间复杂度为 O（1）的算法，该算法删除顺序表中所有值为x的数据元素。</h2><ol><li><p>时间复杂度为 o（n^2）的暴力算法，即两个for循环。</p></li><li><p>记录不等于x的元素的个数<br><em>相比较与粘图片，还是使用福昕pdf复制，我觉得还是手打吧，因为我实在是看不上前两种方式</em></p></li></ol><p>法一：记录不等于x的个数，直接替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(SeList *L,Element x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;<span class="comment">//记录不等于x的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; L-&gt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;data[i] != x)&#123;</span><br><span class="line">            L-&gt;data[k] = L-&gt;data[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length = k ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：记录等于x的个数，整体移位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(SeList *L,Element x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>,i = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; L-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i] == x)&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            data[i-k] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length = L-&gt;length-k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法三：双指针法</p><h3 id="变种"><a href="#变种" class="headerlink" title="变种"></a>变种</h3><ul><li>从顺序表中删除其值在给定值s和t之间（包含s和t，要求s小于t）的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。</li></ul><h2 id="合并有序表为一个新的有序表，并由函数返回"><a href="#合并有序表为一个新的有序表，并由函数返回" class="headerlink" title="合并有序表为一个新的有序表，并由函数返回"></a>合并有序表为一个新的有序表，并由函数返回</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Merge</span><span class="params">(SqList *a,SqList *b ,SqList *c)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a-&gt;length + b-&gt;length &gt; c-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> , k = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a-&gt;length &amp;&amp; j &lt; b-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;data[i] &lt;= b-&gt;data[j])&#123;</span><br><span class="line">            c-&gt;data[k++] = a-&gt;data[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c-&gt;data[k++] = b-&gt;data[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; a-&gt;length)&#123;</span><br><span class="line">        c-&gt;data[k++] = a-&gt;data[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; b-&gt;length)&#123;</span><br><span class="line">        c-&gt;data[k++] = b-&gt;data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;length = k;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如图"><a href="#如图" class="headerlink" title="如图"></a>如图</h2><p><img src="/img/2025_2_4/001.png" alt="404"></p><p>思路：先对m+n整体逆转，在对其分别逆转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Reverse</span><span class="params">(SqList *L,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> arraySize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right - left &gt; arraySize)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (right - left)/<span class="number">2</span> + left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt;= mid ; i++)&#123;</span><br><span class="line">        <span class="type">int</span> temp = L-&gt;data[left + i];</span><br><span class="line">        L-&gt;data[left + i] = L-&gt;data[right - i];</span><br><span class="line">         L-&gt;data[right - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Exchange</span><span class="params">(SqList *L,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> arraySize)</span>&#123;</span><br><span class="line">    Reverse(&amp;L,<span class="number">0</span>,m+n<span class="number">-1</span>,m+n);</span><br><span class="line">    Reverse(&amp;L,<span class="number">0</span>,n<span class="number">-1</span>,n);</span><br><span class="line">    Reverse(&amp;L,n,m+n<span class="number">-1</span>,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变种-1"><a href="#变种-1" class="headerlink" title="变种"></a>变种</h3><p><img src="/img/2025_2_4/002.png" alt="404"></p><h2 id="从三个顺序表中找出相同元素"><a href="#从三个顺序表中找出相同元素" class="headerlink" title="从三个顺序表中找出相同元素"></a>从三个顺序表中找出相同元素</h2><p><img src="/img/2025_2_5/001.png" alt="404"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sameKey</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b[],<span class="type">int</span> c[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span> , j = <span class="number">0</span> ,k = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n &amp;&amp; k &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j] &amp;&amp; b[j] == c[k])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> max = maxValue(a[i],maxValue(b[j],c[k]));</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; max)&#123;i++;&#125;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; max)&#123;j++;&#125;</span><br><span class="line">            <span class="keyword">if</span>(a[k] &lt; max)&#123;k++;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度，o(n)<br>空间复杂度，o(1)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/2025/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2025/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ol><li>线性表的定义：相同数据类型、有限、序列（有前驱与后继）。</li><li>线性表由相同数据类型的有限<strong>数据元素</strong>组成，数据元素由数据项组成。</li></ol><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><ol><li>分为1-静态分配存储空间；2-动态分配存储空间。</li><li>优缺点<ul><li>随机访问，存储密度高</li><li>插入、删除难，不够灵活</li></ul></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>结点类型描述</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType data,</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>,</span></span><br><span class="line"><span class="class">&#125;<span class="title">LNode</span>,*<span class="title">LinkList</span></span></span><br></pre></td></tr></table></figure><pre><code>- LNode *L 等价于 LinkList L</code></pre><ol start="2"><li>头结点与头指针的关系</li></ol><p>头指针始终指向链表中第一个节点，头节点时带头节点链表中第一个结点，通常不存储信息。</p><ol start="3"><li>引入头结点所带来的好处</li></ol><ul><li>统一了空表与非空表操作</li><li>在链表第一个位置上的操作与其他位置一致</li></ul><ol start="4"><li>单链表的初始化</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：初始化链表，返回头节点</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">LinkList <span class="title function_">InitList</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkList L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">// 创建头节点</span></span><br><span class="line">    <span class="keyword">if</span> (L != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        L-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 初始化头节点的next为NULL</span></span><br><span class="line">        L-&gt;data = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>若p为指针，可用p-&gt;data或者(*p).data访问这个节点的数据域</p><ol start="5"><li>求表长（有头结点）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span> ;</span><br><span class="line">    LinkList q = L;<span class="comment">//防篡改</span></span><br><span class="line">    <span class="keyword">while</span>(q-&gt;next != null)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>按照值查找节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    LinkList q = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;data != i &amp;&amp; q != null)&#123;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>按照位序（序号）查找节点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    LinkList q = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span> ; <span class="comment">//头结点是第零个节点</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; pos &amp;&amp; q!=null)&#123;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>插入</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若新结点为s，则其关键算法为</span></span><br><span class="line"><span class="comment">//顺序不能颠倒</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-导论</title>
      <link href="/2025/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AF%BC%E8%AE%BA/"/>
      <url>/2025/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>逻辑结构</p><ol><li>集合</li><li>线性结构</li><li>树形结构</li><li>图状结构或网状结构</li></ol><p>  <img src="/img/2025_2_2/008.jpg" alt="404"></p><ul><li>1<br>  顺序表和链表都是线性结构，它们的逻辑结构相同。<br>  栈和队列虽然都是线性结构，但它们的操作规则不同，逻辑结构不完全相同。（存在争议）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好文分享2025_2_2</title>
      <link href="/2025/02/02/%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB2025_2_2/"/>
      <url>/2025/02/02/%E5%A5%BD%E6%96%87%E5%88%86%E4%BA%AB2025_2_2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>以下内容均为转载，非本人原创，所有权利归原作者或版权方所有。本人仅作分享，旨在传播有价值的信息，尊重并支持知识产权保护。如涉及版权问题，请联系删除。</strong></p><h2 id="外媒拆解DeepSeek制胜秘籍，OpenAI-CEO终于认错：我们站在了历史错误的一边"><a href="#外媒拆解DeepSeek制胜秘籍，OpenAI-CEO终于认错：我们站在了历史错误的一边" class="headerlink" title="外媒拆解DeepSeek制胜秘籍，OpenAI CEO终于认错：我们站在了历史错误的一边"></a>外媒拆解DeepSeek制胜秘籍，OpenAI CEO终于认错：我们站在了历史错误的一边</h2><p><a href="https://www.36kr.com/p/3147635441211909">点击这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 好文分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南山行</title>
      <link href="/2025/02/02/%E5%8D%97%E5%B1%B1%E8%A1%8C/"/>
      <url>/2025/02/02/%E5%8D%97%E5%B1%B1%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="行者"><a href="#行者" class="headerlink" title="行者"></a>行者</h2><p>好久没去南山了，一到南山，我便在山里跑了起来，看着似曾相识的景与物，思绪便不由自主地从四面八方涌入我的脑海中。曾经湍急的河流现如今裸露的只剩枯叶，亦或是青苔安静的铺在上面。曾经觉得南山好高好高，走了一程又一程，绕过了一个又一个弯，仍不能抵达山顶，现在却也用具体的数字量化山的高度，走一会儿就走完了全程。小时候的自己使劲地爬呀爬，终于—和早已在山顶的自己相遇。但或许初心仍在，犹如眼见之处清雅古檀般的大地、幽深静远的浅谭；所踏之地台阶参差不齐的边缘，它被时间缓缓地雕塑着，镌刻着光阴的年轮，勾勒出变迁的轨迹；耳闻之声的和谐与静谧，与大自然同频振动，却也不同与世间喧嚣吵闹。</p><p><img src="/img/2025_2_2/001.png" alt="图片去外星球了"></p><hr><p><img src="/img/2025_2_2/002.png" alt="图片去外星球了"></p><hr><p><img src="/img/2025_2_2/003.png" alt="图片去外星球了"></p><hr><p><img src="/img/2025_2_2/004.png" alt="图片去外星球了"></p><hr><p><img src="/img/2025_2_2/005.png" alt="图片去外星球了"></p><hr><p><img src="/img/2025_2_2/006.png" alt="图片去外星球了"></p><hr><p><img src="/img/2025_2_2/007.png" alt="图片去外星球了"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础语法之输入与其它</title>
      <link href="/2025/02/01/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E5%85%B6%E5%AE%83/"/>
      <url>/2025/02/01/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%BE%93%E5%85%A5%E4%B8%8E%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="input元素"><a href="#input元素" class="headerlink" title="input元素"></a>input元素</h2><ul><li><p>type：此属性可以选择不同的属性值，但最终都是以按钮的形式展示</p><ol><li>submit</li><li>reset</li><li>button</li><li>text</li><li>radio（单选框）</li><li>checkbox（复选框）</li><li>time&#x2F;data（时间&#x2F;日期选择器）<ul><li>13:14会在URL地址栏中显示13%3A34，因为其为了避免有歧义，引入了URL编码。</li></ul></li><li>search（搜索框）<ul><li>具体的搜索用script code实现</li></ul></li><li>color（颜色选择器）<ul><li>例如：#1bac5a,可分为3组，分别代表R\G\B三原色的值</li></ul></li><li>hidden（隐藏按钮）</li><li>file（上传文件）</li><li>number（限定数字）<ul><li>min最小；max最大</li></ul></li><li>range（数值滚动条）<ul><li>step步长；min最小；max最大</li></ul></li><li>textarea：接受多行文本</li></ol></li><li><p>value：此属性指定在按钮上显示的值或者在文本框里预定输入的值等</p></li><li><p>name：这个名称在表单提交时，将作为键值对的一部分被发送到服务器。只有设置了name属性的表单元素，其值才会在表单提交时被传递。这意味着如果你的输入元素没有name属性，或者name属性为空，那么这个输入的值就不会与表单一起提交。</p></li><li><p>id：在一个HTML文件中，id值是唯一的，可供CSS&#x2F;JS选择器选择</p></li><li><p>placeholder：输入框中的提示</p></li><li><p>required：必填字段，否则不能提交</p></li><li><p>autofocus：一打开界面，光标就会自动放在某个输入框上</p></li><li><p>autocomplete属性：自动填充。on开；off关。</p></li></ul><h2 id="div与语义化布局"><a href="#div与语义化布局" class="headerlink" title="div与语义化布局"></a>div与语义化布局</h2><ol><li>div：一个块级无语义元素</li></ol><p>HTML5中的新语义元素：</p><ul><li>nav：导航</li><li>section：节</li></ul><h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><ol><li>嵌入网页</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>sandbox 属性为 iframe 中的内容启用了一组额外的限制。<br><img src="/img/2025_2_1/001.png" alt="404"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础语法之表格与表单</title>
      <link href="/2025/01/31/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E4%B8%8E%E8%A1%A8%E5%8D%95/"/>
      <url>/2025/01/31/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E8%A1%A8%E6%A0%BC%E4%B8%8E%E8%A1%A8%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li><p>table&#x2F;tr&#x2F;th&#x2F;td(row,headercell,datacell)</p><ol><li>tr中的内容默认加粗并居中</li><li>标签table没有边框—<strong>语法与实现相分离</strong></li><li>加边框—{border:1px solid black;}，写在table、th、td内即给对应的加边框</li><li>使边框合并—border-collapse:collapse;</li><li>给table加标题，需要紧挨着table开始标签，使用caption属性写在table标签内</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">&quot;border:1px solid black;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span></span><br><span class="line">            Hdd</span><br><span class="line">        <span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">style</span>=<span class="string">&quot;border:1px solid black;&quot;</span>&gt;</span></span><br><span class="line">                1</span><br><span class="line">            <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">style</span>=<span class="string">&quot;border:1px solid black;&quot;</span>&gt;</span></span><br><span class="line">                2</span><br><span class="line">            <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;border:1px solid black;&quot;</span>&gt;</span></span><br><span class="line">                q1</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;border:1px solid black;&quot;</span>&gt;</span></span><br><span class="line">                q2</span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>thead&#x2F;tbody&#x2F;tfoot进行分割表格</li></ol><p>  <code>&lt;thead&gt;</code> 元素与 <code>&lt;tbody&gt;</code> 和 <code>&lt;tfoot&gt;</code> 元素结合使用，以规定表格的每个部分（页眉、正文、页脚）。</p><ul><li>colspan属性：允许th、td跨行、列显示（colspan跨行，rowspan跨列）</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;这里写要跨的行数&quot;</span>&gt;</span>XX<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>批量设置一列或者多列的style</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">span</span>=<span class="string">&quot;这里写列数，默认为1&quot;</span> <span class="attr">style</span>=<span class="string">&quot;这里写样式&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="表单"><a href="#表单" class="headerlink" title="表单&lt;form&gt;&lt;/form&gt;"></a>表单<code>&lt;form&gt;&lt;/form&gt;</code></h2><ol><li>action&#x3D;””。交由谁处理，默认当前界面</li><li>method&#x3D;””。使用哪种HTTP方法将表单发给Server<ul><li>GET：将数据整合到URL里，不安全</li><li>POST：数据随HTTP消息主题发到服务器</li></ul></li><li>target：指定显示的位置，例如_blank</li></ol><ul><li><p>button：按钮</p><ul><li>type：选择可选的属性值<ol><li>submit：提交</li><li>button：按钮</li><li>reset：重置</li></ol></li><li>formmethod&#x3D;”get&#x2F;post”，HTML5新增，修改原form中规定的提交方法</li></ul></li><li><p>form中的autocomplete属性：on开；off关。（自动填充：由于隐私，有时候用户不希望输入框下有提示）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探-MyBatis</title>
      <link href="/2025/01/31/%E5%88%9D%E6%8E%A2-MyBatis/"/>
      <url>/2025/01/31/%E5%88%9D%E6%8E%A2-MyBatis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MyBatis—一款持久层框架，简化JDBC开发"><a href="#MyBatis—一款持久层框架，简化JDBC开发" class="headerlink" title="MyBatis—一款持久层框架，简化JDBC开发"></a>MyBatis—一款持久层框架，简化JDBC开发</h2><p>首先解决JDBC遗留的三个问题：</p><ol><li>硬编码：在MyBatis中改动application.properties</li><li>繁琐：</li><li>频繁开关连接：在Mybatis中使用数据库连接池。</li></ol><hr><ul><li>DB连接池：<ol><li>是个容器</li><li>当某个用户需要连接数据库时，取曲别针，断开数据库连接时，释放曲别针。<br>  若用户长时间占而不用，池会计时并释放。<br>  <img src="/img/2025_1_31/001.jpg" alt="图片去外星球了"></li><li>SpringBoot使用Hikari</li><li>Sun提供的标准DB接口为：DataSource，所有的数据库连接池都要实现这个接口</li></ol></li></ul><h2 id="基于Spring-Boot整合Mybatis"><a href="#基于Spring-Boot整合Mybatis" class="headerlink" title="基于Spring Boot整合Mybatis"></a>基于Spring Boot整合Mybatis</h2><ol><li>准备：创建Spring Boot工程，勾选MySQL Driver、MyBatis Farmwork；数据库表；实体类。</li><li>引入MyBatis相关依赖，配置MyBatis</li><li>编写SQL语句</li></ol><p>以下为在application.properties中的配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//项目名字</span></span><br><span class="line">spring.application.name=Sql_And_Mybatis</span><br><span class="line"></span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/pingpang_plus</span></span><br><span class="line"></span><br><span class="line">spring.datasource.username=root</span><br><span class="line"></span><br><span class="line">spring.datasource.password=<span class="number">194910</span></span><br><span class="line"><span class="comment">//控制台输出执行SQL语句</span></span><br><span class="line">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探-用GitHub搭建自己的博客</title>
      <link href="/2025/01/30/%E5%88%9D%E6%8E%A2-%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/01/30/%E5%88%9D%E6%8E%A2-%E7%94%A8GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用GitHub搭建自己的博客，下面这篇文章完成从0到hexo初始主题的配置：<br><a href="https://www.cnblogs.com/chenlove/p/15058170.html">点击这里</a></p><p>配置好博客框架后，选择一款主题是非常有必要的。<br>这里通过链接介绍Butterfly主题的安装与配置：<br><a href="https://butterfly.js.org/posts/21cfbf15/">点击这里</a></p><p>Butterfly的官方网站(<a href="https://butterfly.js.org/">https://butterfly.js.org/</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈妙言</title>
      <link href="/2025/01/27/%E8%B0%88%E8%B0%88%E5%A6%99%E8%A8%80/"/>
      <url>/2025/01/27/%E8%B0%88%E8%B0%88%E5%A6%99%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天下载了一款markdown编辑器，名为“妙言”，官方介绍为完全开源，不会上传用户数据等一系列优点，我便下载试试，在这里总结利与弊。<br><a href="https://miaoyan.app/">点击这里下载妙言</a></p><h2 id="利"><a href="#利" class="headerlink" title="利"></a>利</h2><ol><li>支持预览（VSCode也可，两者的预览仅供参考，以网站实际显示效果为准）。</li><li>字体优美（霞骛字体，听起来高大上的样子）。</li><li>轻量级，dmg包仅仅20MB。</li><li>网站主页使用Vercel进行托管，经济实惠，感觉平易近人。</li><li>等等</li></ol><h2 id="弊"><a href="#弊" class="headerlink" title="弊"></a>弊</h2><ol><li><p>令人抓狂的缩进。</p><p> 我在写嵌入文本的代码块时，遇到了棘手的问题。<br> 下面这张图片为正常显示：<br> <img src="/img/2025_1_28/001.png" alt="图片去外星球了"><br> 但当我将代码边界的三个点移动后，再移动回去时，并不会高亮显示：<br> <img src="/img/2025_1_28/002.png" alt="图片去外星球了"><br> 但是预览的时候是没有问题的，所以此处为一个bug。</p><p> 在这方面VSCode是做的不错的，他有着合理的缩进提示线：<br> <img src="/img/2025_1_28/003.png" alt="图片去外星球了"></p><p> 所以“妙言”仍不能胜任严苛的写作任务</p></li></ol><h2 id="一款好的markdown编辑器"><a href="#一款好的markdown编辑器" class="headerlink" title="一款好的markdown编辑器"></a>一款好的markdown编辑器</h2><p>我觉得一款好的编辑器需要具备：</p><ol><li>支持HTML代码自动补全。</li><li>轻量化</li><li>能够胜任大部分任务</li></ol><h2 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h2><p>“妙言”，它又轻又美，但是缩进的影响对我来说是不可忽略的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈婚嫁</title>
      <link href="/2025/01/25/%E8%B0%88%E8%B0%88%E5%A9%9A%E5%AB%81/"/>
      <url>/2025/01/25/%E8%B0%88%E8%B0%88%E5%A9%9A%E5%AB%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="谈谈婚与嫁"><a href="#谈谈婚与嫁" class="headerlink" title="谈谈婚与嫁"></a>谈谈婚与嫁</h2><p>在社会钟表的推动下，人们如同被上紧了的发条，被资本的浪潮不断裹挟着向前，同时作为其中的一部分零件，维持着国家机器的运转。在看似通往罗马的路上，不妨蓦然回首，叩击自己的本心，听听它的回响。｜以年少轻狂为开始，以一地鸡毛为结局的感情状态比比皆是，面对广袤无垠的面包问题，若不是对自己或者世界有着清醒的认知，极大概率成为飞蛾扑火的牺牲品，撞的头破血流、摔得粉身碎骨。理性的声音少有人听，情绪的反应让人沦为俘虏。</p><p>父母安排，亲戚撮合，熟人介绍。社会自由匹配失去驱动力了吗？还是被转嫁为家庭压力或者社会期望？相亲本质上是寻找“适合”，而非“契合”的伴侣，即使在某种意义上稳定了关系，却也可能失去了情感的真实温度，最终难免生出隔阂与迷惘，使个性的棱角在日常的争吵中被一遍遍，一遍遍的磨平，最终达成了一种诡异的合作关系。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 深度议论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础语法之列表</title>
      <link href="/2025/01/24/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%88%97%E8%A1%A8/"/>
      <url>/2025/01/24/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h1><ul><li><p>元素及其属性介绍</p><ul><li>ol</li></ul><ol><li>定义有序列表，列表中的每一项同样用<code>&lt;li&gt;&lt;/li&gt;</code>标识</li><li>属性，reversed、start、type</li></ol><ul><li>reversed（对列表进行降序排序）</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tea<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>start</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tea<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>type（规定类型为罗马字母）</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;I&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Tea<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>dl</p><ol><li>定义列表</li><li>dl需要与dt和dd配合使用</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  显示效果：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;Coffee&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;Black hot drink&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;Milk&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;White cold drink&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五子棋项目总结</title>
      <link href="/2025/01/24/%E4%BA%94%E5%AD%90%E6%A3%8B%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2025/01/24/%E4%BA%94%E5%AD%90%E6%A3%8B%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><ol><li>立项</li><li>可行性分析+软件开发计划</li><li>需求分析</li><li>架构</li><li>编码</li><li>测试</li><li>项目上线</li><li>维护</li></ol><h4 id="立项"><a href="#立项" class="headerlink" title="立项"></a>立项</h4><p>做什么东西</p><h4 id="可行性分析"><a href="#可行性分析" class="headerlink" title="可行性分析"></a>可行性分析</h4><ol><li>技术可行性<ul><li>用到哪些技术。如果某个技术是一部分功能会用到的，需要小组内一半人掌握才能使用；如果是所有代码涉及到的，需要全员掌握</li><li>列举核心功能</li><li>考虑核心功能能否实现<ol><li>数据的设计</li><li>逻辑的描述</li></ol></li></ul></li></ol><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol><li>需求文档<ul><li>界面划分</li><li>界面描述</li><li>功能分类</li><li>功能概述</li><li>优先级</li><li>备注</li></ul></li><li>流程图<ul><li>使用process on来制作流程框图</li></ul></li><li>原型图<ul><li>使用墨刀。不要求一模一样，但数据、内容不能有遗漏</li><li>注意设计时形成闭环（有a-&gt;b，就得有b-&gt;a）。</li></ul></li></ol><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ol><li><p>什么是架构<br>一个项目文件夹里放着数据的设计、函数的声明。<br><em>要求注释详细，函数声明、功能、参数、返回值清晰</em></p></li><li><p>为什么要有架构</p><ul><li>明确分工：谁负责哪块代码，出了问题联系谁</li><li>技术分配：不同人擅长不同的地方</li><li>代码分层：view层与service层（UI与实现相互分离），即<code>接受输入-&gt;逻辑判断、修改-&gt;程序输出</code></li></ul></li><li><p>搭建架构的最低前提</p><ul><li>熟悉用户操作流程、程序运行流程</li><li>单人写，择优</li><li>可在一开始只写核心功能，后来再完善</li></ul></li></ol><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ol><li>整合<ul><li>每天进行整合，以函数为单位在git上提交</li><li>讲进度、讨论问题、安排拓展架构的分工</li><li>布置某项任务时的格式<ul><li>内容：</li><li>负责人：</li><li>截止时间</li><li>提交方式</li><li>接收人</li></ul></li></ul></li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>小项目，无需测试工具，便在本地测试</p><h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><ul><li>9-20：产品经历逐个点评原型图；副组长问大家C语言的掌握程度；大家评判的是用Console还是用EasyX来做。</li><li>9-21：副组长确定每个人的安排，但他刚说完自己就记不清了。得事先写好，不能想到哪，说到哪。</li><li>9-22：我发布了我写的架构，并让大家提出意见</li><li>9-23：我做了个简易五子棋，验证架构可行性，因为自己第一次写架构</li><li>9-24：整合代码，开会讨论</li><li>9-25：整合代码，开会讨论</li><li>9-26：实现了落子，增加了“当前黑|白子”与“当前局数”的功能</li><li>9-27：没归零map数组，导致判断胜负出问题，已改正。我以为“五子紧密相连为胜”，实际上“中间隔着空气”也可以。产品经历提出意见，我一开始没听明白，他也不说了，我也不问了，这是大忌！</li><li>9-28：美化了UI</li><li>9-29：答辩，给出以下评价</li></ul><ol><li>布局清晰，颜色分明，细节到位</li><li>代码注释太少</li><li>有的人没看到我封装的button函数-&gt;通知不到位</li><li>路演PPT有待规范</li></ol><p>获得了83.5分，7&#x2F;20的排名。</p><p><img src="/img/2025_1_24/001.png" alt="404"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML基础语法之段落</title>
      <link href="/2025/01/23/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%AE%B5%E8%90%BD/"/>
      <url>/2025/01/23/HTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B9%8B%E6%AE%B5%E8%90%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML知识点整理"><a href="#HTML知识点整理" class="headerlink" title="HTML知识点整理"></a>HTML知识点整理</h2><ul><li><p>前世今生与概括</p><p>  许多计算机通过Internet连接在一起，而在万维网上，可以找到图片、视频等资源。网景与微软争夺浏览器市场，促使了HTML规范的统一。<br>  HTML:描述网页的一种语言，没有强逻辑处理能力，标记语言而非编程语言。</p></li><li><p>入门</p><p>  创建一个.html文件，使用VSCode打开，输入!，显示出了</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>基础</p><ol><li>doctype声明：在HTML4.01中很复杂，HTML5使其统一</li><li>language为English</li><li>字符集编码（character）为utf-8</li><li>实现网页自适应（根据不同终端设备动态调整网页的缩放与比例）</li><li>title为网站标题</li></ol></li><li><p>提升</p><ol><li>meta部分放在head中，让浏览器早知道这些信息</li><li>meta元素中name属性有不同的值。这里引出<strong>搜索引擎优化（SEO）</strong></li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这里写关键字&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这里写描述&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这里写作者&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  其他功能<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这里写秒数;这里写网站&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li></ul></li><li><p>元素及其属性介绍</p><ul><li><p>元素：img（元素后为属性，以下同理）</p><ol><li>src-&gt;路径</li><li>alt-&gt;图片不能正常显示时出现的文字</li></ol></li><li><p>a</p><ol><li>href-&gt;链接</li><li>target-&gt;如果值为_blank，则超链接在新窗口打开。如果值为_self，则超链接在当前页打开。</li></ol></li><li><p>noscript</p><ol><li>当浏览器不支持JS时，显示的内容</li></ol></li><li><p>pre</p><ol><li>浏览器遇到一个或多个tab、space、enter时会被设置为一个空格，pre按照源文本格式显示</li><li>其内字体为等宽字体而非比例字体</li></ol></li><li><p>code</p><ol><li>内写代码</li><li>注意前端开发的规范，使用正确的元素去做正确的事</li></ol></li><li><p>q</p><ol><li>段引用，会在两侧加“ ”</li></ol></li><li><p>blockquote</p><ol><li>长引用，会缩进</li></ol></li><li><p>cite</p><ol><li>引用作品</li></ol></li><li><p>abbr</p><ol><li>定义简称或缩写，配合title使用</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;这里写全称&quot;</span>&gt;</span>这里写简称<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span>这里写后续文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>dfn</p><ol><li>定义术语</li></ol></li><li><p>address</p><ol><li>作者联系方式</li></ol></li><li><p>ruby</p><ol><li>rt-&gt;里写标识的内容。rp-&gt;浏览器不支持ruby时所显示的内容</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span> 明 日 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span>ming ri<span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span> <span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>bdo</p><ol><li>修改默认文本方向</li></ol><pre><code class="language-html">&lt;bdo dir=&quot;ltr&quot;&gt;left- to - right&lt;/bdo&gt;&lt;bdo dir=&quot;rtl&quot;&gt;right - to - left&lt;/bdo&gt;&lt;bdo dir=&quot;auto&quot;&gt;auto&lt;/bdo&gt;</code></pre></li><li><p>strong </p><ol><li>表示强调</li><li>b也可以表示强调</li></ol></li><li><p>em</p><ol><li>倾斜</li><li>i也可以表示强调</li><li>尽管b与i也可以实现相应的功能，但这些<strong>标签</strong>没有相应的语义。有本书说<em>应该遵循语义与实现相分离</em>，暂时不太理解。</li></ol></li><li><p>ins&#x2F;del</p><ol><li>分别为插入与删除</li></ol></li><li><p>s</p><ol><li>定义不正确的内容</li><li>注意del与s不能混用</li></ol></li><li><p>mark</p><ol><li>标记</li></ol></li><li><p>sup&#x2F;sub</p><ol><li>上标文本与下标文本</li></ol></li><li><p>small</p><ol><li>使变小</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回老家</title>
      <link href="/2025/01/21/%E5%9B%9E%E8%80%81%E5%AE%B6/"/>
      <url>/2025/01/21/%E5%9B%9E%E8%80%81%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="今日回老家—表姐结婚"><a href="#今日回老家—表姐结婚" class="headerlink" title="今日回老家—表姐结婚"></a>今日回老家—表姐结婚</h1><p>开局一张图<br><img src="/img/2025_1_21/001.png" alt="图片去外星球了"></p><p>典礼上放的烟花<br><img src="/img/2025_1_21/002.jpg" alt="图片去外星球了"></p><p>相比饮料，我喜欢各种各样的矿泉水<br><img src="/img/2025_1_21/003.png" alt="图片去外星球了"></p><p>广阔天地、大有作为。这种路骑自行车走是最好的了，驰骋在田野上，仿佛有使不完的力气蹬着脚踏，听着晚风在耳边呼啸而过，看着太阳悬挂在天边，从无尽的平原里来、到无穷的平原中去。<br>纵使在寒冷的冬天里，热烈的汗水浸湿了衣襟，嘴里不断喘着粗气，用手在额头上擦擦，一笑而过了。<br>我不热衷于自行车竞速运动，追求帅与快是与骑行的初衷背道而驰的，适量的多巴胺是愉悦的，失控的多巴胺是危险的，速度与多巴胺呈正比例，而与安全却是对立的，至于帅，也是快过了追求帅的年纪了。</p><p>每一个时代有每一个时代的追求，欲买桂花同载酒，终不似，少年游。🚴‍♀️<br><img src="/img/2025_1_21/004.jpg" alt="图片去外星球了"></p><p>请叫我摄影师！<br><img src="/img/2025_1_21/005.jpg" alt="图片去外星球了"></p><p>又开上小电车了<br><img src="/img/2025_1_21/006.jpg" alt="图片去外星球了"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中的搜索---地址栏与搜索栏</title>
      <link href="/2025/01/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%8F/"/>
      <url>/2025/01/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主流搜索引擎"><a href="#主流搜索引擎" class="headerlink" title="主流搜索引擎"></a>主流搜索引擎</h1><ul><li>百度</li><li>搜狗</li><li>360搜索</li><li>必应</li><li>谷歌</li><li>雅虎</li><li>DuckDuckGo</li><li>Ecosia</li></ul><p><strong>(排名不分先后)</strong></p><h1 id="PC端地址栏与搜索栏之分"><a href="#PC端地址栏与搜索栏之分" class="headerlink" title="PC端地址栏与搜索栏之分"></a>PC端地址栏与搜索栏之分</h1><p><img src="/img/2025_1_20/005.png" alt="图片去外星球了"></p><ol><li><p>1号位置<br> 此处为地址栏，常用于直接输入网址，例如chenhongyang86.fun<br> 如果输入的是一个完整的 URL（如chenhongyang86.fun），浏览器会直接跳转到对应的网站。<br> 如果输入内容看起来不像 URL（如 “TikTok”），浏览器会将地址栏的输入内容自动转为搜索查询，使用默认的搜索引擎搜索。 </p></li><li><p>2号位置<br> 此处为搜索栏，用于输入指定内容，例如 今天天气怎么样<br> 不管输入什么内容（关键词或网址），都会被当作搜索查询发送到搜索引擎。<br> 即使输入一个网址，也会将其视为搜索关键词，返回相关搜索结果，而不是直接跳转到该网址。  </p></li><li><p>总结</p><table><thead><tr><th></th><th>搜索栏</th><th>地址栏</th><th></th><th></th></tr></thead><tbody><tr><td>输入网址</td><td>F</td><td>T</td><td></td><td></td></tr><tr><td>输入内容</td><td>T</td><td>T</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ol><h1 id="手机地址栏与搜索栏"><a href="#手机地址栏与搜索栏" class="headerlink" title="手机地址栏与搜索栏"></a>手机地址栏与搜索栏</h1><p>笔者下载了Google、Safari、百度、DuckDuckGo、Firefox等主流浏览器，发现大多数浏览器地址栏与搜索栏合并，故此栏可输入网址与内容。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题中界面找不到的问题</title>
      <link href="/2025/01/20/Butterfly%E4%B8%BB%E9%A2%98%E4%B8%AD%E7%95%8C%E9%9D%A2%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/20/Butterfly%E4%B8%BB%E9%A2%98%E4%B8%AD%E7%95%8C%E9%9D%A2%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天我遇到了问题<br><img src="/img/2025_1_20/002.png" alt="图片去外星球了"><br>点击这两个区域报404错误</p><p>于是就上网找答案，找来找去，发现都是是解决Butterfly中“导航栏”配置tags与categories配置的方法，怎么也找不到“侧边栏”中前面这两项报404的问题。<br>在社区群里问，直到我自己找到解决方法也没有人回我。故在这里记录下指南。</p><p><strong>经历与过程</strong></p><ol><li><p>一开始扒了别人的博客网址，发现两条HTML代码，感觉是自己写的。但后来随着样本的增多，我发现这代码是官方配置好的，于是调整自己的方向，转向官方的配置文件，<br> 用ChatGPT查官方文件、社区交流困惑，均无法解决问题，于是再自行解决问题。</p></li><li><p>图片<br> <img src="/img/2025_1_20/001.png" alt="图片去外星球了"><br> 这是服务器直接部署在GitHub上报错的页面<br> <img src="/img/2025_1_20/003.png" alt="图片去外星球了"><br> 这是使用Vercel托管报错的页面<br> 注意前一张图片的报错：For root URLs (like <a href="http://example.com/">http://example.com/</a>) you must provide an index.html file.<br> 从GitHub仓库发现每一个界面都存在一个index界面，而恰恰是index界面，使得其可以被浏览器解析。<br> 于是我便将方向转变为创建index界面。</p></li><li><p>代码</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new pageName</span><br></pre></td></tr></table></figure><p> 使用上面这条命令创建新界面，在新创建的md文件中配置为：</p><pre><code> --- title: 标签 date: 2025-01-20 11:02:25 type: &quot;tags&quot; ---</code></pre><p> 其中：title为页面标题，type不能省略，表示其为tags<br> categories同理。</p></li><li><p>效果<br> <img src="/img/2025_1_20/004.png" alt="图片去外星球了"></p></li></ol><p>在遇到令人费解的问题时，仔细阅读提示。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC杂谈</title>
      <link href="/2025/01/19/JDBC%E6%9D%82%E8%B0%88/"/>
      <url>/2025/01/19/JDBC%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>JDBC——Java操纵关系型数据库的一套API</strong></p><p><img src="/img/2025_1_19/001.png" alt="图片去外星球了"><br>SUN公司定义接口，各个数据库厂商实现接口，使用JDBC编程，真正执行代码为jar包中的实现类。</p><p><strong>JDBC操纵MySQL</strong></p><ol><li><p>连接数据库</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法用于建立数据库连接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLConnection</span> &#123;</span><br><span class="line">    <span class="comment">// 方法用于建立数据库连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/pingpang_plus&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功连接到数据库!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;连接数据库时发生错误: &quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 成功连接则返回succeed，否则为failed。</p><ul><li>常见报错：<ul><li>No suitable driver found for jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb<br>  问题描述：这个错误表明JDBC驱动未正确加载。<br>  解决方案：查看相应的驱动是否成功配置。</li><li>Access denied for user ‘root‘@’localhost’ (using password: YES)<br>  问题描述：这个错误表明数据库连接时用户名或密码不正确。<br>  解决方案：看账密有没有错</li></ul></li></ul></li><li><p>查询操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeSearch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MySQLConnection</span> <span class="variable">mySQLConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySQLConnection</span>();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> mySQLConnection.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入要执行的查询语句:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">userQuery</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 接受用户输入的查询语句</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//System.out.println(&quot;实例化 Statement 对象...&quot;);</span></span><br><span class="line">                <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (userQuery.trim().toLowerCase().startsWith(<span class="string">&quot;select&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(userQuery);</span><br><span class="line">                    <span class="type">ResultSetMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> rs.getMetaData(); <span class="comment">// 获取元数据</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> metaData.getColumnCount();   <span class="comment">// 获取列数</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 打印表头</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">                        System.out.print(metaData.getColumnName(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 打印查询结果</span></span><br><span class="line">                    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">                            System.out.print(rs.getString(i) + <span class="string">&quot;\t&quot;</span>); <span class="comment">// 动态获取每列的数据</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;你输入的语句并不是查询语句&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                stmt.close();</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;执行查询时发生错误: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 输入你想输入的查询语句，即可完成查询操作。</p><ul><li>详细解释：<ul><li>public static Scanner scanner &#x3D; new Scanner(System.in);<br>  public：表明类、方法、变量可以在任何类中被访问，而且不受包的限制<br>  eg.<br> public int number;  &#x2F;&#x2F; 公开变量<br> MyClass obj &#x3D; new MyClass();<br> obj.number &#x3D; 10;  &#x2F;&#x2F; 其他类可以直接访问这个public变量<br>  static：使其后面修饰的无需创建实体就可访问<br>  eg.<br> 如果去掉 static，将变成一个实例变量：<br> public Scanner scanner &#x3D; new Scanner(System.in);<br> 必须通过 创建 MySQLSearch 类的对象 才能访问 scanner<br> MySQLSearch mySQLSearch &#x3D; new MySQLSearch(); &#x2F;&#x2F; 创建类的实例<br> mySQLSearch.scanner.nextLine(); &#x2F;&#x2F; 通过对象来访问scanner</li></ul></li></ul></li><li><p>插入操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLAdd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MYSQLAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MySQLConnection</span> <span class="variable">mySQLConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySQLConnection</span>();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> mySQLConnection.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;在下方输入插入语句：&quot;</span>);</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="type">int</span> <span class="variable">ok</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">                <span class="keyword">if</span>(ok != <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                statement.close();</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLDelete</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MySQLDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MySQLConnection</span> <span class="variable">mySQLConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySQLConnection</span>();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> mySQLConnection.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">                System.out.println(<span class="string">&quot;输入删除语句&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="type">int</span> <span class="variable">ok</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">                <span class="keyword">if</span>(ok != <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//close DB</span></span><br><span class="line">                statement.close();</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更新操作</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLUpdate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MySQLUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MySQLConnection</span> <span class="variable">mySQLConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySQLConnection</span>();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> mySQLConnection.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">                System.out.println(<span class="string">&quot;输入更新语句&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="type">int</span> <span class="variable">ok</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">                <span class="keyword">if</span>(ok != <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;更新成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//close DB</span></span><br><span class="line">                statement.close();</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;更新失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>JDBC却也存在许多弊端</strong></p><ol><li><p>硬编码——url、user、password难以改动</p><ul><li>硬编码：写在程序中固定的值，区别于通过变量、配置文件变化而变化的值。</li></ul></li><li><p>繁琐——获取字段太多</p><ul><li>当不使用获取元数据的方法执行查询操作时，得一个字段一个字段的获取<br> <img src="/img/2025_1_19/002.png" alt="图片去外星球了"></li></ul></li><li><p>资源浪费——频繁开关连接</p><ul><li>close方法</li></ul></li></ol><p>MyBatis作为一款持久层框架，较好的解决了上述问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为大数据结课总结与关于Linux的知识</title>
      <link href="/2025/01/18/%E5%8D%8E%E4%B8%BA%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/01/18/%E5%8D%8E%E4%B8%BA%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E8%AF%BE%E6%80%BB%E7%BB%93%E4%B8%8E%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>☆<strong>Linux基础命令总结</strong></p><ol><li>切换到根目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure><ol start="2"><li>切换到某个文件夹下（这里以root为例,root不要写成&#x2F;root）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd root</span><br></pre></td></tr></table></figure><ol start="3"><li>显示当前目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><ol start="4"><li>返回上一级</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure><ol start="5"><li>看有啥文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><ol start="6"><li>看看指定目录下有啥文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /路径</span><br></pre></td></tr></table></figure><ol start="7"><li><p>打包压缩，解包解压（tar命令）</p><ol><li>解压到指定文件夹</li></ol><p> z ：表示 tar 包是被 gzip 压缩过的 (后缀是.tar.gz)，所以解压时需要用 gunzip 解压 (.tar不需要)</p><p> x ：表示 从 tar 包中把文件提取出来</p><p> v ：表示 显示打包过程详细信息</p><p> f ：指定被处理的文件是什么</p><p> hadoop-2.8.3.tar.gz为待解压的文件</p><p> 后面是解压到指定文件夹<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.8.3.tar.gz -C /home/modules</span><br></pre></td></tr></table></figure></p><ol start="2"><li>解压到当前文件夹</li></ol> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.8.3.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>复制（cp）<br>前者为源文件，后者为目的地</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /home/extend_tools/hadoop-huaweicloud-2.8.3.33.jar /home/modules/hadoop-2.8.3/share/hadoop/common/lib/</span><br></pre></td></tr></table></figure><ol start="9"><li>创建新目录（mkdir）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir fileName</span><br></pre></td></tr></table></figure><p>也可以使用递归式创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/data/git</span><br></pre></td></tr></table></figure><ol start="10"><li>文本编辑器（vim）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim </span><br></pre></td></tr></table></figure><ol start="11"><li>查看当前有哪些进程（jps）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure><ol start="12"><li>删除（rm）<ol><li>普通删除</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f</span><br></pre></td></tr></table></figure><ol start="2"><li>强力删除</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf</span><br></pre></td></tr></table></figure><ol start="3"><li>删除根目录下所有的文件，即将系统格式化</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /*</span><br></pre></td></tr></table></figure></li><li>剪切（mv）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv</span><br></pre></td></tr></table></figure><p>☆<strong>Linux操作技巧</strong></p><ol><li><p>按下Tab键自动补齐，即使显示乱码也没问题。</p></li><li><p>esc -&gt;:q!强制退出<br>esc -&gt;:w!        写入再退出</p></li></ol><p>☆<strong>碎知识点</strong></p><ol><li>云服务是企业数字化转型的趋势：<ol><li>弹性扩展（方便加大带宽）</li><li>按需计费</li><li>轻资产（盘点资产时导出EXCEL即可）</li><li>SaaS化</li><li>安全可靠<br> 总结：提高效率，降低成本</li></ol></li><li>一些工具：<ol><li>XShell   –远程控制</li><li>Putty    –远程控制</li><li>WinSCP   –远程拷贝文件</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> HuaWei </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美国加州山火</title>
      <link href="/2025/01/18/%E7%BE%8E%E5%9B%BD%E5%8A%A0%E5%B7%9E%E5%B1%B1%E7%81%AB/"/>
      <url>/2025/01/18/%E7%BE%8E%E5%9B%BD%E5%8A%A0%E5%B7%9E%E5%B1%B1%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/2025_1_18/001.jpg" alt="图片去外星球了"></p><p>我高度关注美国加州山火事件，对美国人民表示慰问，同时也相信美国人民能够自力更生、美国政府有能力高效完成自救。<br>希望美国政府可以高效开展工作，能够妥善安置当地百姓并及时重建家园，让广大人民都能居者有其屋，过上安稳的生活。</p><p><strong>加州山火背后的政治舞台与气候畸变</strong></p><ol><li><p>持续干旱与极端强风的降临，火灾的发生只是时间早晚问题</p></li><li><p>供水优先给富人区，消防栓无水可用，消防员无法救火。美国政府懒惰，不清理落叶，不建设防火隔离带。</p></li><li><p>美国陈旧的电线杆与美国人民木制的房屋</p></li></ol><p><strong>美帝国主义早晚会崩溃瓦解</strong></p>]]></content>
      
      
      <categories>
          
          <category> 时政 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对接下来的设想</title>
      <link href="/2025/01/18/%E5%AF%B9%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E8%AE%BE%E6%83%B3/"/>
      <url>/2025/01/18/%E5%AF%B9%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E8%AE%BE%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对从现在到年底考研结束的设想</p><ol><li><p>关于专业课</p><p> 不再猛烈学习新型知识，以考研408计算机综合为主。同时对以前学过的知识加以巩固，在博客发一些MySQL、STM32、Java、Linux等知识。</p></li><li><p>关于考研课程</p><p> 初步设想为专硕：学数二、英二、政治与专业课。</p></li><li><p>关于情感</p><p> 等到自己长大成熟后再考虑吧。</p></li><li><p>未完待续……</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 任务 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM镜像源配置</title>
      <link href="/2025/01/16/NPM%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>/2025/01/16/NPM%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div>    <p>        NPM安装依赖卡慢的解决方法    </p></div><div>    <ol>        <li>            查看镜像使用状态            <code>                <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>            </code>            如果返回 https://registry.npmmirror.co 说明配置的是淘宝镜像。        </li>        <br>        <li>            设置淘宝镜像源             <code>            <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>            </code>            恢复官方镜像源            <code>            <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure>            </code>        </li>    </ol></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vercel加速Hexo静态博客访问</title>
      <link href="/2025/01/15/%E4%BD%BF%E7%94%A8Vercel%E5%8A%A0%E9%80%9FHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/"/>
      <url>/2025/01/15/%E4%BD%BF%E7%94%A8Vercel%E5%8A%A0%E9%80%9FHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div>    <p>        首先引用看到的一句话：        <blockquote>            <em>                “估计现在有很多同学使用了Hexo博客框架做一个博客并部署在了Github上，                这一切看起来很容易上手，于是开开心心地去写博客内容了，但到后面才发现这才是“苦难”的开始：原本以为是要写博客内容，                但更多的时间是被用来优化网站。因为强迫症‘患者’总是对网站各种不满意，于是自己挖坑又填坑。            </em>        </blockquote>    </p></div><div>    <ol>        <li>            网站代码 repo 导入 vercel：            <br>            在Vervel中new一个新项目，将GitHub上的网站后端代码仓库导入进去，            接下来就可以通过Domains中的几个链接来访问你的网站。            <img src="/img/2025_1_15/001.png" alt="图片去外星球了">        </li>        <br>        <li>            修改DNS以及设置域名：            <br>            在域名服务提供商（阿里云、GoDaddy 等）的 DNS 解析中增加一条 CNAME 记录（将你的域名指向另一个域名）            <img src="/img/2025_1_15/002.png" alt="图片去外星球了">            添加重定向：            <img src="/img/2025_1_15/003.png" alt="图片去外星球了">        </li>        <br>    </ol>    <div>        <p>尝试一下，现在网速可能块了些，但我使用中碰到的问题有：</p>        <ul>            <li>                白天起飞            </li>            <li>                晚上坠机            </li>        </ul>    </div>    <div>Mac        <p>            昨天晚上又研究了许久，使用Cloudfare等技术，还是不行，又把原来的好网站搞崩了，我又调了许久，才调回原来的样子。            打开Mac听音乐，也没听进去，        </p>        <br>        <p>            再次感叹，希望全面拥抱创新技术！        </p>    </div>    <div>        <p>            最后再填张图        </p>        <img src="/img/2025_1_15/004.png" alt="图片去外星球了">    </div></div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于腾讯云记录的笔记</title>
      <link href="/2025/01/14/%E5%85%B3%E4%BA%8E%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%B0%E5%BD%95%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/01/14/%E5%85%B3%E4%BA%8E%E8%85%BE%E8%AE%AF%E4%BA%91%E8%AE%B0%E5%BD%95%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>   <div>        <p>            各记录类型的设置方法：        </p>        <a href="https://cloud.tencent.com/document/product/302/3448">点击这里</a>    </div>    <br>    <br>    <div>        <p>            DNS解析中的A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录、SRV记录、URL转发等        </p>        <a href="https://www.cnblogs.com/bluestorm/p/10345334.html">点击这里</a>    </div>    <br>    <br>    <div>        <p>            CNAME 记录(有关Twitoo与Vercel)        </p>        <a href="https://cloud.tencent.com/document/product/302/3450">点击这里</a>    </div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tencent Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么自己注册域名</title>
      <link href="/2025/01/14/%E6%80%8E%E4%B9%88%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E5%9F%9F%E5%90%8D/"/>
      <url>/2025/01/14/%E6%80%8E%E4%B9%88%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>   <div>        <p>            <p>                这里得看阁下的财力了，金币多的买个好域名，本网站是我花了1块4毛3买了一年的域名。            </p>            <img src="/img/2025_1_14/001.jpg" alt="图片去外星球了">            <br>            <p>                我本想着为啥这么便宜，原来和手机卡是一个套路，第二年续费一年65块。😓            </p>        </p>    </div>    <br>    <br>    <div>        <p>            这里我就不再写的非常详细了，介绍下大体流程        </p>    </div>    <br>    <br>    <div>        <ul>            <li>                在网站搜索栏键入“购买域名”，随便找到一个厂商，点击去，我这里以腾讯云为例。            </li>            <li>                找到你想要的域名后缀，点击购买，并按要求进行实名认证操作（约半小时）。            </li>            <li>                便可以有自己的域名了。            </li>        </ul>    </div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Vercel被墙导致Twikoo无法评论的问题</title>
      <link href="/2025/01/13/%E8%A7%A3%E5%86%B3Vercel%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4Twikoo%E6%97%A0%E6%B3%95%E8%AF%84%E8%AE%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/13/%E8%A7%A3%E5%86%B3Vercel%E8%A2%AB%E5%A2%99%E5%AF%BC%E8%87%B4Twikoo%E6%97%A0%E6%B3%95%E8%AF%84%E8%AE%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><body><div style="color: brown;">    解决Vercel被墙导致Twikoo无法评论的问题：在Vercel添加子域名</div><br><br><div>    <span>        前提条件:    </span></div><br><div>    <ul>        <li>            用Vercel部署了Twikoo评论系统        </li>        <li>            一个自己的注册域名            <p>                    关于如何注册域名，请看我这篇文章<a href="/2025/01/14/怎么自己注册域名/index.html">点击这里</a>            </p>        </li>    </ul></div><br><br><div>    <ol>        <li>            <p>                在Vercel添加子域名            </p>            <span>                进入Vercel的twikoo项目后，点击Settings - Domains，在窗口里输入一个子域名（不要加http前缀）。这里我选择用twikoo.thirdshire.com作为我的子域名。            </span>            <img src="/img/2025_1_13/012.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            <span>                点击Add添加之后， Vercel会显示配置错误如下，并提示需要在DNS服务商处添加一条DNS记录。            </span>            <img src="/img/2025_1_13/013.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            <p>                为域名添加DNS记录            </p>            <span>                DNS服务商就是给网站添加各种A record/CNAME record的地方。                以我的腾讯云为例：            </span>            <img src="/img/2025_1_13/014.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            <span>                添加完DNS记录之后，回到Vercel并刷新界面。看到下面这个界面，就显示DNS已经配置成功了。            </span>            <img src="/img/2025_1_13/015.png" alt="图片去外星球了">            <span>                想要进一步确认的话，可以点击进入这个子域名，如果网站显示“Twikoo 云函数运行正常”，就说明这个子域名可以用来当作Twikoo的入口啦。            </span>        </li>        <br>        <br>        <li>            <span>                进入博客的配置文件，把博客文件的Twikoo设置里envID的链接替换成上面配置好的子域名。                这样配置完之后，国内用户也可以在Twikoo里面评论了～            </span>        </li>    </ol></div><br><br>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vercel </tag>
            
            <tag> VPN </tag>
            
            <tag> Twitoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评论组件的实现</title>
      <link href="/2025/01/13/%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/01/13/%E8%AF%84%E8%AE%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div>    今天实现了评论功能，在此详细写下开发过程。</div><br><br><div>    涉及到的技术栈：MonGoDB \ Tencent Cloud \ Vercel \ Butterfly Theme \ Hexo \ Twikoo</div><br><br><div>    详细描述    <ul>        <li>            总体描述:这里的评论系统选择了Twikoo，是一个简洁、安全、无后端的静态网站评论系统，基于腾讯云开发。只需要把获取到的环境ID(envId)填写到配置栏。        </li>    </ul>    <br>    <br>    <ol>        <li>            <span>因为没有自己的服务器，便使用免费的 Vercel 进行部署。Hexo 是静态博客，访客没有办法评论，添加一个自己的评论系统就会方便很多。</span>            <!-- 下面这个图片访问路径需要注意 -->            <img src="/img/2025_1_13/001.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            申请 MongoDB Atlas 账号,MongoDB Atlas 是 MongoDB Inc 提供的 MongoDB 数据库托管服务。免费账户可以永久使用 500 MiB 的数据库，足够存储 Twikoo 评论使用。            以下步骤针对新用户，在 MongoDB AtLas 注册完账号以后，创建免费 MongoDB 数据库。(接下来的位置可以选择为Hong Kong)            <img src="/img/2025_1_13/002.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            牢记你的用户名与密码            <img src="/img/2025_1_13/003.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            创建完用户以后，就可以 close 了。接下来在 Network Access 页面点击 Add IP Address 添加网络白名单。            因为 Vercel 的出口地址不固定，所以我们这里 Access List Entry 输入 0.0.0.0/0（允许所有 IP 地址的连接）。            <img src="/img/2025_1_13/004.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            接下来在 Database页面点击Connect，连接方式选择Drivers。            <img src="/img/2025_1_13/005.png" alt="图片去外星球了">            mongodb+srv://yemengstar:你的数据库密码@cluster0.zzsmj.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0            连接字符串包含了连接到 MongoDB 数据库的所有信息，一旦泄露会导致评论被任何人添加、修改、删除，并有可能获取你的 SMTP、图床token等信息。            请妥善记录这一字符串，之后需要填入到 Twikoo 的部署平台里。        </li>        <br>        <br>        <li>            <p>                在 vercel 中部署 twikoo            </p>            <span>在https://vercel.com中注册账号</span>            <a href="https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Ftwikoojs%2Ftwikoo%2Ftree%2Fmain%2Fsrc%2Fserver%2Fvercel-min">                点击这个链接，将 Twikoo 一键部署到 Vercel            </a>            <span>出现以下图，证明其已经配置好</span>            <img src="/img/2025_1_13/006.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            <span>                接下来进入 Settings – Environment Variables，添加环境变量 MONGODB_URI，值为前面记录的数据库连接字符串，即：            </span>            <img src="/img/2025_1_13/007.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            <span>                添加完毕点击 save，然后进入 Settings – Deployment Protection，设置 Vercel Authentication 为 Disabled，并 Save。            </span>            <img src="/img/2025_1_13/008.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            <span>                进入 Deployments , 然后在任意一项后面点击更多（三个点） , 然后点击 Redeploy , 最后点击下面的 Redeploy。等待重新部署完毕。            </span>            <img src="/img/2025_1_13/009.png" alt="图片去外星球了">        </li>        <br>        <br>        <li>            <span>                进入项目的 Overview，点击 Domains 下方的链接，如果环境配置正确，可以看到 “Twikoo 云函数运行正常” 的提示。            </span>            <img src="/img/2025_1_13/010.png" alt="图片去外星球了">            <span style="color: brown;">Vercel Domains（包含 https:// 前缀，例如 https://xxx.vercel.app）即为您的环境 id（envId）。</span>        </li>        <br>        <br>        <li>            <p>                将Twikoo接入 Butterfly            </p>            <span>                把 envId 修改成你使用的域名，把 visitor 修改为 true：            </span>            <img src="/img/2025_1_13/011.png" alt="图片去外星球了">        </li>        <br>        <br>    </ol>    <br>    <br>    <p>        看到这里，我相信你或许在你的网站上已经看见了评论功能，但遗憾的是，关掉科学上网工具后，不能评论。        请移步至另一篇文章：        <a href="/2025/01/13/解决Vercel被墙导致Twikoo无法评论的问题/index.html">点击这里</a>    </p></div><div>    这次评论功能的实现，丰富了我的技术栈。定期回顾这些知识，以保持清醒的头脑。</div>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超越时空的爱恋｜《来自星星的你》</title>
      <link href="/2025/01/12/%E8%B6%85%E8%B6%8A%E6%97%B6%E7%A9%BA%E7%9A%84%E7%88%B1%E6%81%8B%EF%BD%9C%E3%80%8A%E6%9D%A5%E8%87%AA%E6%98%9F%E6%98%9F%E7%9A%84%E4%BD%A0%E3%80%8B/"/>
      <url>/2025/01/12/%E8%B6%85%E8%B6%8A%E6%97%B6%E7%A9%BA%E7%9A%84%E7%88%B1%E6%81%8B%EF%BD%9C%E3%80%8A%E6%9D%A5%E8%87%AA%E6%98%9F%E6%98%9F%E7%9A%84%E4%BD%A0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div>    <p>        1.《来自星星的你》拍摄地之N首尔塔    </p>    <p>        N首尔塔也叫南山塔，位于海拔243米的南山之巅，高236.7米，是首尔的一大地标。    </p>    <img src="/img/2025_1_16/010.png" alt="图片去外星球了">    <p>        在N首尔塔，数字化的观景台、屋顶露台、及各种餐厅等一应俱全，还可360度俯瞰首尔风光，不仅是韩国人约会的天堂，也是外国游客的旅游胜地。    </p>    <img src="/img/2025_1_16/011.png" alt="图片去外星球了">    <p>        ▼《来自星星的你》都教授跟千颂伊▼    </p>    <img src="/img/2025_1_16/012.png" alt="图片去外星球了"></div><div>    <p>        2.《来自星星的你》拍摄地之小法国村    </p>    <img src="/img/2025_1_16/013.png" alt="图片去外星球了">    <img src="/img/2025_1_16/014.png" alt="图片去外星球了"></div>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我希望有个如你一般的人｜《从你的全世界路过》</title>
      <link href="/2025/01/11/%E6%88%91%E5%B8%8C%E6%9C%9B%E6%9C%89%E4%B8%AA%E5%A6%82%E4%BD%A0%E4%B8%80%E8%88%AC%E7%9A%84%E4%BA%BA%EF%BD%9C%E3%80%8A%E4%BB%8E%E4%BD%A0%E7%9A%84%E5%85%A8%E4%B8%96%E7%95%8C%E8%B7%AF%E8%BF%87%E3%80%8B/"/>
      <url>/2025/01/11/%E6%88%91%E5%B8%8C%E6%9C%9B%E6%9C%89%E4%B8%AA%E5%A6%82%E4%BD%A0%E4%B8%80%E8%88%AC%E7%9A%84%E4%BA%BA%EF%BD%9C%E3%80%8A%E4%BB%8E%E4%BD%A0%E7%9A%84%E5%85%A8%E4%B8%96%E7%95%8C%E8%B7%AF%E8%BF%87%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div>    <p>        <strong style="color:violet;">                <blockquote>                    陈末，我们分手吧。                </blockquote>        </strong>    </p></div><div><div>    <p>        1.我希望有个如你一般的人，如山间清爽的风，如古城温暖的光，只要最后是你就好。今天，你路过了谁？谁又丢失了你呢？从你的全世界路过。    </p>    <img src="/img/2025_1_16/001.png" alt="图片去外星球了"></div><br><div>    <p>        2.我偷偷地告诉你，有一个地方，叫做稻城。我要和我最心爱的人，一起去到那里，看蔚蓝的天空，看白色的雪山，看金黄的草地，        看一场秋天的童话。我要告诉她，如果没有住在你的心里，都是客死他乡。我要告诉她，相爱这件事情，就是永远在一起。    </p>    <img src="/img/2025_1_16/002.png" alt="图片去外星球了"></div><br><div>    <p>        3.当你全力以赴，打算对一个人好的时候，你就变成了傻子、聋子。眼里除了他，什么人都没有。就连伤害，都变成了一场恋爱的检测。你还傻不兮兮地鼓励自己，安慰自己，要坚强。    </p>    <img src="/img/2025_1_16/003.png" alt="图片去外星球了"></div><br><div>    <p>        4.荔枝，你走路永远看着天空，出门不记方向，你说你不敢出远门，怕回不来，以后不怕了，不用背路名，不用买地图，        我会在这个导航仪里，一直陪着你。只要有太阳照常升起，导航仪，就永远有电。我，永远在你身边。    </p>    <img src="/img/2025_1_16/004.png" alt="图片去外星球了"></div><br><div>    <p>        5.因为心里有爱，节目才会有爱，当我们自己感到孤独的时候，我们无法温暖别人。以前陈末可以温暖那么多孤独的灵魂，只是现在，他最孤独。    </p>    <img src="/img/2025_1_16/005.png" alt="图片去外星球了"></div><br><div>    <p>        6.我多希望，我的生活可以和墙上的画一样，越来越美好，幸福得不得了。    </p>    <img src="/img/2025_1_16/006.png" alt="图片去外星球了"></div><br><div>    <p>        7.人一辈子会听到很多心里话，我很庆幸，因为我曾经听到过，我也很难过，因为我无法忘掉。        沙城，就是一个人的记忆，你无法触碰，一旦双手陷入，整座城市就会轰隆隆地崩塌，所以我们泪流满面，步步回头，可是只能向前走。    </p>    <img src="/img/2025_1_16/007.png" alt="图片去外星球了"></div><br><div>    <p>        8.因为是最蓝的天，所以，你是天使。我站在那一天的天空下，和今天的自己，一起告诉你那个秘密吧。我要让全世界都知道，荔枝，我爱你。荔枝我爱你，我永远爱你。    </p>    <img src="/img/2025_1_16/008.png" alt="图片去外星球了"></div><br><hr><hr><div>    <p>        我希望有个如你一般的人，如山间清爽的风，如古城温暖的光，        从清晨，到夜晚，从山野，到书房，一切都没有关系，只要最后是你就好。一个人，终将拥有另一个人。对你点点头，贯彻未来，数遍，生命的公路牌。    </p>    <img src="/img/2025_1_16/009.png" alt="图片去外星球了"></div><hr style="color: dodgerblue;" size="5px"><div style="text-align: center;">    <p style="font-size: 50px; color: darkred;">        全劇終    </p></div>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;简历&#39;</title>
      <link href="/2025/01/10/%E7%AE%80%E5%8E%86/"/>
      <url>/2025/01/10/%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉啦, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5f702243623c38b1f7a6d2b88ecd127c43c938b1d2edf447f7c6fa76f6864363">e586eeac1f4220959faada9056b373f82b1c8c4feb3f0d34c0ef3fa164732f21b69151de9bd1d04b273215f9c6c90aa47120facfb048aa8b9ba9e1afcfe3c58a8101bac5ee01cd0c430621cf3f3257651e51c729b5ba2867afb0e19853057781ddb427c2e08b4ce0585b832c43f170f784ea44b4b2b2ac0f12495f9866b284a9ec9f7ed47c3f2a3db854d0ead7c7420ebc4ec84df565ded190bc1f8ac5eafbf6a34a2059690a2f6cab6118ec29bcf93c3ed685beaaa8e64c7f8fab109ce0583e5743086c1975449f38bb1ff277b0cdc5324a8d143684e32aae604e5bbd71e143bc50f15193c2b50c1c20ec8efc946d5ef302cd29268c2746365cc6d58081a2216e8111e5ebe8170ce15031c7c579230c22675af627c0482128f0942a00b75beb964e8715706c7aa980813fddf61581215ee90dcb1410bed1a86b6bcd53aecfff6bb6eec652d27ff57c46cc19dd45071a5217f9debf325bec427806047db5a43fd430e89f52a06222c7fb3720255bb09453994d3e4860c361abe2244e219c6e758e012c6b9015bb12dcf9d22132e170ce1ae4cb964343a4687c45db6e99feb616e2a77b377ee7db30e164ffaded10686f34c28fcefb559506d084fc70a8543fc0bdde0fc9204a2ab548013a3b1669d89b0c78065f84dd9f14126fa6942447b15dd1c653ef162c4e7bba905dd996ad44457f3a841f09a97382fd250ce3e2463180d9e8c0bc47261f05d019f720a75a0f7cb57e754e2a7fd00e8d6d5b7fefeaed244ad10e0a50b8464c6c3acd1f1e19d34d10fd8dd67aba7da24332b585137c6675b69a3dd360fe07bbd1d2d5cd156760b76888b42e5c2551a40bad371df99089f1c01cd24ba005185586a12c47e72ae2f8913ff140b684c6b928619cd59b6401bdeb85f068c65b40d0701ac1f9764560d06476960bb95b1fe16a45f73da006b459e8db15a7a1923ca17ea6de45e281911d4a71bbfdd3f1d952ac5c7126febc221d80d7e5c74575f41183664c78be3c98d47644ff8af63a9df1268d13c5a6843784c86b38ecf060e7ddd1638703f05de21778c4e6013e18108817c48ba3a787d9f3462764477379ee51435b53b9b79418df1f84f539476c4f68688a33ca2eac55b7792b18fca4e62647dc0e395ac8c9b0e0faf3e7a5550f4e7340b8ecc58e727d6b809ba1014abcd7c955c508d1d52102e52cb49e0bf8fe89a556e13a5a533fa6ca8f9a9f3802aa82ac0e59ba9ce3862b7fdee6cd07034188078d7b16d7972f591a42f81782a10466ee4398c97ecdde330571bed93cb7aa49f8775a566edff7a210064b966e7aba412a98f20522bfd3d5161a7876fad92b247ffce3ff76cbf6e17f435c77bfeb443bdd25b1a3ee3f27ed277985ab3157af0dd2420c359606f8dc86bed42c9d21b851b99ff527ec5648962454df4be4c96a197cc3675d82e04a5a53d044eb82db8680af7a9625bd5ca169f4596bd94f0cd4567f03113fbc82f159f48e29f6e1c493912f22cb05609b7f825e53de2af1dfe5e1c72773f8e032b2105a6a34794a6b3f3490ae1897c3ad1917a3defb31a9c743ffc463d3bfbec1d1d5cc9a62e46f91bfe0f3c7b3e05f2af52f4c5fb788d03e9d3c8f293363a255f4e4be</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你好呀, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>&#39;谈谈这些天用Hexo搭建网站的心得体会&#39;</title>
      <link href="/2025/01/09/%E8%B0%88%E8%B0%88%E8%BF%99%E4%BA%9B%E5%A4%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"/>
      <url>/2025/01/09/%E8%B0%88%E8%B0%88%E8%BF%99%E4%BA%9B%E5%A4%A9%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%9A%84%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我是1月6号晚上学了Vue渐进式JS框架与Spring Boot后端框架后，学了这些技术也是为了做更难于博客的类似于淘宝购物平台的PC+Phone+Pad<br>在线购物平台与购物平台后台管理系统。之前心里一直有做博客的想法，但然后便是突发奇想，在因特网上找关于搭建博客的信息，一看到基于NPM与Node.js<br>在GitHub上搭载网站，大致浏览了下操作步骤，这些知识点我都有所涉猎。于是我便说干就干，不一会便搭建成功了。</p><p>当时搭建静态网站后，心中有些激动，但也不是特别激动，因为这种localhost网站已经数见不鲜了，然而后来我使用host d命令的时候，静态网站竟然部署到GitHub<br>上了，并且给出了网站的具体URL。这太疯狂了，意味着全世界的人在相同的网络协议TCP&#x2F;IP下，键入我的网址，便可以访问由我亲自搭建的网站！</p><p>当天晚上睡前还在想着我的网站，其实当时也只是能记录博客，没啥别的功能，再一个就是通过我所了解的HTML&#x2F;CSS&#x2F;JavaScript在这个配置信息conf文件中增加<br>一些效果，比如副标题、换颜色、使之可以与用户交互等。当时做完这些已经十点半了，由于宿舍严苛的管理政策，便不得不回去。</p><p>好了，现在我回到驻马店了，继续写这篇文章。</p><p>7号便一直在想着这个网站的建设，7号上午解接触了主题。首先是Hexo社区的主题，配置好之后发现不行，我觉得是主题太过于老旧，于是找流行的主题。<br>在这里说下关于主题选取的建议：第一，有充分的说明文档；第二，有好的社区；第三，现在仍然在维护。我一开始选择的那个老旧的主题，只看到了它的炫酷，<br>前面说的三方面一点都没有涉猎，醉了，醉了。之后便配置新主题—butterfly。</p><p>7号下午与8号便在钻研这个主题，接下来我以“问题—当时状态—解决方法”的流程描述。</p><ul><li>问题1：如何用本地图片？<p>当时状态：使用本地绝对路径—在public目录下上传—重新建仓库重新上传—在GitHub上本网站的仓库上上传—等等等等<br>或是因为hexo clean把public删了，或是因为不知为啥新仓库的图片加载不出来，或是因为指定的URL不对，等等。</p><p>最终我在8号晚上回宿舍的时候，我用手机搜hexo相关知识，偶然间看到了一篇博客：public文件夹由source文件夹下的文件生成，<br>应该把图片放在source里，hexo clean 后，清理掉public，hexo g后，由source生成public，hexo d，便把public文件夹托管到GitHub。<br>9号早上到办公室试了下，果然可以，太好了！</p><p>感悟：挺累的。</p></li><li>问题2：关于butterfly的说明文档<p>当时状态：卧槽，这说明文档写的啥呀，什么状态栏，导航栏，front-page啥的，你倒是说清楚呀。“开发不规范，码友两行泪”。</p><p>解决方法：一点一点的尝试，当时使用了hexo d部署，因为不知道hexo s生成localhost预览，导致浪费了很多时间。官方的说明文档我看了好几遍，<br>也没看明白他说的啥。这个时候我就应该像8号晚上那样找其他人的博客了。就像唐太宗李世民说的那样“以人为镜，方可明得失”，最高的智慧结晶一定是<br>由团队协作弄好的，我感觉。因为个人毕竟有其局限性。</p><p>感悟：请写一份规范的接口文档！！！我很希望有那种小白也能看懂的文档，最好再加上图文说明。之前用EasyX的时候，感觉里面很多函数都可组成一个更大的、<br>更方便的函数。挺有意思的，当时自己写文档，研究自己的代码怎么调用自己写的API，遗憾的是，我写了一个按钮就不再写了，说好听点，就是不再维护了。</p></li></ul><p>特别写下这次我与butterfly维护者的交流。我带着问题进了社区群，我的QQ昵称吸引了某前辈注意，因为我的昵称就是“物联网2201陈宏阳”，我以谦卑的姿态<br>向他请教问题，他也不吝啬自己的笔墨，告诉我hexo命令的相关知识，并把他的博客分享给我，关于“存储本地图片的问题”，他给出的解决方案是“new repository<br>或者create aliyun OSS”，但现在我已经找到了更好的方法。我非常感谢他，也意识到了沟通交流的重要性。</p><p>我所希望的是把我这个博客做大做强，在获取些微开发者赞助与广告收益的同时提升自己的个人影响力，并且能够给开发者们提供小小的帮助。</p><p>先写这么多，若我想起来啥了，后续补充。</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈butterfly</title>
      <link href="/2025/01/08/%E8%B0%88%E8%B0%88butterfly/"/>
      <url>/2025/01/08/%E8%B0%88%E8%B0%88butterfly/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>尼玛的，这狗日的参考文档是个啥啊。</p><p>要是企业开发用这个技术文档，都塔莫的别干了，原地解散吧。</p><p>参考文档做的让人看得云里雾里的</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈情感</title>
      <link href="/2025/01/07/%E8%B0%88%E8%B0%88%E6%83%85%E6%84%9F/"/>
      <url>/2025/01/07/%E8%B0%88%E8%B0%88%E6%83%85%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉啦, 这个密码看着不太对, 请再试试." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ad7284af4d24e0ff8b6059303864d7fe3c672d04236288801d9a0bbe34a0dda4">e586eeac1f4220959faada9056b373f82b1c8c4feb3f0d34c0ef3fa164732f21b69151de9bd1d04b273215f9c6c90aa47120facfb048aa8b9ba9e1afcfe3c58a8101bac5ee01cd0c430621cf3f3257651e51c729b5ba2867afb0e19853057781ddb427c2e08b4ce0585b832c43f170f784ea44b4b2b2ac0f12495f9866b284a9ec9f7ed47c3f2a3db854d0ead7c7420ebc4ec84df565ded190bc1f8ac5eafbf6a34a2059690a2f6cab6118ec29bcf93c3ed685beaaa8e64c7f8fab109ce0583e5743086c1975449f38bb1ff277b0cdc5c1d1c467c4b0fd0e31dfee59b86ff47ae99c002353d261f0f927e37b6367179722fdd35bad6d290b3449bf5c411a4caa0e748dca5cd1f28ea879d071511909e373dec6d1b9c0469d137970eb65973c136472838b5936c75c27938d48ea3ebb2a6f8d5fbb827941061d51ff6acf41ef5e784673374f1a9f3070189790edf5c33376e351001876ab1c7735f5136d9e3ab38d977d6d6388692ea67eabf19e24f15ecb18c5c243339b5f80a13670d614682adb39871c0aed4d9b5c66a682008717ceb93495bcb5c83a6f6ded1eeeb71c2413955ea80e84e4e1934e50aed6003c011edd57d68c5217be04917009a37570eddee98a1406c0c7149dd890c8e092cd630071e1470ee92da0993c55fea02910d83b5dc47968ff53d556897393f3a40f824b70f44dd32a6df0861560aee5f2dd9838723feec18a131ff4405ef91a4f53c50846a6c9942974c7cc30f281da66df5e4ebf220914d520c32ff36a41ae250676020af6898c93cf54c9d082b28b2e7af6a832697db4afb19d8c8c06af91fac69995b15ed6ae1a720245ff37a4a61bf609b8c250d17f94fed6fe1c39fb6d920cc3e1682c6b27205b3ed64eaa52b586584286a49d37eb407d173619db2b7b2b84b68b3c67edf3446f6fb04c120a198907ce34c2f14414696f2f0a9be65e944bd24a412dc8f8a7f72f4079404dd6cfba438671c2aa641e8e3809dd7d62a07030745f0396342af5e53474f14b27b6afcc66ed94929901b8cc51c7aada9066837ff9fd74779f4b5cf8a54fb5e6b461c32f5328715e9c61bf031a7a0ee6cefdd4a850e18d4491aca7d745b17e3f147d5df3b94e5bcc6d2aa6981cb11041ed21f5c59f531739cefc4d97ed5ea33b00934e6087f7a62e52c73cdafa9125fae78f4088d89fb0b8b9bebf184a5069a6fe8e08f010c77dbdaec1b2b84a273fee8c0f7b8548fc7f7712d45fb12f71c609a4f03e8f5b8a8e289ba70f0b84ddcadfceebf2025ee6fcfd893826448adbc35488777b0090e419a69a0e350e2ea0628e0b6bd21610fcd3bb2a03e72ef11afa51068a8a71cbc93a6e2dbde73c35f8f36f4a463a2668291dd479016a410434dd4477788c701d73a6e540efdb5cbe05fcc6dc2adcd0eefaa2b5b503a8e77f36b0c7a552b813c5ae0d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">你好呀, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 深度议论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LOVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chen-first-blog</title>
      <link href="/2025/01/06/chen-first-blog/"/>
      <url>/2025/01/06/chen-first-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是2025年1月6号，我用Hexo与GitHub创造了第一个Blog</p><p>快乐送大家！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/01/06/hello-world/"/>
      <url>/2025/01/06/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>就跨年之夜与韩国空难发表自己的观点</title>
      <link href="/2024/12/31/%E5%B0%B1%E8%B7%A8%E5%B9%B4%E4%B9%8B%E5%A4%9C%E4%B8%8E%E9%9F%A9%E5%9B%BD%E7%A9%BA%E9%9A%BE%E5%8F%91%E8%A1%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%A7%82%E7%82%B9/"/>
      <url>/2024/12/31/%E5%B0%B1%E8%B7%A8%E5%B9%B4%E4%B9%8B%E5%A4%9C%E4%B8%8E%E9%9F%A9%E5%9B%BD%E7%A9%BA%E9%9A%BE%E5%8F%91%E8%A1%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%A7%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天是二〇二四年的最后一天，哦，不，是最后一个晚上，首先在这里祝大家新年快乐，愿大家在新的一年里平安健康、事业有成、幸福快乐。</p><p>看着街上喧嚣的场景：斑斓的霓虹灯、人头攒动的商场、响彻云霄的欢呼与尖叫。此刻的我坐在办公室里，享受片刻的宁静与飘忽的思考，觉得是有写一点东西的必要了。</p><p>今天焦作的夜是安静而又吵闹的，对我来说，没有丰富的活动，没有成群的消遣，有的只是一种宁静。就像水里一鞠皎洁的月亮，宁静地让我不忍用指尖触碰，生怕碰碎了一池的美梦。</p><p>注视着成群的人们来来往往，我更偏向于安静的独处。独行可能孤独，却能避免庸俗。我也会想，如果&nbsp;我感到寂寞的话，那又如何？靠着自己的影子安慰自己？那么会是什么促使我这种情绪的产生--应该是自己内心仍然不够强大，亦或是金玉其外，败絮其中。寂寞之所以是寂寞，并不是因为是也不过是因为寂寞本身罢了。是投身于一步一个脚印，还是选择三五成群的沆瀣一气，便不由得分说了。</p><p>这便引出了及时享乐与长期主义。做一个及时享乐的人，在歌舞厅里花天酒地、在钟点房里寻欢做爱。纸醉金迷，纸醉金迷，金钱至上，金钱至上。仿佛置身于浮华之中，听见奢靡的呢喃，愈加深刻地感受到其中的矛盾与荒诞。是物质的洪流淹没了灵魂？还是灵魂从未挣脱过物质的束缚？形形色色的人们，奏响了一曲海市蜃楼的交响乐。做一个长期主义的人，看清自己的样子，转变自己的内心。知道自己想要什么。当然个人的自我成长也不应该被诡辩的转嫁为趋于社会的认可同时被包装成达标的任务进而推向功利化的边缘。</p><p>面对着两条截然不同的人生道路，我想是应该选择后者了。疯狂的快感之后，留给自己的也不过是虚空的多巴胺，用发条不断上进本就离谱的阈值，必会在某一刻轰然倒塌，上层建筑沦为一地鸡毛的时候，便独自忏悔。出轨、嫖娼、赌博、吸毒，像一只在阴沟里的老鼠，窥探着灿烂的世界。此乃歪门邪道也。来到这世上一遭，不妨选择有意义的人生。</p><p>确实如此，话虽然这么说。但也不得不辩证式的看待。韩国客机撞墙失火，机上181人，179人遇难。明天与意外哪个先到，谁都不知道。上帝知道吗，宙斯知道吗，不得而知。有人说，人生无常，我们无法预知未来，好好爱自己，珍惜当下，去做想做的事，去爱想爱的人。有人说，明天不会向任何人做出承诺，不如在今天就让自己摆脱遗憾。现实猛烈地敲击着我的内心，那么，果真是这样的吗？？</p><p>我不知道。</p><p>看了《我与地坛》，便去了北海公园；看了来自星星的你，便准备去N首尔塔。我总是带着强烈的目的性的。可是现在，韩国政坛内乱给这个半岛的安全造成严重影响，客机失事事件又是给韩国旅游业致命一击。就先缓一缓吧。</p><p>评价《来自星星的你》：塑造了都敏俊这个既有神性，又有人性的人物。外星人与地球人的感情，在人类的情感世界与外星文明之间架起了一座彩虹桥。跨越物种的交流是通过爱，也仅仅是爱。同时这部剧的剧情也印证了三毛与柯西的对话。按照在我认为的韩剧的一般规律化套路中，这样的剧本确实不错，但当你深入思考，却也发现里面的问题经不起推敲，也罢，就当其为科幻感情剧吧。关于韩剧文化对中国人的入侵来说，其实，看韩剧的人在岁月中交付了梦想，但也在梦想中暂时脱离了现实，进行纯粹审美。尽管有时候想入非非，不过也是在那一瞬间回归了现实而已。这部剧的火爆（过去式）的其中一个哲学因素便是康德的审美无利害论，探究背后的逻辑性便是十分有意义，事物的运转规律便柳暗花明又一村了。</p><p>韩国可真是一个有趣的国家。读“关于韩国厌女文化、军国主义与色情泛滥”的时候，却怎么也看不明白，背后的事情可真复杂，但也不过是美帝国主义的一个傀儡、一枚棋子。挺有意思的，再一个就是领导人的更迭周期之短，短到连紧急领导人都得面临指控，估计连拍韩剧的都想不出这剧本吧。“李在明翻墙进国会，还在手机上直播”--可谓是：直播有角度，观众有热度，翻墙有力度，议会有速度。“尹锡瑞之妻的故事”：也不一一说了，可能跟玛丽莲梦露与肯尼迪的故事有关吧。荒唐！荒唐！</p><p>知行合一。因为了解而去认识，因认识便有了更好的了解。不早了，写到这吧。<br></p><br><br>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 深度议论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>北京之旅</title>
      <link href="/2024/11/23/%E5%8C%97%E4%BA%AC%E4%B9%8B%E6%97%85/"/>
      <url>/2024/11/23/%E5%8C%97%E4%BA%AC%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="/img/2024_11_23/001.png" alt="图片去外星球了"><p>“北海的菊花开了，我推着你去看看吧。”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—史铁生《秋天的怀念》<br>人都是这样吧，总想拥有自己未曾拥有的，却忽略自己现在所拥有的。或许我们应该在自我成长与家庭生活中找到平衡，向上求索固然重要，那么，爬升多高才算高？人的欲望是没有止境的。就像赌博，哎呀，我赌多少就戒了。不可能的。赌博就像出轨，有一次就有无数次。所以，常回家看看吧，末出现“子欲养而亲不待”，空悲切！</p><br><img src="/img/2024_11_23/002.png" alt="图片去外星球了"><p>奥林匹克公园的落日<br>天空是湛蓝色的，几朵云在空中慢悠悠地飘动，像蜉蝣一样漂浮于世间。夕阳西下，日光洒在湖面上，给平静的水面镀了层金，闪闪发光，照亮了我的眉发，也照亮了我的心。鸭子在水上游走，嘎嘎嘎，说着“北京欢迎你”（有点离谱）。</p><br><img src="/img/2024_11_23/003.png" alt="图片去外星球了"><p>中午没吃饱，看见自动贩卖机，非常激动。走近一看，原来是喂鸭子🦆的。呵呵。呵呵。不把你做成BeiJing&nbsp;Duck已经很好了！</p><br><img src="/img/2024_11_23/004.png" alt="图片去外星球了"><p>拉夫劳伦。<br>好贵的衣服<br><img src="/img/2024_11_23/005.png" alt="图片去外星球了">yeah，bicycle。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 旅行 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
